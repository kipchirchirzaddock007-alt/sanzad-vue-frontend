import {
  require_maplibre_gl
} from "./chunk-YY2SQDYP.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-4YJ6HKSX.js";

// node_modules/@geoman-io/maplibre-geoman-free/dist/maplibre-geoman.es.js
var import_maplibre_gl = __toESM(require_maplibre_gl());
var bm = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AYht+mLYpUHOwgopChOtlFRRxrFYpQIdQKrTqYXPoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJESv0sKLWK847iH97735e47QGhWmWaFEoCm22YmlRRz+VWx5xUhmmGMIi4zy5iTpDR8x9c9Any/i/Ms/7o/R79asBgQEIkTzDBt4g3imU3b4LxPHGVlWSU+J54w6YLEj1xXPH7jXHJZ4JlRM5uZJ44Si6UuVrqYlU2NeJo4pmo65Qs5j1XOW5y1ap2178lfGCnoK8tcpzWCFBaxBAkiFNRRQRU24rTrpFjI0HnSxz/s+iVyKeSqgJFjATVokF0/+B/87q1VnJr0kiJJIPziOB9jQM8u0Go4zvex47ROgOAzcKV3/LUmMPtJeqOjxY6AgW3g4rqjKXvA5Q4w9GTIpuxKQVpCsQi8n9E35YHBW6Bvzetb+xynD0CWepW+AQ4OgfESZa/7vLu3u2//1rT79wN2rHKoBaSKHQAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+gEBAUlKJesuC4AABWbSURBVHja7Z3fcxTHEce/t1ohYekA2QaBDBgocGLHNmW7Kg4pV9l5SeUleci/4b9H/0aeU3mJXXEF5yEmEOw4hgKFH7JBtpEQwhLS3eVhunV9w+7tHWh3e2Z7q64OyZJ18+Mz3+7pme4W7Bn6tBdXWwD4lYj3FMA0gCkAswCOAJihrw8AOAfgdwDOAmgDmKDf3YunB6ADYB3AdQB/BnANwEMAWwA2ANwH8Ii+3gSwA6BLv8vvvfWPD/VslPOflnVBLhQQYKQCiEl6zQCYB/AigGMA3gBwGMB+guQQgFfpfZKg2sunC2AbwCqA/9H7FoCfAKwA+ArAtwB+BHCPoNmmFwOzw6AAgMFigIyrFhMChgMERJu+PkJQHCNI5un7qfi9F+i9VUJf88TeBvCY3js06TcIih8Jkq9IUTZIde6R2myI3zNVMUBGAiOlST1NrwMAjgM4BeAtAUKbIJklxZim35WAJSXB4UPSlROcINkkRXlEcKwLcP4NYAnAHQJlk17bUlUMlIYDkgHGPpr8BwEcJWVYAPA2AXKcwGAza0ooRiL6s1Vx//Yy3rtCUbaEebVOYCwBuAJgmZTmOwBrBNETA6XBgAwBYw7ACYLhbYLjRYLlIP3MpOest2oAYhxgep5zvk0QrBEUPxIkVwia2wAeGCgNBGQEME4DeIcAOUHm1bRwztMaVWIv1WVHOOubZGbdJkAuAbhpoDQIELErlRSAcZq+nhNqMeEpReh91vOUpSNU5QGBcbMAlG5Tdr1aDYGjRROdYxZFYOzzHO4Y+8o3w3YIgCJQOLbSaYKatBoAR0JKsB/Ay2Q+nRkRjKaYoL0RQblBZtj3cPGWbQDdmCFpRQyGVI0DcFuybwL4FVx0+6SBMRYot+Ci9p8DuAq3dfwwdjVpRQxHCheoO0xKcY7geJNgaRsYY4GyTlBcJUiukbKswAUqd2KEpBUhHBM06WfgotznAVwgQE6TmbWffiYxMEYCpUsA/ETm1U0C5CKAy3DR+g36mU5MkLQiAsM3qeYJjg/pfZ6+P4X+wUEDYzxQOmRSPYSLyF8G8Cm934vR5GpFBEeWSXWB4DiGwXNSMDieCRJg8LzXtwTHxVhNrlZEcMzCRb59k+owgZOaauypmuwQCCsZJtcy3HZw8JCkEcHxCoB3AXxkJlUli2oqVHmGFqIZsRDdZUjai6vBBhXTwOHgo+gMx2/ofcEzqQyMvYfEP7YzhcGjOCBINgBshwpJGigciYBjwYPjFQFHYnCUDgovQKzi/rMsIAkuqJgGCscU+kfSz5NZxXDMmr9ROSS8YPmQsLrwUfqt0CBpBQrHS+SE/xzArwmSBYNDjfP+iJTjMoC/A/ianPgf4LaBg4GkFRAcLbjI9xyA1wH8Fu6G31m4yLjtVOmC5DFc5P063A3GvwD4D9yxlScIZHcrCQgO9jmOknK8Re9Hvd0Tg6N+5z0tGKtJAC1xDcEAeU44UuGQnyez6iz6x0ZsG1cfJBPon6A+65nCuwuadkiSQODIinMcMTiCgeTIsM0UzZCkyjvZh0PGOV4wOILwbydorBbQP67Cz24wMeO/GSAF6iE71o9z2G5VWJDIhc536u8A2Ggvrqp02lPFcEzBHV+wOEeckPBu1xYrSHtxVd1R+UQhHGxaHYA7bHghy7kzOIL0SfzNlgs0xge0+iOpwo7kTpyHCwaew2BaT4MjfCXxx3eFlKSrzR9RoyCe33EsZ4Wxs1XhQ5LkWAjHeONFk4okiuBIPL+DbwIexuCRdXvCh2SiYKwTLZAkSuDgSHnuqmJwRAlJnrWgJtKuxcSSAaU8v8Oe+CDJ8kdkALjZCuKZVi+jn7dqYGcDcWY19EsX5L3kz8YGiL9jyWmZXtZiaqVKVpFZuIyHfgfFYlrllSfojdFPdZZXqMIf4QVyDS5Dyjr6JRt6jQMk4wj7GfSPrquR2D2Cwi9BwAEyruxUpPI8ieROntbSC89rYp+luXAHlGurvbjaqiuAmNa8erANegIuV+5JuIyHIZtWWdnT/SI2G/DS4xT0Eacz4qPiecV7QuwzGR9p0xx4By5TCt8dqU1FagEkQz1O02uOvhdivMNP18n1N7LKoN2HuzwkA2S9HLOKt0NfR7+Sblb5t0mEm0aV2+rPh9t1q0haY4f46nEi0F2rvITPsoJTViHNFfTTdfZG6KcryC8gKitghZpvOGtO1K4ilQMygnqEMqhFJQOWMFgD0C/FvAWvDPOQnZ4HBJQsQX0VT9dQDLmUQ968qFVFUiUrRWjqIZ3tvFoaS/S1rCK74znrow42A8WmyAO4JNJchfc6ATKs5kkSCCSqVKRSQCJQDz+J8yMUly3z65Dv7nCNuhpSv3VF32yLv79GCnWL/nZW1Sz2VbRfMFOnIqmCFSIU9cjKSbsEV3WpsPDlOED4j/i9ngcM1xfMUjEG5Qypi8xRDOWQqFGRyjpJRM33w12a+RDAH+HO4cyhX15Zs0nVwWDOp4tk3txCTRVhCyr3noSLK8g7NbN4uq67tofLVT+gfv4TXJmFu3A1SirLq1W1giRkNx8lxzIE9fDriy8D+ALAJzR4XIqsllLJ9Hd6BMq25xc9FDtn/Nn44tmkYkh8FXkbwH8hEs/FaGLxsYJpsfuye3JT6UCxv8G1xLlozCcEyTKZW9vsY9QV8c0AhQOUm56pt4N+5vtp6DzO45/wXqA5M00K3qnKzKoEkIwj7bLBE8rh4AyBN5BdA6MDRak0BShyQ+GugGMD7tTsGfQzUmqFJGtBXYNLhF2Js55W2FiWzOMkmUep8YlSOLq0+t4H8E8AnwH4BoFUUVr/+FCvvbjKO2eP4M42bdFnfw3ABwDeo3HYr9Tc8k3ya7RjV5mzXvrkzEjEcIpeB5WaV9LneEjK8RmAfwD4EoMFK1Xnl2U1wWDJtC+pLZ9R2x5KE1GpmXVQzJtKEzykFa8E83B5Wo8rdc6lWbJBPsc1Uo5lAKu0CgdTyTXD5OLP/Q21ja+5tqHvZLBvebwFd4btB1KRbhUTt8qVoE2QtBWrh5++/yKZVWuhwZEBCgc416hNmTUFlapILXOnKvtfVoSSW4xanXJ/K3clZDhyIFlB9o5cB/puL9Y2f0r9IxnZ2Y8oVQ/2O4ZOnBjqfgtIhi0EmvwRX0WOoMLs8GlFELL/8QY1cEqZgkjTaikA02OvTcmsBWxS0QLG92L4mP9VuMOapQcNkwro5+uiL8LdX9CWW5cd1ydwRxtuwB0fuS9NjhjUI2N3S8Z5rlPbdytAKVkU/DIYfAemkpwFpQGSUd+j0oY9w2q6AXfQ7xLc2ard7c+Y4PAgkdvZt6jtuydnlZlZuQttmWZW2QriS+M8dAUHffW4icGTo1HCkQFJXvs1pRuqxVSvwsRi+/Yw9CWgzlIPjSto0/ugVTCXggSEG8WX8aehKzBYpB69mNUjwx8JQUUYkmkMJvcI1sSqvEGmHtGrSKULbimAZMQ/KpPEMdVjGy6qvESvRqnHEBXh/lhD/1CgFkgy51RZjnpSMnwyp9Nh6Ip/8Gnd7+CyjzRVPfJU5Ar1zSYqvKCkbU6V7YNwinttDro8cvEjXLCMt3UbpR4ZKsLbvpyuiFOk1t0nWVZJ6XdZkhIbw///FP00mZrMK44kf0sTYRM6zyHVsXBsop/wTp4k0GRmyVzFKGtuVXWaV5NzzubVFlwE+Su4Y+2aTAkNpuc99LNBbinqmxaeznYflpM+RFG0rJJsSqzDS2rQRPMqw8xiX4TzCWty1CudU0lD54LMUsLJ3Uw9rH8aD0hIK6RKhW1aHzVRQeS9D78EgT3WR40HRB7zXjH/o9AP4Qwujdzha6KJxSskV31qamBwlL6SfdT1+tAAacAE6JrvUeiLdJvcP4lNAnusjwwQe+wxQOyxxwCxp+qnZYDY4NuT3TeVnXkyQHROAG2HKLX1T2WnZg0QXYqh8Ri+iifnNqjWGiIGSEmQZF7kqiKdfkDzQvNtUAPEBl+FeaU1XVN0gGhLhKw9mbYW51xjuqZK51RSUUO0HekIoRyDBgXRmq6psiMwScl0azwUWGs6/QAddG2VwCo9RJmU3JDMY+UKQNGeM7juvtFYrqKWY/hlNlrrpZu8rPOaS1JX2Tey9LK2chWVz6lSAMm5dKMtjaVMp881uCebamYNqWWvqVxF7pwq67JbUlGDNtGvSqrFWfdrcJ+Azsq7VTvmM9QX2mrZS+f8Cc2p0hfcJLYGPYOjLmtwz9GuTaNURKjHPuoD7g9ttewrX3CrUpANhY66v2K+02AV0d4XtZnsZQOiOTuGv2qeplejVCRDPZ7qByWLRS1zqTRAAsnSZyoSRh/Ulg0zqYh8rVn6ilbPJGYVobYlAahHbfMoqZN8xSpyEv1t3yghEXDwtu5J5epRiyVSlYJoztLnq8gZAGfhIsi79yBigkT4HXzs/wi1+Yxi9ahlDpUKSEDZwmVk/RSACwDOwwXLZiP0R2R7F6itF6jt2tpbazb+pMIVQHO2cDY3+J7IeQAfAXiXJtALACZiUBFqAyvHArXxI2qzvBujqa21zZ+0xhVgjuzfnpLB8CeOVL/d08jtxdVOqDl8BRxDFwKF6lGbBVKlgoRQ0SnP9DgNF1WeClVJPDgOUptCMCVrrXhVuoKsf3yo115czasJOKtsxeLPMUE7OfMAzgF4Da48MuBKI2+1F1c7CCAjvOeQMxwL1KZz1MYZMQ7aqoHl1kysou+TihuaWVUW+kp7ye3PMwA+APA+gF/AHQEP4oJVxgWoY9SG96lNZyC2s6G3VF5tVXerPKXp1yW/A711yRmSabgt0PcA/B7AHwD8EsBxYZKojJOIOAebjMfps/+B2vIetW0aOpPDSd/jDmqq216Fky7NrG0yUZbo9aqYaD1lgySd9qPIrve+DHerbbu9uNrVYHIJ1WAVzNqtmifl0HpJTKqHnC9rqLiWfVrzivAzAC9Bb9odhmQ/nk40x6bLfTIBngDYoYWgclAEGPy59hEERzJ2q2aUmlXqLI7KAPFURNqUGp31PJ+kDeAVz66/DuAWOfEbVYOSA8YM3Db6SbgIub9bNaEcDt85H/BZq1x80pobzrsSh6ArJpIHSUvY85z04QaASwBuAridBwovEnsIBYaAcQJuG/cdcsRPoZ9CVHsCuDznfBM11ElMa+gAua/9Je2qvAz92Q1bos/YD2kTLKcJkCxQtmlguwQLxgXGA0ICO4F+fi8fjNP09RxBLe+Wa47jqHDOawEksJhIHiS+E+xPTgZliUB5SO3jK8d8TVQCM46C8c7UNL0O0N8+lQHGDClLijDKGKhxzutUkDz78qByMyvPL8kzb5Zo9WMT4Z5QlG0MJtPrFQDJGwSTAsp59DOyvE2AZIHRQlhpVVWFA1IlnXCWBnsf+kkCEAAkLRq0LFBepV069rX4mMQG3HmiUe5V+1kO2+jnFH4D/ZxeR2mBCRkMVc55bYAMiYmcFLZ9L6CBzQNlFm4Le4vMybcIDD50599r6OWolMxEz2lSOWUq+xbT4m+HCIY657xuBZGO2G2y2eVVz8kABzgLlCka3IO0EcHm1QaZRY9HVBAZpGQzi2Mycss25Az1/pyo1TmvFRChIk9ot+cmvU4EqiJ5oMidpin084TN0YTvjDD4/P+Y8pxtP+N6yHdVWD14PtTunNetILGqiA8KPFh4kCUw4+5iIRIoiubCbSg4q1db3EFcx/VV5AF9T9sp371QlUS8UmGKDXtNCuVIEF/h0cJ5UOf5tlThyhGTihSpC2BVrdSqR60K0kAVsScw9agdkBBWEHuaPfa1A2IqYuqhVT20KIipiKmH2jFXAYipiKmHRvXQpCCmIqYeKsdaDSCmIqYe2tRDm4KYiph6qBtjVYCMoCJdgyR4OLqhqIdGBclbYW7BHRXXVFfEnmczrXZoLG+FYCGoAyRDRW7AZQ65D+AnuBOw9oT5dGgM79OY3tCsHkD9Z7GKVOQR3LHnz9G/Mcf5nEK4Y23PoGm1BeB7AFdpTJcgcu1q/OAqs4jQShJkh9oz8oJ3lcZ2C0BXaxLwRHnHDpNkc9jDdMyDMpnVAuKVb5NOnTns4TvmA2OouYSEagURppY57HE65l3t9VXSADrYHHZzzE1BnsFhvwm9RXjsCdgxDwqQHKm+Ri8ztcwxN0CEw85JxW5mrUimIuaYN1ZBLDZijrkBsgedb5DUrh6dmBaxoAApiI2Yw67HtMo1g0NSjyAVpCA2UpTr1p5yAeFT2Pdi2UhJAx8M3kK8iH5cZIL+HVP2wVBMq8dwpR4u05gMbMWHph6h+iC+w75CA/IpvQ8rKWBPOXAUjkWIcAQLiICkcNUySCrxO+T2+0Uai29pbDqhwhE0IDHbvYE9WQFcLjcXvD8YNCDerpYFEOszrbKOAAUVEIxVQaSpZWe16jWt/IWpEzocUQBSIPVmall/GyAjntWqrRBkhOpRqNgxqEdUCjLCsXi7gbh3plVU0fJhTxrhIGZJ/2G4moBc+swCiM8OSKN2DWPyQfJMraf25U1Fnsu0ii5a3hhAMkytvMiuQfLsfkd00fJGASIgGbbamT/yfH5HVNHypvkgRfay+SN704/RRMsbpyCeP7Jj/khpfkcU0fJGAuKZWuaPlON3dGKGI3pAzB8xv8N8EPNHzO8wBTF/xPwOA8T8EfM7DJAA/JGm3h/hAGvj/Y7GAjKifd1poNPeE+rReL+j0YAU+CPLaGaWRpklZrnpfkfTFSTPH/kEwBc0QZrktEuzc5n64JMm+x3ySdHQZ/3jQ7324qqcGJxHK4Xb+uVt3wnEu/070kLRVDgaDUiOaZHCJZ07TO8MSYwFeoY55U01Nc3EyvFHRnFOe5HBMdJmRZPVo/GACEiGraSxQeLDkeeUd5sOhwEymtN+NzJzQ5qVd80pNx/keZx2floAjiP8pNhZO1Z/NafcAHnW1ZXhiGFnq0kqaSZWyU57oX0e2EQa2c8y9TBAxoUk9J2tkdtjcBgg40ASw86W7VgZIKVCMqrN3lMOh+1YmZNeDiRDdrYA4BUAs6IfW8rhsB0rA6SUyebvbOVB0lL6mSUctmNlgOy5imAIJNpiJMNiHQNwmHoYIGVDoi1GMrLfZHCYk16G0645RmKxDgNEHSRaYiQW6zBAVEGiKUZisQ4DRCUkGmIkFuswJ121415njMRiHQaI+mecGMleQlIEh8U6DBA1KoKKIRkLDlMPA6RJkBgcBohBYnAYIAbJeJAYHAaIQWJwGCAGyXiQGBwGiEGSA4nBYYAYJDmQGBwGiEGSAwkMDgPEIBkOicFhgBgkGZDM0L83DA4DxCDpP1xi4Sh9/R2ASwaHAdJkSPjuRgJgEv167QBwFcDfAPwLdhuw1sfug9QAiXDCH8Pd+Psa7v7GHXpdpu/do58xOGp6/g9eQPkxBqxc0wAAAABJRU5ErkJggg==";
var Su;
try {
  Su = "free";
} catch {
  Su = process.env.VITE_GEOMAN_VERSION || null;
}
var ut = "gm";
var se = `_${ut}`;
var at = Su === "pro";
var Wf = {
  draw: {
    marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "marker",
      settings: {
        exclusive: true
      }
    },
    circle_marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "circle_marker",
      settings: {
        exclusive: true
      }
    },
    text_marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "text_marker",
      settings: {
        exclusive: true
      }
    },
    circle: {
      type: "draw",
      eventType: "toggle",
      targetMode: "circle",
      settings: {
        exclusive: true
      }
    },
    ellipse: {
      type: "draw",
      eventType: "toggle",
      targetMode: "ellipse",
      settings: {
        exclusive: true
      }
    },
    line: {
      type: "draw",
      eventType: "toggle",
      targetMode: "line",
      settings: {
        exclusive: true
      }
    },
    rectangle: {
      type: "draw",
      eventType: "toggle",
      targetMode: "rectangle",
      settings: {
        exclusive: true
      }
    },
    polygon: {
      type: "draw",
      eventType: "toggle",
      targetMode: "polygon",
      settings: {
        exclusive: true
      }
    },
    freehand: {
      type: "draw",
      eventType: "toggle",
      targetMode: "freehand",
      settings: {
        exclusive: true
      }
    },
    custom_shape: {
      type: "draw",
      eventType: "toggle",
      targetMode: "custom_shape",
      settings: {
        exclusive: true
      }
    }
  },
  edit: {
    drag: {
      type: "edit",
      eventType: "toggle",
      targetMode: "drag",
      settings: {
        exclusive: true
      }
    },
    change: {
      type: "edit",
      eventType: "toggle",
      targetMode: "change",
      settings: {
        exclusive: true
      }
    },
    rotate: {
      type: "edit",
      eventType: "toggle",
      targetMode: "rotate",
      settings: {
        exclusive: true
      }
    },
    scale: {
      type: "edit",
      eventType: "toggle",
      targetMode: "scale",
      settings: {
        exclusive: true
      }
    },
    copy: {
      type: "edit",
      eventType: "toggle",
      targetMode: "copy",
      settings: {
        exclusive: true
      }
    },
    cut: {
      type: "edit",
      eventType: "toggle",
      targetMode: "cut",
      settings: {
        exclusive: true
      }
    },
    split: {
      type: "edit",
      eventType: "toggle",
      targetMode: "split",
      settings: {
        exclusive: true
      }
    },
    union: {
      type: "edit",
      eventType: "toggle",
      targetMode: "union",
      settings: {
        exclusive: true
      }
    },
    difference: {
      type: "edit",
      eventType: "toggle",
      targetMode: "difference",
      settings: {
        exclusive: true
      }
    },
    line_simplification: {
      type: "edit",
      eventType: "toggle",
      targetMode: "line_simplification",
      settings: {
        exclusive: true
      }
    },
    lasso: {
      type: "edit",
      eventType: "toggle",
      targetMode: "lasso",
      settings: {
        exclusive: true
      }
    },
    delete: {
      type: "edit",
      eventType: "toggle",
      targetMode: "delete",
      settings: {
        exclusive: true
      }
    }
  },
  helper: {
    shape_markers: {
      type: "helper",
      eventType: "toggle",
      targetMode: "shape_markers",
      settings: {
        exclusive: false,
        enabledBy: ["drag", "change", "rotate", "scale", "line_simplification"]
      }
    },
    snapping: {
      type: "helper",
      eventType: "toggle",
      targetMode: "snapping",
      settings: {
        exclusive: false
      }
    },
    pin: {
      type: "helper",
      eventType: "toggle",
      targetMode: "pin",
      settings: {
        exclusive: false
      }
    },
    snap_guides: {
      type: "helper",
      eventType: "toggle",
      targetMode: "snap_guides",
      settings: {
        exclusive: false
      }
    },
    measurements: {
      type: "helper",
      eventType: "toggle",
      targetMode: "measurements",
      settings: {
        exclusive: false
      }
    },
    auto_trace: {
      type: "helper",
      eventType: "toggle",
      targetMode: "auto_trace",
      settings: {
        exclusive: false
      }
    },
    geofencing: {
      type: "helper",
      eventType: "toggle",
      targetMode: "geofencing",
      settings: {
        exclusive: false
      }
    },
    zoom_to_features: {
      type: "helper",
      eventType: "click",
      targetMode: "zoom_to_features",
      settings: {
        exclusive: false
      }
    },
    click_to_edit: {
      type: "helper",
      eventType: "toggle",
      targetMode: "click_to_edit",
      settings: {
        exclusive: false
      }
    }
  }
};
var Am = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="m22.775 29.562 6.75-6.75-5.625-5.625-3.6 3.6-3.15-3.15 3.6-3.6-5.626-5.55-6.75 6.75zm25.95 26.101 6.75-6.825-5.624-5.625-3.6 3.6-3.15-3.15 3.6-3.6-5.55-5.55-6.75 6.75zm.6-46.126 5.25 5.25ZM16.7 59.039H5v-11.7l14.55-14.551L2 15.237l13.05-13.2 17.7 17.624L46.1 6.312q.676-.676 1.5-.976.826-.3 1.65-.3.826 0 1.65.3.826.3 1.5.976l5.326 5.325q.675.675.975 1.5.3.825.3 1.65t-.3 1.65q-.3.825-.975 1.5l-13.35 13.35L62 48.913l-13.125 13.05-17.551-17.55Zm-7.2-4.5h5.25l29.476-29.552-5.25-5.25L9.5 49.288Zm32.1-32.178-2.625-2.625 5.25 5.25Z"/>
</svg>`;
var jf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <circle cx="32" cy="32" r="26" fill="currentColor" fill-opacity=".15" stroke="currentColor" stroke-width="7"/>
    <circle cx="32" cy="32" r="5" fill="currentColor"/>
</svg>`;
var Lm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <circle cx="32" cy="32" r="26" fill="currentColor" fill-opacity=".15" stroke="currentColor" stroke-width="7"/>
    <path stroke="currentColor" stroke-dasharray="3" stroke-width="4" d="M6 32h52M32 6v52"/>
</svg>`;
var Tm = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   viewBox="0 0 64 64"
   version="1.1"
   id="svg2"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs2" />
  <path
     fill="none"
     d="M 0,0 H 24 V 24 H 0 Z"
     id="path1"
     style="display:inline" />
  <ellipse
     cx="32"
     cy="32"
     fill="currentColor"
     fill-opacity="0.15"
     stroke="currentColor"
     stroke-width="7"
     id="circle1"
     rx="26.787416"
     ry="15.158148" />
  <path
     stroke="currentColor"
     stroke-dasharray="3"
     stroke-width="4"
     d="M 6.4966994,32 H 58 M 32,18.552705 v 30.15073"
     id="path2"
     style="stroke-width:3;stroke-dasharray:3;stroke-dashoffset:0" />
</svg>
`;
var Cm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path
            fill="currentColor"
            d="M32 61.4 19.85 49.42l3.28-3.235 6.634 6.542V34.205H10.98l6.26 6.174-3.279 3.234L2.185 32l11.852-11.686 3.28 3.234-6.336 6.247h18.783V11.273l-6.261 6.174-3.28-3.234L32 2.6l11.777 11.613-3.28 3.234-6.26-6.174v18.522h18.782l-6.26-6.174 3.279-3.234L61.815 32 50.038 43.613l-3.28-3.234 6.261-6.174H34.236v18.522l6.634-6.542 3.28 3.234z"
    />
</svg>
`;
var Nm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <line x1="8" y1="50" x2="24" y2="20" stroke="currentColor" stroke-width="8"/>
    <line x1="24" y1="20" x2="40" y2="54" stroke="currentColor" stroke-width="8"/>
    <line x1="40" y1="54" x2="54" y2="10" stroke="currentColor" stroke-width="8"/>
    <circle cx="8" cy="50" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="24" cy="20" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="40" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`;
var Pm = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M32 62.81s23.107-21.898 23.107-38.512a23.107 23.107 0 0 0-46.214 0C8.893 40.912 32 62.809 32 62.809m0-26.958a11.554 11.554 0 1 1 0-23.107 11.554 11.554 0 0 1 0 23.107"/>
</svg>
`;
var Om = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <!-- Polygon -->
    <polygon points="8,28 40,6 55,35 51,55 18,54" fill="none" stroke="currentColor" stroke-width="8"/>

    <!-- Vertex Circles -->
    <circle cx="9" cy="28" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="40" cy="8" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="55" cy="35" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="50" cy="55" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="18" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`;
var Rm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <!-- Rectangle -->
    <polygon points="10,10 54,10 54,54 10,54" fill="none" stroke="currentColor" stroke-width="8"/>

    <!-- Vertex Circles -->
    <circle cx="10" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="10" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`;
var Dm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M39.063 42.14 22.288 28.12 7.96 44.603l11.338 9.854h9.059zm-3.498 12.317h25.941v5.465h-44.25L4.377 48.726a5.465 5.465 0 0 1-.542-7.711L34.311 5.958a5.465 5.465 0 0 1 7.712-.538l16.496 14.343a5.465 5.465 0 0 1 .541 7.709z"/>
</svg>`;
var Fm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M58.709 17.724c-.3-.6-.601-.901-.902-1.502l-.3-.601c-.301-.601-.602-.902-.902-1.503l-.3-.601c-.301-.601-.602-.902-1.203-1.503l-.6-.901 8.414-9.317-13.825.3-13.824.301 1.502 13.524 1.503 13.524 9.617-10.819v.3l.3.602c.301.3.301.6.602.6l.3.602c0 .6 0 .901.3 1.202.903 2.104 1.804 4.208 2.105 6.311.6 4.208 0 8.716-1.804 12.623l-.6 1.202-.301.3-.902 1.503-.3.601c-.601.601-1.202 1.503-1.804 2.104-1.502 1.503-3.305 3.005-5.109 3.907-1.803 1.202-3.907 1.803-6.311 2.404-2.104.301-4.508.601-6.612.301-2.404-.3-4.508-.902-6.612-1.503-2.103-.901-3.907-2.104-5.71-3.606l-1.202-1.202-.601-.902-.601-.601c-.3-.3-.601-.601-.601-.902l-.902-1.202-.3-.3-.602-1.203c0-.3-.3-.3-.3-.6l-.902-1.503-.3-.601-.902-2.705q-.901-3.607-.901-7.213V27.04c0-.601 0-.901.3-1.202l.3-1.803.602-1.803c.901-2.405 2.103-4.509 3.606-6.612q2.254-3.156 5.41-5.41c.6-.3.901-1.202.3-1.803-.3-.3-.6-.601-.901-.601h-.601l-.3.3c-2.706 1.202-4.81 3.006-6.913 4.809-2.104 2.104-3.607 4.508-5.11 7.213-2.704 5.41-3.606 11.42-2.404 17.431.3 1.503.601 2.705.902 4.207l.902 2.405c.3.3.6.6.6 1.202l.602 1.202c0 .3.3.601.3.601l.902 1.503c.3.601.6.901.901 1.503l.301.6c.3.301.601.902.902 1.203l2.103 1.803c2.104 2.104 4.809 3.907 7.514 5.41q4.057 2.254 9.016 2.705c1.503.3 3.005.3 4.508.3 1.803 0 3.306 0 4.809-.3 3.005-.602 6.311-1.503 9.016-3.006l.6-.3c.602-.3.903-.601 1.504-.902l2.103-1.202c.601-.3.902-.601 1.203-.902l.6-.6a3.622 3.622 0 0 0 1.503-1.504l.3-.3c.902-.902 2.105-2.104 2.706-3.005l1.803-2.705 1.202-1.804c3.005-5.71 4.208-12.322 3.306-18.633-.601-3.306-1.503-6.612-3.005-9.317z"/>
</svg>
`;
var Gm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path stroke="currentColor"
          stroke-width="3.8"
          d="m2.155 32.345 42.35-29.82M18.963 60.919l42.35-29.82M31.443 2.332l29.82 42.35M2.207 19.515l29.82 42.35"/>
</svg>
`;
var Bm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <path fill="currentColor"
          d="M6.962 3.385h50.076a3.577 3.577 0 0 1 3.577 3.577v50.076a3.577 3.577 0 0 1-3.577 3.577H6.962a3.577 3.577 0 0 1-3.577-3.577V6.962a3.577 3.577 0 0 1 3.577-3.577Zm3.577 7.154v42.922h42.922V10.539Zm7.154 7.154h28.614v7.153H17.693Zm0 14.307h28.614v7.154H17.693Z"/>
</svg>
`;
var Um = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M16.862 2.13 7.297 21.17a2.091 2.091 0 0 0-.193 1.288l4.107 24.166-7.618 13.15 3.619 2.096 7.997-13.804a2.091 2.091 0 0 0 .252-1.397l-4.119-24.235 9.256-18.428Zm40.876.255-1.25 2.49 2.668 1.341 1.25-2.49zm-2.593 5.16-2.68 5.337 2.668 1.341 2.682-5.338zm-4.022 8.007-2.682 5.338 2.67 1.34 2.681-5.337zm-18.67 5.83.055 6.984-11.118.087.056 7.242 11.12-.088.054 6.985 10.521-10.688zm18.927 2.817-2.945.5 1.001 5.89 2.945-.5zm1.502 8.835-2.945.5 1.001 5.89 2.945-.5zm1.502 8.834-2.945.5.74 4.355-.24.413 2.585 1.499.51-.881a1.494 1.494 0 0 0 .18-1zm-3.943 7.854-2.994 5.17 2.584 1.496 2.994-5.169zm-4.492 7.754-1.497 2.584 2.584 1.497 1.498-2.584z"/>
</svg>
`;
var zm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M41.687.926a2.173 2.173 0 0 0-.433.045c-4.075.232-7.358 3.618-7.358 7.747 0 .084.01.164.012.246l-12.987 4.261a7.842 7.842 0 0 0-6.126-3.563 2.173 2.173 0 0 0-.424-.043 2.173 2.173 0 0 0-.435.044c-4.073.232-7.358 3.618-7.358 7.747 0 3.143 1.901 5.869 4.604 7.097L8.377 35.11a2.173 2.173 0 0 0-.028.007C4.274 35.35.99 38.736.99 42.865c0 4.277 3.514 7.791 7.791 7.791 2.497 0 4.727-1.201 6.157-3.048l12.887 6.235a7.67 7.67 0 0 0-.139 1.44c0 4.277 3.515 7.791 7.792 7.791 4.278 0 7.793-3.514 7.793-7.792a7.67 7.67 0 0 0-1.885-5.027l.508-1.05-3.263-1.579 4.505-29.969.888-.29-.368-1.122a7.78 7.78 0 0 0 2.28-1.018l.447 1.364 4.72-1.547-.774-2.359-2.522.826a7.73 7.73 0 0 0 1.672-4.793c0-4.132-3.288-7.52-7.368-7.748a2.173 2.173 0 0 0-.424-.044zm0 4.346a3.414 3.414 0 0 1 3.447 3.446 3.415 3.415 0 0 1-3.446 3.447 3.414 3.414 0 0 1-3.446-3.447 3.414 3.414 0 0 1 3.445-3.446zm20.076 3.725a1.242 1.242 0 0 0-.382.062l-1.612.528.578 1.76-.293 1.94 2.456.37.486-3.234a1.242 1.242 0 0 0-1.233-1.426Zm-4.354 1.364-4.72 1.548.775 2.36 4.719-1.548-.774-2.36zm-22.153 2.732a7.877 7.877 0 0 0 3.735 2.922l-.062.408-.397.13.26.793-4.255 28.298-3.818-1.847-1.082 2.235 3.718 1.798a7.841 7.841 0 0 0-3.543 2.147l-13.272-6.42c.02-.23.035-.458.035-.692 0-2.888-1.609-5.408-3.969-6.745l2.912-11.012c3.74-.562 6.645-3.81 6.645-7.698l-.001-.02 13.094-4.297zm-20.885.87a3.414 3.414 0 0 1 3.445 3.447 3.414 3.414 0 0 1-3.445 3.447 3.414 3.414 0 0 1-3.447-3.447 3.414 3.414 0 0 1 3.446-3.446zm45.314 1.78-.738 4.912 2.456.37.738-4.912zM36.172 17.33l-1.793.588a1.242 1.242 0 0 0-.813.862l-.788 2.978 2.401.634.615-2.325 1.15-.377-.773-2.36zm22.405 5.781-.737 4.913 2.455.368.739-4.91zm-26.432 1.048-1.27 4.802 2.401.634 1.27-4.802zm25.325 6.32-.739 4.913 2.457.368.738-4.911-2.456-.37zm-27.23.882-1.27 4.802 2.402.634 1.27-4.801zm26.124 6.486-.739 4.91 2.455.37.74-4.912-2.457-.368zm-28.027.717-1.27 4.803 2.4.634 1.27-4.802-2.401-.634zm-19.555.856a3.414 3.414 0 0 1 3.446 3.446 3.414 3.414 0 0 1-3.446 3.447 3.414 3.414 0 0 1-3.445-3.447 3.414 3.414 0 0 1 3.445-3.446zm46.473 5.795-.739 4.91 2.456.37.74-4.911zm-11.124 5.072-1.082 2.236 4.47 2.164 1.083-2.237zm-8.651 1.55a3.414 3.414 0 0 1 3.445 3.446 3.414 3.414 0 0 1-3.445 3.447 3.414 3.414 0 0 1-3.447-3.447 3.414 3.414 0 0 1 3.446-3.446zm18.669.745-.358 2.378-2.953-1.428-1.083 2.236 4.472 2.163.541-1.117 1.228.183.608-4.046-2.455-.37z"/>
</svg>
`;
var qm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <circle cx="49.754" cy="50.219" r="10.098" fill="none" stroke="currentColor" stroke-width="5.1"/>
    <path fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="4.491"
          d="M44.516 26.657H17.842l6.669-11.55 6.668-11.55 6.669 11.55Z"/>
    <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="6"
          stroke-width="4.683" d="M4.481 40.605h20.761v19.093H4.481z"/>
</svg>
`;
var Ym = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path stroke="currentColor" fill="currentColor" stroke-width="2"
          d="M44.095 2.247a2.285 2.285 0 0 0-.135.04L12.025 12.762a2.285 2.285 0 0 0-1.497 1.588l-7.772 29.4a2.285 2.285 0 0 0 1.213 2.641L35.397 61.6a2.285 2.285 0 0 0 2.873-.754l22.64-32.582a2.285 2.285 0 0 0 .05-2.534L46.6 3.23a2.285 2.285 0 0 0-2.504-.982ZM43.7 7.182l12.203 19.12-5.167 1.76 1.052 3.09 2.031-.693L38.07 53.122l.01-1.375-3.262-.023-.034 4.5-27.13-13.127 6.975-26.38Zm3.946 21.932-6.18 2.105 1.052 3.09 6.18-2.105zm-9.27 3.157-2.329.793a1.632 1.632 0 0 0-1.105 1.534l-.03 4.068 3.265.024.02-2.91 1.232-.419zm-3.488 9.66-.047 6.529 3.264.023.048-6.528z"/>
</svg>
`;
var Hm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="m41.478 7.967-.033 3.069c1.887.02 3.772.337 5.561.933l.97-2.913a21.337 21.337 0 0 0-6.498-1.09Zm-3.294.215a21.567 21.567 0 0 0-6.298 1.915l1.332 2.766a18.518 18.518 0 0 1 5.401-1.641zm12.836 2.155-1.402 2.73a18.497 18.497 0 0 1 4.572 3.312l2.16-2.179a21.548 21.548 0 0 0-5.331-3.863ZM22.783 13.06c-11.848 0-21.486 9.638-21.486 21.486 0 11.849 9.638 21.486 21.486 21.486a21.37 21.37 0 0 0 14.288-5.466c.003 0 .006 0 .009.002.04-.036.078-.075.117-.11l.077-.072a21.285 21.285 0 0 0 1.51-1.532 22.128 22.128 0 0 0 .867-1.025 19.557 19.557 0 0 1-.88-.095c-.196-.025-.389-.058-.582-.09-.097-.015-.194-.028-.29-.045a18.378 18.378 0 0 1-1.576-.359l-.118-.03c-7.753-2.172-13.422-9.271-13.422-17.728a18.34 18.34 0 0 1 5.867-13.478c.1-.093.199-.185.3-.276.153-.136.31-.268.467-.4.097-.08.193-.163.291-.242.255-.203.514-.402.78-.592a21.534 21.534 0 0 0-1.76-.592l-.018-.005c-.176-.05-.355-.095-.533-.141-.132-.035-.263-.073-.397-.105-.213-.051-.43-.095-.646-.14-.077-.016-.153-.035-.231-.05H26.9a21.37 21.37 0 0 0-4.118-.4Zm35.728 3.64-2.472 1.82a18.424 18.424 0 0 1 2.61 5.004l2.907-.986a21.474 21.474 0 0 0-3.045-5.839Zm3.864 9.034-3.022.534c.328 1.86.37 3.772.118 5.642l3.042.409a21.448 21.448 0 0 0-.138-6.585zm-3.496 8.943a18.539 18.539 0 0 1-2.416 5.104l2.543 1.72a21.586 21.586 0 0 0 2.815-5.952zM54.703 42a18.288 18.288 0 0 1-4.428 3.492l1.505 2.675a21.348 21.348 0 0 0 5.173-4.08zm-6.995 4.69a18.512 18.512 0 0 1-5.526 1.158l.163 3.065a21.56 21.56 0 0 0 6.444-1.35z"/>
</svg>
`;
var Jm = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M44.698 2.661a1.644 1.644 0 0 1 2.328 0l9.866 9.866a1.644 1.644 0 0 1 0 2.329L24.004 47.744a1.644 1.644 0 0 1-.552.362L7.008 54.683a1.644 1.644 0 0 1-2.138-2.138l6.578-16.444a1.644 1.644 0 0 1 .362-.552zm-3.089 7.742 7.542 7.541 4.252-4.252-7.541-7.541zm5.216 9.866-7.54-7.54-21.378 21.376v.964h1.644a1.644 1.644 0 0 1 1.645 1.644v1.645h1.644a1.644 1.644 0 0 1 1.645 1.644v1.644h.963zM14.724 37.29l-.35.348L9.35 50.204l12.566-5.025.349-.35a1.644 1.644 0 0 1-1.07-1.538v-1.645h-1.644a1.644 1.644 0 0 1-1.644-1.644v-1.644h-1.644a1.644 1.644 0 0 1-1.54-1.07"/>
    <path stroke="currentColor" stroke-width="5.107"
          d="M6.298 59.53c3.44-1.692 6.88-3.384 10.558-4.319s7.594-1.111 11.719-.298c4.125.814 8.459 2.617 13.483 2.655 5.023.038 10.737-1.689 16.45-3.415"/>
</svg>
`;
var $m = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M31.226 17.87c-4.69 0-8.532 3.832-8.532 8.508 0 1.812.58 3.495 1.558 4.88l5.932 10.255c.831 1.085 1.383.879 2.074-.058l6.543-11.135c.132-.24.236-.493.327-.753a8.396 8.396 0 0 0 .628-3.19c0-4.675-3.841-8.506-8.53-8.506zm0 3.987a4.5 4.5 0 0 1 4.532 4.52 4.5 4.5 0 0 1-4.532 4.521 4.5 4.5 0 0 1-4.534-4.52 4.5 4.5 0 0 1 4.533-4.52z"/>
    <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="6"
          stroke-width="5" d="M8.97 53.509 4.423 19.145 35.698 4.199l23.88 25.127L43.06 59.801Z"/>
</svg>
`;
var Vm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <ellipse cx="4.907" cy="-32.051" fill="none" stroke="currentColor" stroke-dasharray="13.7543, 6.87718"
             stroke-width="5.489" rx="20.4" ry="13.713" transform="matrix(-.71127 .70292 -.86047 -.5095 0 0)"/>
    <path fill="currentColor"
          d="M34.597 25.275a1.934 1.934 0 0 0-2.04 2.165l2.922 31.37c.188 1.523 1.989 2.235 3.165 1.249l6.169-5.004 2.765 4.79c1.59 2.756 4.115 3.431 6.87 1.841 2.756-1.59 3.433-4.114 1.841-6.87l-2.755-4.773 7.31-2.803c1.443-.525 1.728-2.44.503-3.365L35.64 25.66a1.93 1.93 0 0 0-1.042-.383z"/>
</svg>
`;
var Xm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M1.947 25.554c-2.176 3.77-.867 8.656 2.903 10.832 2.126 1.229 4.607 1.346 6.757.539l8.252 12.152a7.79 7.79 0 0 0-.701 1.005c-2.176 3.77-.867 8.656 2.903 10.833 3.77 2.177 8.655.867 10.832-2.903 2.1-3.64.93-8.294-2.543-10.572a2.211 2.211 0 0 0-.36-.26 2.211 2.211 0 0 0-.404-.181 7.955 7.955 0 0 0-6.086-.432l-8.348-12.292c.19-.252.369-.512.53-.79 1.457-2.526 1.339-5.537-.03-7.907l8.202-8.256c3.494 1.335 7.562.025 9.575-3.229l13.899 2.913c.266 2.435 1.634 4.721 3.899 6.03 3.77 2.176 8.655.866 10.832-2.904 2.101-3.64.93-8.294-2.543-10.572a2.211 2.211 0 0 0-.36-.26 2.211 2.211 0 0 0-.403-.181c-3.71-1.87-8.328-.556-10.429 3.083-.084.147-.155.297-.228.446l-13.5-2.83c-.053-2.55-1.329-5.023-3.58-6.499a2.211 2.211 0 0 0-.358-.259 2.211 2.211 0 0 0-.405-.181c-3.708-1.87-8.326-.556-10.428 3.083-1.61 2.79-1.307 6.19.486 8.652l-7.84 7.892a2.211 2.211 0 0 0-.094-.036c-3.71-1.87-8.328-.556-10.429 3.084zm3.83 2.211a3.473 3.473 0 0 1 4.79-1.282 3.472 3.472 0 0 1 1.284 4.789 3.473 3.473 0 0 1-4.79 1.284 3.475 3.475 0 0 1-1.283-4.79ZM23.656 8.173a3.474 3.474 0 0 1 4.79-1.283 3.472 3.472 0 0 1 1.283 4.79 3.473 3.473 0 0 1-4.789 1.284 3.475 3.475 0 0 1-1.284-4.791zm-.666 44.12a3.474 3.474 0 0 1 4.79-1.283 3.472 3.472 0 0 1 1.283 4.79 3.473 3.473 0 0 1-4.79 1.284 3.475 3.475 0 0 1-1.283-4.791zm29.166-37.88a3.474 3.474 0 0 1 4.79-1.283 3.472 3.472 0 0 1 1.283 4.79 3.473 3.473 0 0 1-4.79 1.284 3.475 3.475 0 0 1-1.283-4.791z"/>
    <path fill="currentColor"
          d="M12.9 13.516c-.63.177-.685.37-.88.95l-1.069 3.18 2.995 1.006.844-2.506 2.074-.882-1.236-2.908zm19.209 5.25 4.378 4.554 2.277-2.19-4.379-4.554zm8.132 3.106 1.441 2.812 5.623-2.882-1.441-2.812zM5.448 46.082l3.144.304.608-6.29-3.145-.303zm4.623 3.728 5.762 2.592 1.297-2.88-5.762-2.593z"/>
</svg>
`;
var Wm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M1.717 38.645a2.675 2.668 79.7 0 0-.307 3.769L16.754 60.55a2.675 2.668 79.7 0 0 3.76.312l41.769-35.508a2.675 2.668 79.7 0 0 .307-3.769L47.246 3.45a2.675 2.668 79.7 0 0-3.76-.312zm5.486 2.352 37.702-32.05 11.892 14.056-2.717 2.31-4.458-5.269-2.033 1.729 4.457 5.269-3.11 2.643-4.457-5.268-2.034 1.728 4.458 5.27-3.106 2.64-4.458-5.27-2.033 1.73 4.457 5.268-3.11 2.644-6.194-7.32-2.033 1.728 6.193 7.32-3.11 2.645-4.457-5.269-2.034 1.729 4.458 5.268-3.106 2.64-4.458-5.268-2.033 1.73 4.457 5.268-3.11 2.643-4.457-5.268-2.034 1.729 4.458 5.268-2.098 1.783z"/>
</svg>
`;
var jm = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M7.839 34.833c-7.104-9.763-5.332-23.33 4.2-30.266C21.572-2.369 35.03.123 42.13 9.882L56.166 29.17c7.098 9.755 5.329 23.325-4.204 30.262-9.533 6.936-22.989 4.444-30.09-5.315L7.841 34.836Zm5.063-25.476c-6.079 5.766-7.006 15.598-1.634 22.98l.778 1.07 12.002-8.732zm3.43-2.495L27.476 22.18l12.002-8.733-.781-1.073c-5.37-7.38-15.01-9.522-22.367-5.512m25.643 10.014L14.54 36.836l10.762 14.79c5.818 7.997 16.653 9.842 24.163 4.378 7.51-5.465 9.088-16.342 3.267-24.342z"/>
</svg>
`;
var Zm = `\uFEFF<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M42.012 2.106a4.092 4.092 0 0 0-5.741.735 4.092 4.092 0 0 0 .572 5.607L23.964 23.45a8.185 8.185 0 0 0-10.458 2.142l5.18 4.005 5.454 4.218L7.87 59.22a1.124 7.304 37.712 0 0 1.54 1.19l20.494-22.138 5.454 4.217 5.18 4.005a8.185 8.185 0 0 0-.558-10.66l11.277-16.24a4.092 4.092 0 0 0 5.572-.858 4.092 4.092 0 0 0-.735-5.74z"/>
</svg>
`;
var Km = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <g fill="currentColor" stroke="currentColor">
        <path d="m37.62 5.028-.337.284-4.039 4.068 3.547 3.523L39.875 9.8l2.846.596 1.025-4.893-4.176-.877Zm9.995 6.393 9.787 2.053 1.026-4.895-9.787-2.05zm14.68 3.078 9.787 2.05 1.025-4.892-9.787-2.053zm-39.623 5.522 3.547 3.523 7.049-7.094-3.547-3.523zm-10.57 10.642 3.546 3.524 7.047-7.094-3.547-3.524zM1.529 41.306l3.55 3.523 7.046-7.096-3.547-3.523Zm70.977 4.027 3.91 3.115 3.44-4.387-1.118-6.55zM.947 48.319l5.617 8.274 4.137-2.809-5.617-8.273Zm62.211 8.744 3.91 3.116 6.233-7.82-3.91-3.116zM9.373 60.73l5.62 8.272 4.134-2.809-5.617-8.271zm44.438 8.067 3.91 3.115 6.232-7.82-3.91-3.117zM17.8 73.138l5.617 8.273 4.137-2.808-5.617-8.274zm26.662 7.388 3.91 3.116 6.232-7.82-3.91-3.116zm-18.236 5.022 5.617 8.273 4.136-2.81-5.617-8.272zm8.888 6.709 3.91 3.117 6.233-7.822-3.91-3.115z"
              stroke-width="3"
              transform="translate(2.517 1.586) scale(.60827)"/>
        <path d="M22.672 20.02a3.5 3.5 0 0 0-2.506 1.034L-.514 41.872a3.5 3.5 0 0 0-.412 4.434L18 74.176a3.5 3.5 0 0 0 5.633.216l33.494-42.038a3.5 3.5 0 0 0-2.018-5.605l-31.742-6.654a3.5 3.5 0 0 0-.695-.074zm1.121 7.317 24.32 5.098-26.992 33.877L6.484 44.759Z"
              stroke-width="3"
              transform="translate(2.517 1.586) scale(.60827)"/>
        <path d="m78.734 7.668 2.61 11.396-18.145 4.154 2.705 11.816L84.05 30.88l2.609 11.396L100 21.011Z"
              stroke-width="3"
              transform="translate(1.586 1.586) scale(.60827)"/>
    </g>
</svg>
`;
var Qm = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor" fill-rule="evenodd"
          d="M19.435 3.417c-4.478 0-8.96 1.693-12.343 5.076-6.766 6.766-6.766 17.913 0 24.679h.006c2.754 2.749 5.563 5.561 8.357 8.357 1.857 1.859 3.696 3.696 5.553 5.553l.949.949 1.892 1.898 9.496-9.49-1.898-1.898-6.502-6.502c-2.796-2.797-5.6-5.606-8.363-8.362-1.65-1.653-1.652-4.042 0-5.694 1.653-1.653 4.047-1.653 5.7 0l8.357 8.362 6.502 6.502 1.898 1.893 9.49-9.49-1.893-1.893-6.507-6.502-8.357-8.362c-3.384-3.383-7.86-5.076-12.337-5.076Zm0 2.68c3.789 0 7.577 1.432 10.439 4.294l8.357 8.362-5.694 5.694-8.357-8.362a6.7 6.7 0 0 0-9.496 0 6.697 6.697 0 0 0 0 9.49c2.76 2.755 5.566 5.564 8.363 8.362l-5.694 5.694c-2.795-2.796-5.601-5.607-8.357-8.357H8.99c-5.724-5.724-5.724-15.16 0-20.883 2.861-2.862 6.655-4.294 10.444-4.294ZM57.709 29.03a4.266 4.266 0 0 0-4.268 4.268c0 1.594.881 2.973 2.176 3.707-.714 4.997-1.424 10.107-2.176 15.037-.934 0-1.792.309-2.495.818l-7.115-5.07a4.25 4.25 0 0 0 .115-.965 4.27 4.27 0 1 0-4.268 4.268 4.23 4.23 0 0 0 2.732-1.012l6.973 4.965a4.22 4.22 0 0 0-.215 1.269 4.27 4.27 0 0 0 4.273 4.268 4.266 4.266 0 0 0 4.268-4.268 4.247 4.247 0 0 0-1.657-3.356l2.208-15.446c2.095-.273 3.722-2.045 3.722-4.215a4.27 4.27 0 0 0-4.273-4.268z"
    />
</svg>
`;
var ev = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <g fill="currentColor">
        <path d="m4.879 2.684-2.832 2.8L7.65 11.15l2.832-2.801Zm8.403 8.495-2.832 2.802 5.603 5.662 2.831-2.802zm8.404 8.494-2.832 2.8 5.602 5.664 2.832-2.802z"
        />
        <path d="M27.814 7.408a3.576 3.576 0 0 0-1.161-.176 3.2 3.2 0 0 0-.878.138l7.963 26.068L7.18 27.3c-.543 2.352 1.67 6.055 4.962 6.816l23.054 5.297 2.326 6.42c-2.27-.175-4.279 1.912-4.908 3.805-.535 1.698-.512 3.656.085 5.61.597 1.954 1.671 3.59 3.064 4.7 1.393 1.11 3.238 1.71 5.023 1.164 8.064-3.039 2.135-15.793.467-20.58 5.917 1.023 18.77 5.88 20.578-1.979.42-1.819-.306-3.616-1.509-4.929-1.203-1.313-2.909-2.27-4.9-2.73-1.99-.46-3.866-.547-5.602.303-1.737.849-3.768 2.642-3.468 4.73a6.17 6.17 0 0 0 .012.43l-6.563-1.794-6.88-22.632c-.702-2.297-3.445-3.99-5.108-4.523Zm26.824 26.88c1.36.315 2.472.99 3.116 1.692.644.703.795 1.307.684 1.79-.112.482-.511.956-1.399 1.305-.887.348-2.182.467-3.542.152-1.361-.314-2.472-.99-3.116-1.693-.644-.703-.797-1.304-.686-1.787.112-.482.513-.956 1.4-1.305a5.198 5.198 0 0 1 1.594-.327 6.98 6.98 0 0 1 1.949.173zM37.846 49.174c.333.069.71.25 1.13.585.746.594 1.497 1.654 1.905 2.99.408 1.335.379 2.635.092 3.545-.287.91-.731 1.34-1.205 1.484-.473.145-1.085.036-1.831-.558-.746-.594-1.496-1.655-1.904-2.99-.407-1.336-.378-2.637-.092-3.546.287-.91.732-1.342 1.206-1.486.118-.036.245-.057.38-.058.102 0 .207.011.319.034z"
        />
    </g>
</svg>
`;
var tv = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M41.233 7.917c-5.5 0-10.519 2.077-14.328 5.482a21.443 21.443 0 0 0-4.138-.404c-11.88 0-21.544 9.664-21.544 21.544s9.664 21.544 21.544 21.544c5.5 0 10.519-2.077 14.328-5.482 1.34.263 2.722.404 4.138.404 11.88 0 21.544-9.664 21.544-21.544S53.113 7.917 41.233 7.917zm-9.969 6.791a21.61 21.61 0 0 1 5.598 3.499l-2.01 2.33a18.557 18.557 0 0 0-4.8-2.999Zm-7.927 2.765 2.557 1.714a18.558 18.558 0 0 0-2.396 5.128l-2.955-.86a21.614 21.614 0 0 1 2.794-5.982zm15.86 3.08a21.413 21.413 0 0 1 3.46 5.628l-2.839 1.188a18.357 18.357 0 0 0-2.963-4.817zm-19.334 6.142 3.053.399a18.348 18.348 0 0 0 .144 5.654l-3.027.552a21.407 21.407 0 0 1-.17-6.605Zm23.834 2.63a21.81 21.81 0 0 1 .548 3.263c.1 1.1.115 2.207.044 3.31l-3.07-.195c.12-1.888-.056-3.8-.511-5.64zm-19.918 6.172a18.37 18.37 0 0 0 2.64 5.003l-2.466 1.84a21.427 21.427 0 0 1-3.083-5.84Zm17.042 3.016 3.004.666a21.486 21.486 0 0 1-2.404 6.15l-2.66-1.547a18.434 18.434 0 0 0 2.06-5.27zm-12.535 4.124a18.554 18.554 0 0 0 4.6 3.302l-1.392 2.744a21.611 21.611 0 0 1-5.363-3.85Z"/>
</svg>
`;
var nv = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M1.585 1.585V13.75h5.17v1.52H8.58v-1.52h5.17V1.585Zm3.041 3.041h6.083v6.083H4.626Zm9.429 2.13V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.474 0V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.475 0v1.597a1.521 1.521 0 0 0-.325.152l-15.686 9.758a1.52 1.52 0 0 0-.199 2.437l23.512 20.553a1.52 1.52 0 0 0 2.477-.78l4.212-17.037v.352h1.825v-3.65H55.42v1.524a1.52 1.52 0 0 0-.222-.296L43.002 8.741a1.521 1.521 0 0 0-.182-.16h2.259V6.754Zm5.475 0V8.58h3.65V6.755Zm5.474 0V8.58h3.65V6.755Zm3.042 2.432v3.65h1.825v-3.65Zm-13.752 2.549 10.757 11.137-3.57 14.446-20.087-17.559Zm13.752 2.926v3.65h1.825v-3.65ZM6.755 17.096v3.65H8.58v-3.65zm0 5.475v3.65h1.628a1.52 1.52 0 0 0 1.02.909l12.683 3.406 7.905 12.694c.168.27.417.481.712.602l13.39 4.576a1.52 1.52 0 0 0 1.157-2.814l-12.936-4.389L24.35 28.42a1.52 1.52 0 0 0-.896-.664L10.19 24.193a1.52 1.52 0 0 0-1.61.557v-2.178zm48.665 3.042v3.65h1.825v-3.65ZM6.755 28.046v3.65H8.58v-3.65zm48.665 3.042v3.65h1.825v-3.65ZM6.755 33.52v3.65H8.58v-3.65zm48.665 3.041v3.65h1.825v-3.65ZM6.755 38.996v3.65H8.58v-3.65zm48.665 3.041v3.65h1.825v-3.65zm-35.382.913c-3.454 0-6.287 2.833-6.287 6.287 0 3.076 2.248 5.654 5.179 6.183h-1.225v1.825h3.65V55.42h-.206c2.712-.5 4.777-2.796 5.055-5.59l.002-.002a1.52 1.52 0 0 0 0-1.18c-.314-3.168-2.922-5.698-6.168-5.698zM6.755 44.47v3.65H8.58v-3.65zm13.283 1.521a3.223 3.223 0 0 1 3.246 3.246 3.223 3.223 0 0 1-3.246 3.246 3.223 3.223 0 0 1-3.246-3.246 3.223 3.223 0 0 1 3.246-3.246zm35.382 1.52v2.738h-5.17v12.166h12.165V50.25h-5.17v-2.737ZM6.755 49.946v3.65H8.58v-3.65zm46.536 3.346h6.083v6.083H53.29ZM6.755 55.42v1.825h3.65V55.42H7.668Zm5.475 0v1.825h3.65V55.42zm10.95 0v1.825h3.65V55.42zm5.474 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42z"/>
</svg>
`;
var wt = {
  marker: Pm,
  circle: Lm,
  ellipse: Tm,
  circle_marker: jf,
  text_marker: Bm,
  line: Nm,
  rectangle: Rm,
  polygon: Om,
  freehand: Jm,
  custom_shape: qm,
  drag: Cm,
  change: Am,
  rotate: Fm,
  scale: Km,
  copy: zm,
  cut: Ym,
  split: ev,
  delete: Dm,
  union: tv,
  difference: Hm,
  line_simplification: Xm,
  lasso: Vm,
  shape_markers: null,
  snapping: Qm,
  pin: Zm,
  snap_guides: Gm,
  measurements: Wm,
  auto_trace: Um,
  geofencing: $m,
  zoom_to_features: nv,
  click_to_edit: jm
};
var $o = (t) => [
  {
    type: "circle",
    paint: {
      "circle-radius": t.circleMarkerRadius,
      "circle-color": t.fillColor,
      "circle-opacity": t.fillOpacity,
      "circle-stroke-color": t.lineColor,
      "circle-stroke-width": t.lineWidth,
      "circle-stroke-opacity": t.lineOpacity
    }
  }
];
var Mi = (t) => [
  {
    type: "circle",
    paint: {
      "circle-radius": 7,
      "circle-color": "#ffffff",
      "circle-opacity": 1,
      "circle-stroke-color": t.lineColor,
      "circle-stroke-width": 2,
      "circle-stroke-opacity": 1
    }
  }
];
var Vo = (t) => [
  {
    type: "line",
    paint: {
      "line-color": t.lineColor,
      "line-opacity": t.lineOpacity,
      "line-width": t.lineWidth
    }
  }
];
var Xo = () => [
  {
    type: "symbol",
    layout: {
      "icon-image": "default-marker",
      "icon-size": 0.18,
      "icon-allow-overlap": true,
      "icon-anchor": "bottom"
    }
  }
];
var Zt = (t) => [
  {
    type: "fill",
    paint: {
      "fill-color": t.fillColor,
      "fill-opacity": t.fillOpacity
    }
  },
  {
    type: "line",
    paint: {
      "line-color": t.lineColor,
      "line-opacity": t.lineOpacity,
      "line-width": t.lineWidth
    }
  }
];
var Wo = (t) => [
  {
    type: "circle",
    paint: {
      "circle-radius": 6,
      "circle-color": "#ffffff",
      "circle-opacity": 0.6,
      "circle-stroke-color": t.lineColor,
      "circle-stroke-width": 2,
      "circle-stroke-opacity": 1
    }
  }
];
var jo = () => [
  {
    type: "line",
    paint: {
      "line-color": "#00979f",
      "line-width": 1.8,
      "line-dasharray": [2, 1]
    }
  }
];
var mt = `__${ut}_`;
var qt = `${mt}id`;
var qc = 6e4;
var K = {
  // order matters here, layers order will be aligned according to these items
  ...at && { standby: `${ut}_standby` },
  // available only in the pro version
  main: `${ut}_main`,
  temporary: `${ut}_temporary`
};
var Zo = () => [
  {
    type: "symbol",
    layout: {
      "text-field": ["get", `${mt}text`],
      "text-justify": "center"
    },
    paint: {
      "text-color": "black",
      "text-halo-color": "#fff",
      "text-halo-width": 2
    }
  }
];
var Be = {
  [K.main]: {
    lineColor: "#278cda",
    lineOpacity: 0.8,
    lineWidth: 3,
    fillColor: "#4fb3ff",
    fillOpacity: 0.4,
    circleMarkerRadius: 10
  },
  [K.temporary]: {
    lineColor: "#ff5600",
    lineOpacity: 0.8,
    lineWidth: 3,
    fillColor: "#4fb3ff",
    fillOpacity: 0.4,
    circleMarkerRadius: 10
  },
  ...at && {
    [K.standby]: {
      lineColor: "#787878",
      lineOpacity: 0.8,
      lineWidth: 3,
      fillColor: "#a5a5a5",
      fillOpacity: 0.4,
      circleMarkerRadius: 10
    }
  }
};
var rv = {
  // order matters here, layers order will be aligned according to these items
  polygon: {
    [K.main]: Zt(Be[K.main]),
    [K.temporary]: Zt(Be[K.temporary]),
    ...at && { [K.standby]: Zt(Be[K.standby]) }
  },
  ellipse: {
    [K.main]: Zt(Be[K.main]),
    [K.temporary]: Zt(Be[K.temporary]),
    ...at && { [K.standby]: Zt(Be[K.standby]) }
  },
  rectangle: {
    [K.main]: Zt(Be[K.main]),
    [K.temporary]: Zt(Be[K.temporary]),
    ...at && { [K.standby]: Zt(Be[K.standby]) }
  },
  circle: {
    [K.main]: Zt(Be[K.main]),
    [K.temporary]: Zt(Be[K.temporary]),
    ...at && { [K.standby]: Zt(Be[K.standby]) }
  },
  circle_marker: {
    [K.main]: $o(Be[K.main]),
    [K.temporary]: $o(Be[K.temporary]),
    ...at && { [K.standby]: $o(Be[K.standby]) }
  },
  line: {
    [K.main]: Vo(Be[K.main]),
    [K.temporary]: Vo(Be[K.temporary]),
    ...at && { [K.standby]: Vo(Be[K.standby]) }
  },
  marker: {
    [K.temporary]: Xo(),
    [K.main]: Xo(),
    ...at && { [K.standby]: Xo() }
  },
  text_marker: {
    [K.main]: Zo(),
    [K.temporary]: Zo(),
    ...at && { [K.standby]: Zo() }
  },
  dom_marker: {
    // not a geojson source, layers aren't required
    [K.main]: [],
    [K.temporary]: [],
    ...at && { [K.standby]: [] }
  },
  center_marker: {
    [K.main]: Mi(Be[K.main]),
    [K.temporary]: Mi(Be[K.temporary]),
    ...at && { [K.standby]: Mi(Be[K.standby]) }
  },
  vertex_marker: {
    [K.main]: Mi(Be[K.main]),
    [K.temporary]: Mi(Be[K.temporary]),
    ...at && { [K.standby]: Mi(Be[K.standby]) }
  },
  edge_marker: {
    [K.main]: Wo(Be[K.main]),
    [K.temporary]: Wo(Be[K.temporary]),
    ...at && {
      [K.standby]: Wo(Be[K.standby])
    }
  },
  snap_guide: {
    // todo: check which sources can't display snap guides (and other shapes) and remove layers
    [K.main]: jo(),
    [K.temporary]: jo(),
    ...at && { [K.standby]: jo() }
  }
};
var iv = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="#0A95F0" class="bi bi-geo-alt-fill"
     viewBox="0 0 16 16">
    <path d="M8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10m0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6"/>
</svg>
`;
var sv = `<svg xmlns="http://www.w3.org/2000/svg" width="21" height="21">
    <circle cx="10.5" cy="10.5" r="9.213" fill="#fff" stroke="#278cda" stroke-width="2.303"/>
</svg>
`;
var av = {
  settings: {
    throttlingDelay: 10,
    awaitDataUpdatesOnEvents: true,
    useDefaultLayers: true,
    controlsPosition: "top-left",
    controlsUiEnabledByDefault: true,
    controlsCollapsible: false,
    controlsStyles: {
      controlGroupClass: "maplibregl-ctrl maplibregl-ctrl-group",
      controlContainerClass: "gm-control-container",
      controlButtonClass: "gm-control-button"
    },
    idGenerator: null,
    markerIcons: {
      default: iv,
      control: sv
    }
  },
  layerStyles: rv,
  controls: {
    draw: {
      marker: {
        title: "Marker",
        icon: wt.marker,
        uiEnabled: true,
        active: false
      },
      circle_marker: {
        title: "Circle Marker",
        icon: wt.circle_marker,
        uiEnabled: true,
        active: false
      },
      text_marker: {
        title: "Text Marker",
        icon: wt.text_marker,
        uiEnabled: true,
        active: false
      },
      circle: {
        title: "Circle",
        icon: wt.circle,
        uiEnabled: true,
        active: false
      },
      ellipse: {
        title: "Ellipse",
        icon: wt.ellipse,
        uiEnabled: true,
        active: false
      },
      line: {
        title: "Line",
        icon: wt.line,
        uiEnabled: true,
        active: false
      },
      rectangle: {
        title: "Rectangle",
        icon: wt.rectangle,
        uiEnabled: true,
        active: false
      },
      polygon: {
        title: "Polygon",
        icon: wt.polygon,
        uiEnabled: true,
        active: false
      }
    },
    edit: {
      drag: {
        title: "Drag",
        icon: wt.drag,
        uiEnabled: true,
        active: false
      },
      change: {
        title: "Change",
        icon: wt.change,
        uiEnabled: true,
        active: false
      },
      rotate: {
        title: "Rotate",
        icon: wt.rotate,
        uiEnabled: true,
        active: false
      },
      cut: {
        title: "Cut",
        icon: wt.cut,
        uiEnabled: true,
        active: false
      },
      delete: {
        title: "Delete",
        icon: wt.delete,
        uiEnabled: true,
        active: false
      }
    },
    helper: {
      shape_markers: {
        title: "Shape markers",
        icon: null,
        uiEnabled: false,
        active: false
      },
      snapping: {
        title: "Snapping",
        icon: wt.snapping,
        uiEnabled: true,
        active: false
      },
      zoom_to_features: {
        title: "Zoom to features",
        icon: wt.zoom_to_features,
        uiEnabled: true,
        active: false
      }
    }
  }
};
var Zf = typeof global == "object" && global && global.Object === Object && global;
var ov = typeof self == "object" && self && self.Object === Object && self;
var In = Zf || ov || Function("return this")();
var on = In.Symbol;
var Kf = Object.prototype;
var uv = Kf.hasOwnProperty;
var lv = Kf.toString;
var fs = on ? on.toStringTag : void 0;
function cv(t) {
  var e = uv.call(t, fs), r = t[fs];
  try {
    t[fs] = void 0;
    var s = true;
  } catch {
  }
  var u = lv.call(t);
  return s && (e ? t[fs] = r : delete t[fs]), u;
}
var hv = Object.prototype;
var fv = hv.toString;
function gv(t) {
  return fv.call(t);
}
var dv = "[object Null]";
var pv = "[object Undefined]";
var Yc = on ? on.toStringTag : void 0;
function ai(t) {
  return t == null ? t === void 0 ? pv : dv : Yc && Yc in Object(t) ? cv(t) : gv(t);
}
function Jn(t) {
  return t != null && typeof t == "object";
}
var mv = "[object Symbol]";
function Gi(t) {
  return typeof t == "symbol" || Jn(t) && ai(t) == mv;
}
function Ri(t, e) {
  for (var r = -1, s = t == null ? 0 : t.length, u = Array(s); ++r < s; )
    u[r] = e(t[r], r, t);
  return u;
}
var bt = Array.isArray;
var Hc = on ? on.prototype : void 0;
var Jc = Hc ? Hc.toString : void 0;
function Qf(t) {
  if (typeof t == "string")
    return t;
  if (bt(t))
    return Ri(t, Qf) + "";
  if (Gi(t))
    return Jc ? Jc.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
var vv = /\s/;
function yv(t) {
  for (var e = t.length; e-- && vv.test(t.charAt(e)); )
    ;
  return e;
}
var _v = /^\s+/;
function Ev(t) {
  return t && t.slice(0, yv(t) + 1).replace(_v, "");
}
function At(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var $c = NaN;
var xv = /^[-+]0x[0-9a-f]+$/i;
var wv = /^0b[01]+$/i;
var kv = /^0o[0-7]+$/i;
var Sv = parseInt;
function Vc(t) {
  if (typeof t == "number")
    return t;
  if (Gi(t))
    return $c;
  if (At(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = At(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = Ev(t);
  var r = wv.test(t);
  return r || kv.test(t) ? Sv(t.slice(2), r ? 2 : 8) : xv.test(t) ? $c : +t;
}
function vo(t) {
  return t;
}
var Mv = "[object AsyncFunction]";
var Iv = "[object Function]";
var bv = "[object GeneratorFunction]";
var Av = "[object Proxy]";
function dl(t) {
  if (!At(t))
    return false;
  var e = ai(t);
  return e == Iv || e == bv || e == Mv || e == Av;
}
var Ko = In["__core-js_shared__"];
var Xc = (function() {
  var t = /[^.]+$/.exec(Ko && Ko.keys && Ko.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
})();
function Lv(t) {
  return !!Xc && Xc in t;
}
var Tv = Function.prototype;
var Cv = Tv.toString;
function oi(t) {
  if (t != null) {
    try {
      return Cv.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var Nv = /[\\^$.*+?()[\]{}|]/g;
var Pv = /^\[object .+?Constructor\]$/;
var Ov = Function.prototype;
var Rv = Object.prototype;
var Dv = Ov.toString;
var Fv = Rv.hasOwnProperty;
var Gv = RegExp(
  "^" + Dv.call(Fv).replace(Nv, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Bv(t) {
  if (!At(t) || Lv(t))
    return false;
  var e = dl(t) ? Gv : Pv;
  return e.test(oi(t));
}
function Uv(t, e) {
  return t == null ? void 0 : t[e];
}
function ui(t, e) {
  var r = Uv(t, e);
  return Bv(r) ? r : void 0;
}
var Mu = ui(In, "WeakMap");
var Wc = Object.create;
var zv = /* @__PURE__ */ (function() {
  function t() {
  }
  return function(e) {
    if (!At(e))
      return {};
    if (Wc)
      return Wc(e);
    t.prototype = e;
    var r = new t();
    return t.prototype = void 0, r;
  };
})();
function qv(t, e, r) {
  switch (r.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, r[0]);
    case 2:
      return t.call(e, r[0], r[1]);
    case 3:
      return t.call(e, r[0], r[1], r[2]);
  }
  return t.apply(e, r);
}
function Yv() {
}
function Hv(t, e) {
  var r = -1, s = t.length;
  for (e || (e = Array(s)); ++r < s; )
    e[r] = t[r];
  return e;
}
var Jv = 800;
var $v = 16;
var Vv = Date.now;
function Xv(t) {
  var e = 0, r = 0;
  return function() {
    var s = Vv(), u = $v - (s - r);
    if (r = s, u > 0) {
      if (++e >= Jv)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function Wv(t) {
  return function() {
    return t;
  };
}
var ja = (function() {
  try {
    var t = ui(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
})();
var jv = ja ? function(t, e) {
  return ja(t, "toString", {
    configurable: true,
    enumerable: false,
    value: Wv(e),
    writable: true
  });
} : vo;
var Zv = Xv(jv);
function Kv(t, e) {
  for (var r = -1, s = t == null ? 0 : t.length; ++r < s && e(t[r], r, t) !== false; )
    ;
  return t;
}
function Qv(t, e, r, s) {
  for (var u = t.length, l = r + -1; ++l < u; )
    if (e(t[l], l, t))
      return l;
  return -1;
}
function ey(t) {
  return t !== t;
}
function ty(t, e, r) {
  for (var s = r - 1, u = t.length; ++s < u; )
    if (t[s] === e)
      return s;
  return -1;
}
function ny(t, e, r) {
  return e === e ? ty(t, e, r) : Qv(t, ey, r);
}
function eg(t, e) {
  var r = t == null ? 0 : t.length;
  return !!r && ny(t, e, 0) > -1;
}
var ry = 9007199254740991;
var iy = /^(?:0|[1-9]\d*)$/;
function yo(t, e) {
  var r = typeof t;
  return e = e ?? ry, !!e && (r == "number" || r != "symbol" && iy.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function Zs(t, e, r) {
  e == "__proto__" && ja ? ja(t, e, {
    configurable: true,
    enumerable: true,
    value: r,
    writable: true
  }) : t[e] = r;
}
function Ks(t, e) {
  return t === e || t !== t && e !== e;
}
var sy = Object.prototype;
var ay = sy.hasOwnProperty;
function pl(t, e, r) {
  var s = t[e];
  (!(ay.call(t, e) && Ks(s, r)) || r === void 0 && !(e in t)) && Zs(t, e, r);
}
function oy(t, e, r, s) {
  var u = !r;
  r || (r = {});
  for (var l = -1, f = e.length; ++l < f; ) {
    var h = e[l], p = void 0;
    p === void 0 && (p = t[h]), u ? Zs(r, h, p) : pl(r, h, p);
  }
  return r;
}
var jc = Math.max;
function uy(t, e, r) {
  return e = jc(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var s = arguments, u = -1, l = jc(s.length - e, 0), f = Array(l); ++u < l; )
      f[u] = s[e + u];
    u = -1;
    for (var h = Array(e + 1); ++u < e; )
      h[u] = s[u];
    return h[e] = r(f), qv(t, this, h);
  };
}
function ml(t, e) {
  return Zv(uy(t, e, vo), t + "");
}
var ly = 9007199254740991;
function vl(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= ly;
}
function Xi(t) {
  return t != null && vl(t.length) && !dl(t);
}
function Iu(t, e, r) {
  if (!At(r))
    return false;
  var s = typeof e;
  return (s == "number" ? Xi(r) && yo(e, r.length) : s == "string" && e in r) ? Ks(r[e], t) : false;
}
function tg(t) {
  return ml(function(e, r) {
    var s = -1, u = r.length, l = u > 1 ? r[u - 1] : void 0, f = u > 2 ? r[2] : void 0;
    for (l = t.length > 3 && typeof l == "function" ? (u--, l) : void 0, f && Iu(r[0], r[1], f) && (l = u < 3 ? void 0 : l, u = 1), e = Object(e); ++s < u; ) {
      var h = r[s];
      h && t(e, h, s, l);
    }
    return e;
  });
}
var cy = Object.prototype;
function yl(t) {
  var e = t && t.constructor, r = typeof e == "function" && e.prototype || cy;
  return t === r;
}
function hy(t, e) {
  for (var r = -1, s = Array(t); ++r < t; )
    s[r] = e(r);
  return s;
}
var fy = "[object Arguments]";
function Zc(t) {
  return Jn(t) && ai(t) == fy;
}
var ng = Object.prototype;
var gy = ng.hasOwnProperty;
var dy = ng.propertyIsEnumerable;
var Us = Zc(/* @__PURE__ */ (function() {
  return arguments;
})()) ? Zc : function(t) {
  return Jn(t) && gy.call(t, "callee") && !dy.call(t, "callee");
};
function py() {
  return false;
}
var rg = typeof exports == "object" && exports && !exports.nodeType && exports;
var Kc = rg && typeof module == "object" && module && !module.nodeType && module;
var my = Kc && Kc.exports === rg;
var Qc = my ? In.Buffer : void 0;
var vy = Qc ? Qc.isBuffer : void 0;
var zs = vy || py;
var yy = "[object Arguments]";
var _y = "[object Array]";
var Ey = "[object Boolean]";
var xy = "[object Date]";
var wy = "[object Error]";
var ky = "[object Function]";
var Sy = "[object Map]";
var My = "[object Number]";
var Iy = "[object Object]";
var by = "[object RegExp]";
var Ay = "[object Set]";
var Ly = "[object String]";
var Ty = "[object WeakMap]";
var Cy = "[object ArrayBuffer]";
var Ny = "[object DataView]";
var Py = "[object Float32Array]";
var Oy = "[object Float64Array]";
var Ry = "[object Int8Array]";
var Dy = "[object Int16Array]";
var Fy = "[object Int32Array]";
var Gy = "[object Uint8Array]";
var By = "[object Uint8ClampedArray]";
var Uy = "[object Uint16Array]";
var zy = "[object Uint32Array]";
var Je = {};
Je[Py] = Je[Oy] = Je[Ry] = Je[Dy] = Je[Fy] = Je[Gy] = Je[By] = Je[Uy] = Je[zy] = true;
Je[yy] = Je[_y] = Je[Cy] = Je[Ey] = Je[Ny] = Je[xy] = Je[wy] = Je[ky] = Je[Sy] = Je[My] = Je[Iy] = Je[by] = Je[Ay] = Je[Ly] = Je[Ty] = false;
function qy(t) {
  return Jn(t) && vl(t.length) && !!Je[ai(t)];
}
function _o(t) {
  return function(e) {
    return t(e);
  };
}
var ig = typeof exports == "object" && exports && !exports.nodeType && exports;
var Ns = ig && typeof module == "object" && module && !module.nodeType && module;
var Yy = Ns && Ns.exports === ig;
var Qo = Yy && Zf.process;
var Bi = (function() {
  try {
    var t = Ns && Ns.require && Ns.require("util").types;
    return t || Qo && Qo.binding && Qo.binding("util");
  } catch {
  }
})();
var eh = Bi && Bi.isTypedArray;
var _l = eh ? _o(eh) : qy;
var Hy = Object.prototype;
var Jy = Hy.hasOwnProperty;
function sg(t, e) {
  var r = bt(t), s = !r && Us(t), u = !r && !s && zs(t), l = !r && !s && !u && _l(t), f = r || s || u || l, h = f ? hy(t.length, String) : [], p = h.length;
  for (var d in t)
    (e || Jy.call(t, d)) && !(f && // Safari 9 has enumerable `arguments.length` in strict mode.
    (d == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    u && (d == "offset" || d == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    l && (d == "buffer" || d == "byteLength" || d == "byteOffset") || // Skip index properties.
    yo(d, p))) && h.push(d);
  return h;
}
function ag(t, e) {
  return function(r) {
    return t(e(r));
  };
}
var $y = ag(Object.keys, Object);
var Vy = Object.prototype;
var Xy = Vy.hasOwnProperty;
function Wy(t) {
  if (!yl(t))
    return $y(t);
  var e = [];
  for (var r in Object(t))
    Xy.call(t, r) && r != "constructor" && e.push(r);
  return e;
}
function Eo(t) {
  return Xi(t) ? sg(t) : Wy(t);
}
function jy(t) {
  var e = [];
  if (t != null)
    for (var r in Object(t))
      e.push(r);
  return e;
}
var Zy = Object.prototype;
var Ky = Zy.hasOwnProperty;
function Qy(t) {
  if (!At(t))
    return jy(t);
  var e = yl(t), r = [];
  for (var s in t)
    s == "constructor" && (e || !Ky.call(t, s)) || r.push(s);
  return r;
}
function og(t) {
  return Xi(t) ? sg(t, true) : Qy(t);
}
var e0 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var t0 = /^\w*$/;
function El(t, e) {
  if (bt(t))
    return false;
  var r = typeof t;
  return r == "number" || r == "symbol" || r == "boolean" || t == null || Gi(t) ? true : t0.test(t) || !e0.test(t) || e != null && t in Object(e);
}
var qs = ui(Object, "create");
function n0() {
  this.__data__ = qs ? qs(null) : {}, this.size = 0;
}
function r0(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var i0 = "__lodash_hash_undefined__";
var s0 = Object.prototype;
var a0 = s0.hasOwnProperty;
function o0(t) {
  var e = this.__data__;
  if (qs) {
    var r = e[t];
    return r === i0 ? void 0 : r;
  }
  return a0.call(e, t) ? e[t] : void 0;
}
var u0 = Object.prototype;
var l0 = u0.hasOwnProperty;
function c0(t) {
  var e = this.__data__;
  return qs ? e[t] !== void 0 : l0.call(e, t);
}
var h0 = "__lodash_hash_undefined__";
function f0(t, e) {
  var r = this.__data__;
  return this.size += this.has(t) ? 0 : 1, r[t] = qs && e === void 0 ? h0 : e, this;
}
function Kr(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var s = t[e];
    this.set(s[0], s[1]);
  }
}
Kr.prototype.clear = n0;
Kr.prototype.delete = r0;
Kr.prototype.get = o0;
Kr.prototype.has = c0;
Kr.prototype.set = f0;
function g0() {
  this.__data__ = [], this.size = 0;
}
function xo(t, e) {
  for (var r = t.length; r--; )
    if (Ks(t[r][0], e))
      return r;
  return -1;
}
var d0 = Array.prototype;
var p0 = d0.splice;
function m0(t) {
  var e = this.__data__, r = xo(e, t);
  if (r < 0)
    return false;
  var s = e.length - 1;
  return r == s ? e.pop() : p0.call(e, r, 1), --this.size, true;
}
function v0(t) {
  var e = this.__data__, r = xo(e, t);
  return r < 0 ? void 0 : e[r][1];
}
function y0(t) {
  return xo(this.__data__, t) > -1;
}
function _0(t, e) {
  var r = this.__data__, s = xo(r, t);
  return s < 0 ? (++this.size, r.push([t, e])) : r[s][1] = e, this;
}
function dr(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var s = t[e];
    this.set(s[0], s[1]);
  }
}
dr.prototype.clear = g0;
dr.prototype.delete = m0;
dr.prototype.get = v0;
dr.prototype.has = y0;
dr.prototype.set = _0;
var Ys = ui(In, "Map");
function E0() {
  this.size = 0, this.__data__ = {
    hash: new Kr(),
    map: new (Ys || dr)(),
    string: new Kr()
  };
}
function x0(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function wo(t, e) {
  var r = t.__data__;
  return x0(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
function w0(t) {
  var e = wo(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function k0(t) {
  return wo(this, t).get(t);
}
function S0(t) {
  return wo(this, t).has(t);
}
function M0(t, e) {
  var r = wo(this, t), s = r.size;
  return r.set(t, e), this.size += r.size == s ? 0 : 1, this;
}
function pr(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var s = t[e];
    this.set(s[0], s[1]);
  }
}
pr.prototype.clear = E0;
pr.prototype.delete = w0;
pr.prototype.get = k0;
pr.prototype.has = S0;
pr.prototype.set = M0;
var I0 = "Expected a function";
function xl(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(I0);
  var r = function() {
    var s = arguments, u = e ? e.apply(this, s) : s[0], l = r.cache;
    if (l.has(u))
      return l.get(u);
    var f = t.apply(this, s);
    return r.cache = l.set(u, f) || l, f;
  };
  return r.cache = new (xl.Cache || pr)(), r;
}
xl.Cache = pr;
var b0 = 500;
function A0(t) {
  var e = xl(t, function(s) {
    return r.size === b0 && r.clear(), s;
  }), r = e.cache;
  return e;
}
var L0 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var T0 = /\\(\\)?/g;
var C0 = A0(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(L0, function(r, s, u, l) {
    e.push(u ? l.replace(T0, "$1") : s || r);
  }), e;
});
function N0(t) {
  return t == null ? "" : Qf(t);
}
function wl(t, e) {
  return bt(t) ? t : El(t, e) ? [t] : C0(N0(t));
}
function Qs(t) {
  if (typeof t == "string" || Gi(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
function kl(t, e) {
  e = wl(e, t);
  for (var r = 0, s = e.length; t != null && r < s; )
    t = t[Qs(e[r++])];
  return r && r == s ? t : void 0;
}
function Ui(t, e, r) {
  var s = t == null ? void 0 : kl(t, e);
  return s === void 0 ? r : s;
}
function ug(t, e) {
  for (var r = -1, s = e.length, u = t.length; ++r < s; )
    t[u + r] = e[r];
  return t;
}
var th = on ? on.isConcatSpreadable : void 0;
function P0(t) {
  return bt(t) || Us(t) || !!(th && t && t[th]);
}
function O0(t, e, r, s, u) {
  var l = -1, f = t.length;
  for (r || (r = P0), u || (u = []); ++l < f; ) {
    var h = t[l];
    r(h) ? ug(u, h) : u[u.length] = h;
  }
  return u;
}
var lg = ag(Object.getPrototypeOf, Object);
var R0 = "[object Object]";
var D0 = Function.prototype;
var F0 = Object.prototype;
var cg = D0.toString;
var G0 = F0.hasOwnProperty;
var B0 = cg.call(Object);
function hg(t) {
  if (!Jn(t) || ai(t) != R0)
    return false;
  var e = lg(t);
  if (e === null)
    return true;
  var r = G0.call(e, "constructor") && e.constructor;
  return typeof r == "function" && r instanceof r && cg.call(r) == B0;
}
function U0() {
  this.__data__ = new dr(), this.size = 0;
}
function z0(t) {
  var e = this.__data__, r = e.delete(t);
  return this.size = e.size, r;
}
function q0(t) {
  return this.__data__.get(t);
}
function Y0(t) {
  return this.__data__.has(t);
}
var H0 = 200;
function J0(t, e) {
  var r = this.__data__;
  if (r instanceof dr) {
    var s = r.__data__;
    if (!Ys || s.length < H0 - 1)
      return s.push([t, e]), this.size = ++r.size, this;
    r = this.__data__ = new pr(s);
  }
  return r.set(t, e), this.size = r.size, this;
}
function xn(t) {
  var e = this.__data__ = new dr(t);
  this.size = e.size;
}
xn.prototype.clear = U0;
xn.prototype.delete = z0;
xn.prototype.get = q0;
xn.prototype.has = Y0;
xn.prototype.set = J0;
var fg = typeof exports == "object" && exports && !exports.nodeType && exports;
var nh = fg && typeof module == "object" && module && !module.nodeType && module;
var $0 = nh && nh.exports === fg;
var rh = $0 ? In.Buffer : void 0;
var ih = rh ? rh.allocUnsafe : void 0;
function gg(t, e) {
  if (e)
    return t.slice();
  var r = t.length, s = ih ? ih(r) : new t.constructor(r);
  return t.copy(s), s;
}
function V0(t, e) {
  for (var r = -1, s = t == null ? 0 : t.length, u = 0, l = []; ++r < s; ) {
    var f = t[r];
    e(f, r, t) && (l[u++] = f);
  }
  return l;
}
function X0() {
  return [];
}
var W0 = Object.prototype;
var j0 = W0.propertyIsEnumerable;
var sh = Object.getOwnPropertySymbols;
var Z0 = sh ? function(t) {
  return t == null ? [] : (t = Object(t), V0(sh(t), function(e) {
    return j0.call(t, e);
  }));
} : X0;
function K0(t, e, r) {
  var s = e(t);
  return bt(t) ? s : ug(s, r(t));
}
function bu(t) {
  return K0(t, Eo, Z0);
}
var Au = ui(In, "DataView");
var Lu = ui(In, "Promise");
var Di = ui(In, "Set");
var ah = "[object Map]";
var Q0 = "[object Object]";
var oh = "[object Promise]";
var uh = "[object Set]";
var lh = "[object WeakMap]";
var ch = "[object DataView]";
var e_ = oi(Au);
var t_ = oi(Ys);
var n_ = oi(Lu);
var r_ = oi(Di);
var i_ = oi(Mu);
var pn = ai;
(Au && pn(new Au(new ArrayBuffer(1))) != ch || Ys && pn(new Ys()) != ah || Lu && pn(Lu.resolve()) != oh || Di && pn(new Di()) != uh || Mu && pn(new Mu()) != lh) && (pn = function(t) {
  var e = ai(t), r = e == Q0 ? t.constructor : void 0, s = r ? oi(r) : "";
  if (s)
    switch (s) {
      case e_:
        return ch;
      case t_:
        return ah;
      case n_:
        return oh;
      case r_:
        return uh;
      case i_:
        return lh;
    }
  return e;
});
var s_ = Object.prototype;
var a_ = s_.hasOwnProperty;
function o_(t) {
  var e = t.length, r = new t.constructor(e);
  return e && typeof t[0] == "string" && a_.call(t, "index") && (r.index = t.index, r.input = t.input), r;
}
var Za = In.Uint8Array;
function Sl(t) {
  var e = new t.constructor(t.byteLength);
  return new Za(e).set(new Za(t)), e;
}
function u_(t, e) {
  var r = Sl(t.buffer);
  return new t.constructor(r, t.byteOffset, t.byteLength);
}
var l_ = /\w*$/;
function c_(t) {
  var e = new t.constructor(t.source, l_.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var hh = on ? on.prototype : void 0;
var fh = hh ? hh.valueOf : void 0;
function h_(t) {
  return fh ? Object(fh.call(t)) : {};
}
function dg(t, e) {
  var r = e ? Sl(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.length);
}
var f_ = "[object Boolean]";
var g_ = "[object Date]";
var d_ = "[object Map]";
var p_ = "[object Number]";
var m_ = "[object RegExp]";
var v_ = "[object Set]";
var y_ = "[object String]";
var __ = "[object Symbol]";
var E_ = "[object ArrayBuffer]";
var x_ = "[object DataView]";
var w_ = "[object Float32Array]";
var k_ = "[object Float64Array]";
var S_ = "[object Int8Array]";
var M_ = "[object Int16Array]";
var I_ = "[object Int32Array]";
var b_ = "[object Uint8Array]";
var A_ = "[object Uint8ClampedArray]";
var L_ = "[object Uint16Array]";
var T_ = "[object Uint32Array]";
function C_(t, e, r) {
  var s = t.constructor;
  switch (e) {
    case E_:
      return Sl(t);
    case f_:
    case g_:
      return new s(+t);
    case x_:
      return u_(t);
    case w_:
    case k_:
    case S_:
    case M_:
    case I_:
    case b_:
    case A_:
    case L_:
    case T_:
      return dg(t, r);
    case d_:
      return new s();
    case p_:
    case y_:
      return new s(t);
    case m_:
      return c_(t);
    case v_:
      return new s();
    case __:
      return h_(t);
  }
}
function pg(t) {
  return typeof t.constructor == "function" && !yl(t) ? zv(lg(t)) : {};
}
var N_ = "[object Map]";
function P_(t) {
  return Jn(t) && pn(t) == N_;
}
var gh = Bi && Bi.isMap;
var O_ = gh ? _o(gh) : P_;
var R_ = "[object Set]";
function D_(t) {
  return Jn(t) && pn(t) == R_;
}
var dh = Bi && Bi.isSet;
var F_ = dh ? _o(dh) : D_;
var G_ = 1;
var mg = "[object Arguments]";
var B_ = "[object Array]";
var U_ = "[object Boolean]";
var z_ = "[object Date]";
var q_ = "[object Error]";
var vg = "[object Function]";
var Y_ = "[object GeneratorFunction]";
var H_ = "[object Map]";
var J_ = "[object Number]";
var yg = "[object Object]";
var $_ = "[object RegExp]";
var V_ = "[object Set]";
var X_ = "[object String]";
var W_ = "[object Symbol]";
var j_ = "[object WeakMap]";
var Z_ = "[object ArrayBuffer]";
var K_ = "[object DataView]";
var Q_ = "[object Float32Array]";
var e1 = "[object Float64Array]";
var t1 = "[object Int8Array]";
var n1 = "[object Int16Array]";
var r1 = "[object Int32Array]";
var i1 = "[object Uint8Array]";
var s1 = "[object Uint8ClampedArray]";
var a1 = "[object Uint16Array]";
var o1 = "[object Uint32Array]";
var qe = {};
qe[mg] = qe[B_] = qe[Z_] = qe[K_] = qe[U_] = qe[z_] = qe[Q_] = qe[e1] = qe[t1] = qe[n1] = qe[r1] = qe[H_] = qe[J_] = qe[yg] = qe[$_] = qe[V_] = qe[X_] = qe[W_] = qe[i1] = qe[s1] = qe[a1] = qe[o1] = true;
qe[q_] = qe[vg] = qe[j_] = false;
function Ga(t, e, r, s, u, l) {
  var f, h = e & G_;
  if (f !== void 0)
    return f;
  if (!At(t))
    return t;
  var p = bt(t);
  if (p)
    f = o_(t);
  else {
    var d = pn(t), v = d == vg || d == Y_;
    if (zs(t))
      return gg(t, h);
    if (d == yg || d == mg || v && !u)
      f = v ? {} : pg(t);
    else {
      if (!qe[d])
        return u ? t : {};
      f = C_(t, d, h);
    }
  }
  l || (l = new xn());
  var _ = l.get(t);
  if (_)
    return _;
  l.set(t, f), F_(t) ? t.forEach(function(I) {
    f.add(Ga(I, e, r, I, t, l));
  }) : O_(t) && t.forEach(function(I, D) {
    f.set(D, Ga(I, e, r, D, t, l));
  });
  var E = bu, S = p ? void 0 : E(t);
  return Kv(S || t, function(I, D) {
    S && (D = I, I = t[D]), pl(f, D, Ga(I, e, r, D, t, l));
  }), f;
}
var u1 = 1;
var l1 = 4;
function $t(t) {
  return Ga(t, u1 | l1);
}
var c1 = "__lodash_hash_undefined__";
function h1(t) {
  return this.__data__.set(t, c1), this;
}
function f1(t) {
  return this.__data__.has(t);
}
function zi(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.__data__ = new pr(); ++e < r; )
    this.add(t[e]);
}
zi.prototype.add = zi.prototype.push = h1;
zi.prototype.has = f1;
function g1(t, e) {
  for (var r = -1, s = t == null ? 0 : t.length; ++r < s; )
    if (e(t[r], r, t))
      return true;
  return false;
}
function Ka(t, e) {
  return t.has(e);
}
var d1 = 1;
var p1 = 2;
function _g(t, e, r, s, u, l) {
  var f = r & d1, h = t.length, p = e.length;
  if (h != p && !(f && p > h))
    return false;
  var d = l.get(t), v = l.get(e);
  if (d && v)
    return d == e && v == t;
  var _ = -1, E = true, S = r & p1 ? new zi() : void 0;
  for (l.set(t, e), l.set(e, t); ++_ < h; ) {
    var I = t[_], D = e[_];
    if (s)
      var O = f ? s(D, I, _, e, t, l) : s(I, D, _, t, e, l);
    if (O !== void 0) {
      if (O)
        continue;
      E = false;
      break;
    }
    if (S) {
      if (!g1(e, function(T, M) {
        if (!Ka(S, M) && (I === T || u(I, T, r, s, l)))
          return S.push(M);
      })) {
        E = false;
        break;
      }
    } else if (!(I === D || u(I, D, r, s, l))) {
      E = false;
      break;
    }
  }
  return l.delete(t), l.delete(e), E;
}
function m1(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(s, u) {
    r[++e] = [u, s];
  }), r;
}
function Ml(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(s) {
    r[++e] = s;
  }), r;
}
var v1 = 1;
var y1 = 2;
var _1 = "[object Boolean]";
var E1 = "[object Date]";
var x1 = "[object Error]";
var w1 = "[object Map]";
var k1 = "[object Number]";
var S1 = "[object RegExp]";
var M1 = "[object Set]";
var I1 = "[object String]";
var b1 = "[object Symbol]";
var A1 = "[object ArrayBuffer]";
var L1 = "[object DataView]";
var ph = on ? on.prototype : void 0;
var eu = ph ? ph.valueOf : void 0;
function T1(t, e, r, s, u, l, f) {
  switch (r) {
    case L1:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return false;
      t = t.buffer, e = e.buffer;
    case A1:
      return !(t.byteLength != e.byteLength || !l(new Za(t), new Za(e)));
    case _1:
    case E1:
    case k1:
      return Ks(+t, +e);
    case x1:
      return t.name == e.name && t.message == e.message;
    case S1:
    case I1:
      return t == e + "";
    case w1:
      var h = m1;
    case M1:
      var p = s & v1;
      if (h || (h = Ml), t.size != e.size && !p)
        return false;
      var d = f.get(t);
      if (d)
        return d == e;
      s |= y1, f.set(t, e);
      var v = _g(h(t), h(e), s, u, l, f);
      return f.delete(t), v;
    case b1:
      if (eu)
        return eu.call(t) == eu.call(e);
  }
  return false;
}
var C1 = 1;
var N1 = Object.prototype;
var P1 = N1.hasOwnProperty;
function O1(t, e, r, s, u, l) {
  var f = r & C1, h = bu(t), p = h.length, d = bu(e), v = d.length;
  if (p != v && !f)
    return false;
  for (var _ = p; _--; ) {
    var E = h[_];
    if (!(f ? E in e : P1.call(e, E)))
      return false;
  }
  var S = l.get(t), I = l.get(e);
  if (S && I)
    return S == e && I == t;
  var D = true;
  l.set(t, e), l.set(e, t);
  for (var O = f; ++_ < p; ) {
    E = h[_];
    var T = t[E], M = e[E];
    if (s)
      var J = f ? s(M, T, E, e, t, l) : s(T, M, E, t, e, l);
    if (!(J === void 0 ? T === M || u(T, M, r, s, l) : J)) {
      D = false;
      break;
    }
    O || (O = E == "constructor");
  }
  if (D && !O) {
    var X = t.constructor, $ = e.constructor;
    X != $ && "constructor" in t && "constructor" in e && !(typeof X == "function" && X instanceof X && typeof $ == "function" && $ instanceof $) && (D = false);
  }
  return l.delete(t), l.delete(e), D;
}
var R1 = 1;
var mh = "[object Arguments]";
var vh = "[object Array]";
var _a = "[object Object]";
var D1 = Object.prototype;
var yh = D1.hasOwnProperty;
function F1(t, e, r, s, u, l) {
  var f = bt(t), h = bt(e), p = f ? vh : pn(t), d = h ? vh : pn(e);
  p = p == mh ? _a : p, d = d == mh ? _a : d;
  var v = p == _a, _ = d == _a, E = p == d;
  if (E && zs(t)) {
    if (!zs(e))
      return false;
    f = true, v = false;
  }
  if (E && !v)
    return l || (l = new xn()), f || _l(t) ? _g(t, e, r, s, u, l) : T1(t, e, p, r, s, u, l);
  if (!(r & R1)) {
    var S = v && yh.call(t, "__wrapped__"), I = _ && yh.call(e, "__wrapped__");
    if (S || I) {
      var D = S ? t.value() : t, O = I ? e.value() : e;
      return l || (l = new xn()), u(D, O, r, s, l);
    }
  }
  return E ? (l || (l = new xn()), O1(t, e, r, s, u, l)) : false;
}
function ko(t, e, r, s, u) {
  return t === e ? true : t == null || e == null || !Jn(t) && !Jn(e) ? t !== t && e !== e : F1(t, e, r, s, ko, u);
}
var G1 = 1;
var B1 = 2;
function U1(t, e, r, s) {
  var u = r.length, l = u;
  if (t == null)
    return !l;
  for (t = Object(t); u--; ) {
    var f = r[u];
    if (f[2] ? f[1] !== t[f[0]] : !(f[0] in t))
      return false;
  }
  for (; ++u < l; ) {
    f = r[u];
    var h = f[0], p = t[h], d = f[1];
    if (f[2]) {
      if (p === void 0 && !(h in t))
        return false;
    } else {
      var v = new xn(), _;
      if (!(_ === void 0 ? ko(d, p, G1 | B1, s, v) : _))
        return false;
    }
  }
  return true;
}
function Eg(t) {
  return t === t && !At(t);
}
function z1(t) {
  for (var e = Eo(t), r = e.length; r--; ) {
    var s = e[r], u = t[s];
    e[r] = [s, u, Eg(u)];
  }
  return e;
}
function xg(t, e) {
  return function(r) {
    return r == null ? false : r[t] === e && (e !== void 0 || t in Object(r));
  };
}
function q1(t) {
  var e = z1(t);
  return e.length == 1 && e[0][2] ? xg(e[0][0], e[0][1]) : function(r) {
    return r === t || U1(r, t, e);
  };
}
function Y1(t, e) {
  return t != null && e in Object(t);
}
function H1(t, e, r) {
  e = wl(e, t);
  for (var s = -1, u = e.length, l = false; ++s < u; ) {
    var f = Qs(e[s]);
    if (!(l = t != null && r(t, f)))
      break;
    t = t[f];
  }
  return l || ++s != u ? l : (u = t == null ? 0 : t.length, !!u && vl(u) && yo(f, u) && (bt(t) || Us(t)));
}
function J1(t, e) {
  return t != null && H1(t, e, Y1);
}
var $1 = 1;
var V1 = 2;
function X1(t, e) {
  return El(t) && Eg(e) ? xg(Qs(t), e) : function(r) {
    var s = Ui(r, t);
    return s === void 0 && s === e ? J1(r, t) : ko(e, s, $1 | V1);
  };
}
function W1(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
function j1(t) {
  return function(e) {
    return kl(e, t);
  };
}
function Z1(t) {
  return El(t) ? W1(Qs(t)) : j1(t);
}
function wg(t) {
  return typeof t == "function" ? t : t == null ? vo : typeof t == "object" ? bt(t) ? X1(t[0], t[1]) : q1(t) : Z1(t);
}
function K1(t, e, r, s) {
  for (var u = -1, l = t == null ? 0 : t.length; ++u < l; ) {
    var f = t[u];
    e(s, f, r(f), t);
  }
  return s;
}
function Q1(t) {
  return function(e, r, s) {
    for (var u = -1, l = Object(e), f = s(e), h = f.length; h--; ) {
      var p = f[++u];
      if (r(l[p], p, l) === false)
        break;
    }
    return e;
  };
}
var kg = Q1();
function eE(t, e) {
  return t && kg(t, e, Eo);
}
function tE(t, e) {
  return function(r, s) {
    if (r == null)
      return r;
    if (!Xi(r))
      return t(r, s);
    for (var u = r.length, l = -1, f = Object(r); ++l < u && s(f[l], l, f) !== false; )
      ;
    return r;
  };
}
var Sg = tE(eE);
function nE(t, e, r, s) {
  return Sg(t, function(u, l, f) {
    e(s, u, r(u), f);
  }), s;
}
function Mg(t, e) {
  return function(r, s) {
    var u = bt(r) ? K1 : nE, l = e ? e() : {};
    return u(r, t, wg(s), l);
  };
}
var rE = Object.prototype;
var iE = rE.hasOwnProperty;
var sE = Mg(function(t, e, r) {
  iE.call(t, r) ? ++t[r] : Zs(t, r, 1);
});
var tu = function() {
  return In.Date.now();
};
var aE = "Expected a function";
var oE = Math.max;
var uE = Math.min;
function Ig(t, e, r) {
  var s, u, l, f, h, p, d = 0, v = false, _ = false, E = true;
  if (typeof t != "function")
    throw new TypeError(aE);
  e = Vc(e) || 0, At(r) && (v = !!r.leading, _ = "maxWait" in r, l = _ ? oE(Vc(r.maxWait) || 0, e) : l, E = "trailing" in r ? !!r.trailing : E);
  function S(Y) {
    var j = s, x = u;
    return s = u = void 0, d = Y, f = t.apply(x, j), f;
  }
  function I(Y) {
    return d = Y, h = setTimeout(T, e), v ? S(Y) : f;
  }
  function D(Y) {
    var j = Y - p, x = Y - d, k = e - j;
    return _ ? uE(k, l - x) : k;
  }
  function O(Y) {
    var j = Y - p, x = Y - d;
    return p === void 0 || j >= e || j < 0 || _ && x >= l;
  }
  function T() {
    var Y = tu();
    if (O(Y))
      return M(Y);
    h = setTimeout(T, D(Y));
  }
  function M(Y) {
    return h = void 0, E && s ? S(Y) : (s = u = void 0, f);
  }
  function J() {
    h !== void 0 && clearTimeout(h), d = 0, s = p = u = h = void 0;
  }
  function X() {
    return h === void 0 ? f : M(tu());
  }
  function $() {
    var Y = tu(), j = O(Y);
    if (s = arguments, u = this, p = Y, j) {
      if (h === void 0)
        return I(p);
      if (_)
        return clearTimeout(h), h = setTimeout(T, e), S(p);
    }
    return h === void 0 && (h = setTimeout(T, e)), f;
  }
  return $.cancel = J, $.flush = X, $;
}
function Tu(t, e, r) {
  (r !== void 0 && !Ks(t[e], r) || r === void 0 && !(e in t)) && Zs(t, e, r);
}
function bg(t) {
  return Jn(t) && Xi(t);
}
function Cu(t, e) {
  if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__")
    return t[e];
}
function lE(t) {
  return oy(t, og(t));
}
function cE(t, e, r, s, u, l, f) {
  var h = Cu(t, r), p = Cu(e, r), d = f.get(p);
  if (d) {
    Tu(t, r, d);
    return;
  }
  var v = l ? l(h, p, r + "", t, e, f) : void 0, _ = v === void 0;
  if (_) {
    var E = bt(p), S = !E && zs(p), I = !E && !S && _l(p);
    v = p, E || S || I ? bt(h) ? v = h : bg(h) ? v = Hv(h) : S ? (_ = false, v = gg(p, true)) : I ? (_ = false, v = dg(p, true)) : v = [] : hg(p) || Us(p) ? (v = h, Us(h) ? v = lE(h) : (!At(h) || dl(h)) && (v = pg(p))) : _ = false;
  }
  _ && (f.set(p, v), u(v, p, s, l, f), f.delete(p)), Tu(t, r, v);
}
function Il(t, e, r, s, u) {
  t !== e && kg(e, function(l, f) {
    if (u || (u = new xn()), At(l))
      cE(t, e, f, r, Il, s, u);
    else {
      var h = s ? s(Cu(t, f), l, f + "", t, e, u) : void 0;
      h === void 0 && (h = l), Tu(t, f, h);
    }
  }, og);
}
var hE = tg(function(t, e, r, s) {
  Il(t, e, r, s);
});
function fE(t, e, r) {
  for (var s = -1, u = t == null ? 0 : t.length; ++s < u; )
    if (r(e, t[s]))
      return true;
  return false;
}
function gE(t, e) {
  var r = -1, s = Xi(t) ? Array(t.length) : [];
  return Sg(t, function(u, l, f) {
    s[++r] = e(u, l, f);
  }), s;
}
function dE(t, e) {
  return Ri(e, function(r) {
    return t[r];
  });
}
function pE(t) {
  return t == null ? [] : dE(t, Eo(t));
}
var mE = Math.min;
function vE(t, e, r) {
  for (var s = eg, u = t[0].length, l = t.length, f = l, h = Array(l), p = 1 / 0, d = []; f--; ) {
    var v = t[f];
    p = mE(v.length, p), h[f] = u >= 120 && v.length >= 120 ? new zi(f && v) : void 0;
  }
  v = t[0];
  var _ = -1, E = h[0];
  e:
    for (; ++_ < u && d.length < p; ) {
      var S = v[_], I = S;
      if (S = S !== 0 ? S : 0, !(E ? Ka(E, I) : s(d, I))) {
        for (f = l; --f; ) {
          var D = h[f];
          if (!(D ? Ka(D, I) : s(t[f], I)))
            continue e;
        }
        E && E.push(I), d.push(S);
      }
    }
  return d;
}
function yE(t) {
  return bg(t) ? t : [];
}
var _E = ml(function(t) {
  var e = Ri(t, yE);
  return e.length && e[0] === t[0] ? vE(e) : [];
});
function Wi(t, e) {
  return ko(t, e);
}
var EE = Mg(function(t, e, r) {
  Zs(t, r, e);
});
var xE = tg(function(t, e, r) {
  Il(t, e, r);
});
function wE(t, e, r, s) {
  if (!At(t))
    return t;
  e = wl(e, t);
  for (var u = -1, l = e.length, f = l - 1, h = t; h != null && ++u < l; ) {
    var p = Qs(e[u]), d = r;
    if (p === "__proto__" || p === "constructor" || p === "prototype")
      return t;
    if (u != f) {
      var v = h[p];
      d = void 0, d === void 0 && (d = At(v) ? v : yo(e[u + 1]) ? [] : {});
    }
    pl(h, p, d), h = h[p];
  }
  return t;
}
function kE(t, e) {
  var r = t.length;
  for (t.sort(e); r--; )
    t[r] = t[r].value;
  return t;
}
function SE(t, e) {
  if (t !== e) {
    var r = t !== void 0, s = t === null, u = t === t, l = Gi(t), f = e !== void 0, h = e === null, p = e === e, d = Gi(e);
    if (!h && !d && !l && t > e || l && f && p && !h && !d || s && f && p || !r && p || !u)
      return 1;
    if (!s && !l && !d && t < e || d && r && u && !s && !l || h && r && u || !f && u || !p)
      return -1;
  }
  return 0;
}
function ME(t, e, r) {
  for (var s = -1, u = t.criteria, l = e.criteria, f = u.length, h = r.length; ++s < f; ) {
    var p = SE(u[s], l[s]);
    if (p) {
      if (s >= h)
        return p;
      var d = r[s];
      return p * (d == "desc" ? -1 : 1);
    }
  }
  return t.index - e.index;
}
function IE(t, e, r) {
  e.length ? e = Ri(e, function(l) {
    return bt(l) ? function(f) {
      return kl(f, l.length === 1 ? l[0] : l);
    } : l;
  }) : e = [vo];
  var s = -1;
  e = Ri(e, _o(wg));
  var u = gE(t, function(l, f, h) {
    var p = Ri(e, function(d) {
      return d(l);
    });
    return { criteria: p, index: ++s, value: l };
  });
  return kE(u, function(l, f) {
    return ME(l, f, r);
  });
}
function bE(t, e, r) {
  return t == null ? t : wE(t, e, r);
}
var _h = ml(function(t, e) {
  if (t == null)
    return [];
  var r = e.length;
  return r > 1 && Iu(t, e[0], e[1]) ? e = [] : r > 2 && Iu(e[0], e[1], e[2]) && (e = [e[0]]), IE(t, O0(e), []);
});
var AE = "Expected a function";
function Ag(t, e, r) {
  var s = true, u = true;
  if (typeof t != "function")
    throw new TypeError(AE);
  return At(r) && (s = "leading" in r ? !!r.leading : s, u = "trailing" in r ? !!r.trailing : u), Ig(t, e, {
    leading: s,
    maxWait: e,
    trailing: u
  });
}
var LE = 1 / 0;
var TE = Di && 1 / Ml(new Di([, -0]))[1] == LE ? function(t) {
  return new Di(t);
} : Yv;
var CE = 200;
function NE(t, e, r) {
  var s = -1, u = eg, l = t.length, f = true, h = [], p = h;
  if (r)
    f = false, u = fE;
  else if (l >= CE) {
    var d = TE(t);
    if (d)
      return Ml(d);
    f = false, u = Ka, p = new zi();
  } else
    p = h;
  e:
    for (; ++s < l; ) {
      var v = t[s], _ = v;
      if (v = r || v !== 0 ? v : 0, f && _ === _) {
        for (var E = p.length; E--; )
          if (p[E] === _)
            continue e;
        h.push(v);
      } else u(p, _, r) || (p !== h && p.push(_), h.push(v));
    }
  return h;
}
function Eh(t, e) {
  return e = typeof e == "function" ? e : void 0, t && t.length ? NE(t, void 0, e) : [];
}
function Lg(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Ba = { exports: {} };
var PE = Ba.exports;
var xh;
function OE() {
  return xh || (xh = 1, (function(t) {
    (function(e, r) {
      t.exports ? t.exports = r() : e.log = r();
    })(PE, function() {
      var e = function() {
      }, r = "undefined", s = typeof window !== r && typeof window.navigator !== r && /Trident\/|MSIE /.test(window.navigator.userAgent), u = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ], l = {}, f = null;
      function h(D, O) {
        var T = D[O];
        if (typeof T.bind == "function")
          return T.bind(D);
        try {
          return Function.prototype.bind.call(T, D);
        } catch {
          return function() {
            return Function.prototype.apply.apply(T, [D, arguments]);
          };
        }
      }
      function p() {
        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
      }
      function d(D) {
        return D === "debug" && (D = "log"), typeof console === r ? false : D === "trace" && s ? p : console[D] !== void 0 ? h(console, D) : console.log !== void 0 ? h(console, "log") : e;
      }
      function v() {
        for (var D = this.getLevel(), O = 0; O < u.length; O++) {
          var T = u[O];
          this[T] = O < D ? e : this.methodFactory(T, D, this.name);
        }
        if (this.log = this.debug, typeof console === r && D < this.levels.SILENT)
          return "No console available for logging";
      }
      function _(D) {
        return function() {
          typeof console !== r && (v.call(this), this[D].apply(this, arguments));
        };
      }
      function E(D, O, T) {
        return d(D) || _.apply(this, arguments);
      }
      function S(D, O) {
        var T = this, M, J, X, $ = "loglevel";
        typeof D == "string" ? $ += ":" + D : typeof D == "symbol" && ($ = void 0);
        function Y(L) {
          var C = (u[L] || "silent").toUpperCase();
          if (!(typeof window === r || !$)) {
            try {
              window.localStorage[$] = C;
              return;
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent($) + "=" + C + ";";
            } catch {
            }
          }
        }
        function j() {
          var L;
          if (!(typeof window === r || !$)) {
            try {
              L = window.localStorage[$];
            } catch {
            }
            if (typeof L === r)
              try {
                var C = window.document.cookie, G = encodeURIComponent($), R = C.indexOf(G + "=");
                R !== -1 && (L = /^([^;]+)/.exec(
                  C.slice(R + G.length + 1)
                )[1]);
              } catch {
              }
            return T.levels[L] === void 0 && (L = void 0), L;
          }
        }
        function x() {
          if (!(typeof window === r || !$)) {
            try {
              window.localStorage.removeItem($);
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent($) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch {
            }
          }
        }
        function k(L) {
          var C = L;
          if (typeof C == "string" && T.levels[C.toUpperCase()] !== void 0 && (C = T.levels[C.toUpperCase()]), typeof C == "number" && C >= 0 && C <= T.levels.SILENT)
            return C;
          throw new TypeError("log.setLevel() called with invalid level: " + L);
        }
        T.name = D, T.levels = {
          TRACE: 0,
          DEBUG: 1,
          INFO: 2,
          WARN: 3,
          ERROR: 4,
          SILENT: 5
        }, T.methodFactory = O || E, T.getLevel = function() {
          return X ?? J ?? M;
        }, T.setLevel = function(L, C) {
          return X = k(L), C !== false && Y(X), v.call(T);
        }, T.setDefaultLevel = function(L) {
          J = k(L), j() || T.setLevel(L, false);
        }, T.resetLevel = function() {
          X = null, x(), v.call(T);
        }, T.enableAll = function(L) {
          T.setLevel(T.levels.TRACE, L);
        }, T.disableAll = function(L) {
          T.setLevel(T.levels.SILENT, L);
        }, T.rebuild = function() {
          if (f !== T && (M = k(f.getLevel())), v.call(T), f === T)
            for (var L in l)
              l[L].rebuild();
        }, M = k(
          f ? f.getLevel() : "WARN"
        );
        var b = j();
        b != null && (X = k(b)), v.call(T);
      }
      f = new S(), f.getLogger = function(O) {
        if (typeof O != "symbol" && typeof O != "string" || O === "")
          throw new TypeError("You must supply a name when creating a logger.");
        var T = l[O];
        return T || (T = l[O] = new S(
          O,
          f.methodFactory
        )), T;
      };
      var I = typeof window !== r ? window.log : void 0;
      return f.noConflict = function() {
        return typeof window !== r && window.log === f && (window.log = I), f;
      }, f.getLoggers = function() {
        return l;
      }, f.default = f, f;
    });
  })(Ba)), Ba.exports;
}
var RE = OE();
var te = Lg(RE);
var DE = (t, e) => {
  let r = null;
  try {
    t.forEach((s) => {
      if (e(s))
        throw r = s, new Error("found");
    });
  } catch {
  }
  return r;
};
function Nu(t, e, r = []) {
  e(t, r), Array.isArray(t) ? t.forEach((s, u) => Nu(s, e, [...r, u])) : hg(t) ? Object.entries(t).forEach(
    ([s, u]) => Nu(u, e, [...r, s])
  ) : t !== null && typeof t == "object" && te.warn(`forEachDeep: unknown collection type (${t}), path "${r.join(".")}"`);
}
var FE = (t) => {
  const e = ["shape_markers"], r = t.settings.controlsUiEnabledByDefault;
  Nu(t, (s, u) => {
    const l = u.at(2);
    if (u.length === 4 && u.at(-1) === "uiEnabled") {
      if (e.includes(l))
        return;
      bE(t, u, r);
    }
  });
};
var Pu = () => $t(av);
var Ou = false;
var bl = Array.isArray;
var GE = Array.prototype.indexOf;
var So = Array.from;
var Tg = Object.defineProperty;
var Ps = Object.getOwnPropertyDescriptor;
var BE = Object.getOwnPropertyDescriptors;
var UE = Object.prototype;
var zE = Array.prototype;
var Cg = Object.getPrototypeOf;
var wh = Object.isExtensible;
function qE(t) {
  return typeof t == "function";
}
var mn = () => {
};
function YE(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function Ng() {
  var t, e, r = new Promise((s, u) => {
    t = s, e = u;
  });
  return { promise: r, resolve: t, reject: e };
}
function Qa(t, e) {
  if (Array.isArray(t))
    return t;
  if (!(Symbol.iterator in t))
    return Array.from(t);
  const r = [];
  for (const s of t)
    if (r.push(s), r.length === e) break;
  return r;
}
var ft = 2;
var Al = 4;
var Ll = 8;
var HE = 1 << 24;
var jn = 16;
var mr = 32;
var li = 64;
var Mo = 128;
var kn = 512;
var vt = 1024;
var Ft = 2048;
var $n = 4096;
var Jt = 8192;
var Ar = 16384;
var Io = 32768;
var Qr = 65536;
var kh = 1 << 17;
var Pg = 1 << 18;
var ji = 1 << 19;
var JE = 1 << 20;
var ar = 1 << 25;
var ei = 32768;
var Ru = 1 << 21;
var Tl = 1 << 22;
var Lr = 1 << 23;
var Os = Symbol("$state");
var $E = Symbol("");
var Ni = new class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "StaleReactionError");
    __publicField(this, "message", "The reaction that called `getAbortSignal()` was re-run or destroyed");
  }
}();
function Og(t) {
  return t === this.v;
}
function Rg(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function Dg(t) {
  return !Rg(t, this.v);
}
function Fg(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function VE() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function XE(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function WE() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function jE(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function ZE() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function KE() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function QE() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function ex() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function tx() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
var nx = false;
var rx = 1;
var ix = 2;
var Gg = 4;
var sx = 8;
var ax = 16;
var ox = 1;
var ux = 2;
var lx = 4;
var cx = 1;
var hx = 2;
var pt = Symbol();
var fx = "http://www.w3.org/1999/xhtml";
var yt = null;
function qi(t) {
  yt = t;
}
function Bg(t) {
  return (
    /** @type {T} */
    gx().get(t)
  );
}
function Zi(t, e = false, r) {
  yt = {
    p: yt,
    i: false,
    c: null,
    e: null,
    s: t,
    x: null,
    l: null
  };
}
function Ki(t) {
  var e = (
    /** @type {ComponentContext} */
    yt
  ), r = e.e;
  if (r !== null) {
    e.e = null;
    for (var s of r)
      od(s);
  }
  return e.i = true, yt = e.p, /** @type {T} */
  {};
}
function Ug() {
  return true;
}
function gx(t) {
  return yt === null && Fg(), yt.c ?? (yt.c = new Map(dx(yt) || void 0));
}
function dx(t) {
  let e = t.p;
  for (; e !== null; ) {
    const r = e.c;
    if (r !== null)
      return r;
    e = e.p;
  }
  return null;
}
var Pi = [];
function px() {
  var t = Pi;
  Pi = [], YE(t);
}
function ea(t) {
  if (Pi.length === 0) {
    var e = Pi;
    queueMicrotask(() => {
      e === Pi && px();
    });
  }
  Pi.push(t);
}
function mx() {
  console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
function vx() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
function ws(t) {
  if (typeof t != "object" || t === null || Os in t)
    return t;
  const e = Cg(t);
  if (e !== UE && e !== zE)
    return t;
  var r = /* @__PURE__ */ new Map(), s = bl(t), u = Gn(0), l = Wr, f = (h) => {
    if (Wr === l)
      return h();
    var p = Le, d = Wr;
    Rt(null), Lh(l);
    var v = h();
    return Rt(p), Lh(d), v;
  };
  return s && r.set("length", Gn(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(h, p, d) {
        (!("value" in d) || d.configurable === false || d.enumerable === false || d.writable === false) && KE();
        var v = r.get(p);
        return v === void 0 ? v = f(() => {
          var _ = Gn(d.value);
          return r.set(p, _), _;
        }) : It(v, d.value, true), true;
      },
      deleteProperty(h, p) {
        var d = r.get(p);
        if (d === void 0) {
          if (p in h) {
            const v = f(() => Gn(pt));
            r.set(p, v), Rs(u);
          }
        } else
          It(d, pt), Rs(u);
        return true;
      },
      get(h, p, d) {
        var _a6;
        if (p === Os)
          return t;
        var v = r.get(p), _ = p in h;
        if (v === void 0 && (!_ || ((_a6 = Ps(h, p)) == null ? void 0 : _a6.writable)) && (v = f(() => {
          var S = ws(_ ? h[p] : pt), I = Gn(S);
          return I;
        }), r.set(p, v)), v !== void 0) {
          var E = _e3(v);
          return E === pt ? void 0 : E;
        }
        return Reflect.get(h, p, d);
      },
      getOwnPropertyDescriptor(h, p) {
        var d = Reflect.getOwnPropertyDescriptor(h, p);
        if (d && "value" in d) {
          var v = r.get(p);
          v && (d.value = _e3(v));
        } else if (d === void 0) {
          var _ = r.get(p), E = _ == null ? void 0 : _.v;
          if (_ !== void 0 && E !== pt)
            return {
              enumerable: true,
              configurable: true,
              value: E,
              writable: true
            };
        }
        return d;
      },
      has(h, p) {
        var _a6;
        if (p === Os)
          return true;
        var d = r.get(p), v = d !== void 0 && d.v !== pt || Reflect.has(h, p);
        if (d !== void 0 || Oe !== null && (!v || ((_a6 = Ps(h, p)) == null ? void 0 : _a6.writable))) {
          d === void 0 && (d = f(() => {
            var E = v ? ws(h[p]) : pt, S = Gn(E);
            return S;
          }), r.set(p, d));
          var _ = _e3(d);
          if (_ === pt)
            return false;
        }
        return v;
      },
      set(h, p, d, v) {
        var _a6;
        var _ = r.get(p), E = p in h;
        if (s && p === "length")
          for (var S = d; S < /** @type {Source<number>} */
          _.v; S += 1) {
            var I = r.get(S + "");
            I !== void 0 ? It(I, pt) : S in h && (I = f(() => Gn(pt)), r.set(S + "", I));
          }
        if (_ === void 0)
          (!E || ((_a6 = Ps(h, p)) == null ? void 0 : _a6.writable)) && (_ = f(() => Gn(void 0)), It(_, ws(d)), r.set(p, _));
        else {
          E = _.v !== pt;
          var D = f(() => ws(d));
          It(_, D);
        }
        var O = Reflect.getOwnPropertyDescriptor(h, p);
        if ((O == null ? void 0 : O.set) && O.set.call(v, d), !E) {
          if (s && typeof p == "string") {
            var T = (
              /** @type {Source<number>} */
              r.get("length")
            ), M = Number(p);
            Number.isInteger(M) && M >= T.v && It(T, M + 1);
          }
          Rs(u);
        }
        return true;
      },
      ownKeys(h) {
        _e3(u);
        var p = Reflect.ownKeys(h).filter((_) => {
          var E = r.get(_);
          return E === void 0 || E.v !== pt;
        });
        for (var [d, v] of r)
          v.v !== pt && !(d in h) && p.push(d);
        return p;
      },
      setPrototypeOf() {
        QE();
      }
    }
  );
}
function Sh(t) {
  try {
    if (t !== null && typeof t == "object" && Os in t)
      return t[Os];
  } catch {
  }
  return t;
}
function yx(t, e) {
  return Object.is(Sh(t), Sh(e));
}
var Mh;
var zg;
var qg;
var Yg;
function _x() {
  if (Mh === void 0) {
    Mh = window, zg = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, r = Text.prototype;
    qg = Ps(e, "firstChild").get, Yg = Ps(e, "nextSibling").get, wh(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), wh(r) && (r.__t = void 0);
  }
}
function ur(t = "") {
  return document.createTextNode(t);
}
function Ir(t) {
  return (
    /** @type {TemplateNode | null} */
    qg.call(t)
  );
}
function ta(t) {
  return (
    /** @type {TemplateNode | null} */
    Yg.call(t)
  );
}
function yn(t, e) {
  return Ir(t);
}
function wn(t, e = false) {
  {
    var r = Ir(t);
    return r instanceof Comment && r.data === "" ? ta(r) : r;
  }
}
function Hs(t, e = 1, r = false) {
  let s = t;
  for (; e--; )
    s = /** @type {TemplateNode} */
    ta(s);
  return s;
}
function Ex(t) {
  t.textContent = "";
}
function Hg() {
  return false;
}
function Jg(t) {
  var e = Oe;
  if (e === null)
    return Le.f |= Lr, t;
  if ((e.f & Io) === 0) {
    if ((e.f & Mo) === 0)
      throw t;
    e.b.error(t);
  } else
    Yi(t, e);
}
function Yi(t, e) {
  for (; e !== null; ) {
    if ((e.f & Mo) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (r) {
        t = r;
      }
    e = e.parent;
  }
  throw t;
}
var Ea = /* @__PURE__ */ new Set();
var Ye = null;
var Ua = null;
var an = null;
var Bn = [];
var Cl = null;
var Du = false;
var _e, _t, _r, _n, _u, _s, _i, _zn_instances, a_fn, o_fn, l_fn, c_fn, h_fn;
var _zn = class _zn {
  constructor() {
    __privateAdd(this, _zn_instances);
    __publicField(this, "committed", false);
    /**
     * The current values of any sources that are updated in this batch
     * They keys of this map are identical to `this.#previous`
     * @type {Map<Source, any>}
     */
    __publicField(this, "current", /* @__PURE__ */ new Map());
    /**
     * The values of any sources that are updated in this batch _before_ those updates took place.
     * They keys of this map are identical to `this.#current`
     * @type {Map<Source, any>}
     */
    __publicField(this, "previous", /* @__PURE__ */ new Map());
    /**
     * When the batch is committed (and the DOM is updated), we need to remove old branches
     * and append new ones by calling the functions added inside (if/each/key/etc) blocks
     * @type {Set<() => void>}
     */
    __privateAdd(this, _e, /* @__PURE__ */ new Set());
    /**
     * If a fork is discarded, we need to destroy any effects that are no longer needed
     * @type {Set<(batch: Batch) => void>}
     */
    __privateAdd(this, _t, /* @__PURE__ */ new Set());
    /**
     * The number of async effects that are currently in flight
     */
    __privateAdd(this, _r, 0);
    /**
     * The number of async effects that are currently in flight, _not_ inside a pending boundary
     */
    __privateAdd(this, _n, 0);
    /**
     * A deferred that resolves when the batch is committed, used with `settled()`
     * TODO replace with Promise.withResolvers once supported widely enough
     * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
     */
    __privateAdd(this, _u, null);
    /**
     * Deferred effects (which run after async work has completed) that are DIRTY
     * @type {Set<Effect>}
     */
    __privateAdd(this, _s, /* @__PURE__ */ new Set());
    /**
     * Deferred effects that are MAYBE_DIRTY
     * @type {Set<Effect>}
     */
    __privateAdd(this, _i, /* @__PURE__ */ new Set());
    /**
     * A set of branches that still exist, but will be destroyed when this batch
     * is committed  we skip over these during `process`
     * @type {Set<Effect>}
     */
    __publicField(this, "skipped_effects", /* @__PURE__ */ new Set());
    __publicField(this, "is_fork", false);
  }
  is_deferred() {
    return this.is_fork || __privateGet(this, _n) > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    var _a6;
    Bn = [], Ua = null, this.apply();
    var r = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const s of e)
      __privateMethod(this, _zn_instances, a_fn).call(this, s, r);
    this.is_fork || __privateMethod(this, _zn_instances, c_fn).call(this), this.is_deferred() ? (__privateMethod(this, _zn_instances, o_fn).call(this, r.effects), __privateMethod(this, _zn_instances, o_fn).call(this, r.render_effects)) : (Ua = this, Ye = null, Ih(r.render_effects), Ih(r.effects), Ua = null, (_a6 = __privateGet(this, _u)) == null ? void 0 : _a6.resolve()), an = null;
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, r) {
    this.previous.has(e) || this.previous.set(e, r), (e.f & Lr) === 0 && (this.current.set(e, e.v), an == null ? void 0 : an.set(e, e.v));
  }
  activate() {
    Ye = this, this.apply();
  }
  deactivate() {
    Ye === this && (Ye = null, an = null);
  }
  flush() {
    if (this.activate(), Bn.length > 0) {
      if (xx(), Ye !== null && Ye !== this)
        return;
    } else __privateGet(this, _r) === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of __privateGet(this, _t)) e(this);
    __privateGet(this, _t).clear();
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    __privateSet(this, _r, __privateGet(this, _r) + 1), e && __privateSet(this, _n, __privateGet(this, _n) + 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    __privateSet(this, _r, __privateGet(this, _r) - 1), e && __privateSet(this, _n, __privateGet(this, _n) - 1), this.revive();
  }
  revive() {
    for (const e of __privateGet(this, _s))
      __privateGet(this, _i).delete(e), _t3(e, Ft), ti(e);
    for (const e of __privateGet(this, _i))
      _t3(e, $n), ti(e);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    __privateGet(this, _e).add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    __privateGet(this, _t).add(e);
  }
  settled() {
    return (__privateGet(this, _u) ?? __privateSet(this, _u, Ng())).promise;
  }
  static ensure() {
    if (Ye === null) {
      const e = Ye = new _zn();
      Ea.add(Ye), _zn.enqueue(() => {
        Ye === e && e.flush();
      });
    }
    return Ye;
  }
  /** @param {() => void} task */
  static enqueue(e) {
    ea(e);
  }
  apply() {
  }
};
_e = new WeakMap();
_t = new WeakMap();
_r = new WeakMap();
_n = new WeakMap();
_u = new WeakMap();
_s = new WeakMap();
_i = new WeakMap();
_zn_instances = new WeakSet();
/**
 * Traverse the effect tree, executing effects or stashing
 * them for later execution as appropriate
 * @param {Effect} root
 * @param {EffectTarget} target
 */
a_fn = function(e, r) {
  var _a6;
  e.f ^= vt;
  for (var s = e.first; s !== null; ) {
    var u = s.f, l = (u & (mr | li)) !== 0, f = l && (u & vt) !== 0, h = f || (u & Jt) !== 0 || this.skipped_effects.has(s);
    if ((s.f & Mo) !== 0 && ((_a6 = s.b) == null ? void 0 : _a6.is_pending()) && (r = {
      parent: r,
      effect: s,
      effects: [],
      render_effects: []
    }), !h && s.fn !== null) {
      l ? s.f ^= vt : (u & Al) !== 0 ? r.effects.push(s) : ra(s) && ((s.f & jn) !== 0 && __privateGet(this, _s).add(s), $s(s));
      var p = s.first;
      if (p !== null) {
        s = p;
        continue;
      }
    }
    var d = s.parent;
    for (s = s.next; s === null && d !== null; )
      d === r.effect && (__privateMethod(this, _zn_instances, o_fn).call(this, r.effects), __privateMethod(this, _zn_instances, o_fn).call(this, r.render_effects), r = /** @type {EffectTarget} */
      r.parent), s = d.next, d = d.parent;
  }
};
/**
 * @param {Effect[]} effects
 */
o_fn = function(e) {
  for (const r of e)
    (r.f & Ft) !== 0 ? __privateGet(this, _s).add(r) : (r.f & $n) !== 0 && __privateGet(this, _i).add(r), __privateMethod(this, _zn_instances, l_fn).call(this, r.deps), _t3(r, vt);
};
/**
 * @param {Value[] | null} deps
 */
l_fn = function(e) {
  if (e !== null)
    for (const r of e)
      (r.f & ft) === 0 || (r.f & ei) === 0 || (r.f ^= ei, __privateMethod(this, _zn_instances, l_fn).call(
        this,
        /** @type {Derived} */
        r.deps
      ));
};
c_fn = function() {
  if (__privateGet(this, _n) === 0) {
    for (const e of __privateGet(this, _e)) e();
    __privateGet(this, _e).clear();
  }
  __privateGet(this, _r) === 0 && __privateMethod(this, _zn_instances, h_fn).call(this);
};
h_fn = function() {
  var _a6;
  if (Ea.size > 1) {
    this.previous.clear();
    var e = an, r = true, s = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const l of Ea) {
      if (l === this) {
        r = false;
        continue;
      }
      const f = [];
      for (const [p, d] of this.current) {
        if (l.current.has(p))
          if (r && d !== l.current.get(p))
            l.current.set(p, d);
          else
            continue;
        f.push(p);
      }
      if (f.length === 0)
        continue;
      const h = [...l.current.keys()].filter((p) => !this.current.has(p));
      if (h.length > 0) {
        var u = Bn;
        Bn = [];
        const p = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Map();
        for (const v of f)
          $g(v, h, p, d);
        if (Bn.length > 0) {
          Ye = l, l.apply();
          for (const v of Bn)
            __privateMethod(_a6 = l, _zn_instances, a_fn).call(_a6, v, s);
          l.deactivate();
        }
        Bn = u;
      }
    }
    Ye = null, an = e;
  }
  this.committed = true, Ea.delete(this);
};
var zn = _zn;
function xx() {
  var t = Xr;
  Du = true;
  var e = null;
  try {
    var r = 0;
    for (to(true); Bn.length > 0; ) {
      var s = zn.ensure();
      if (r++ > 1e3) {
        var u, l;
        wx();
      }
      s.process(Bn), Tr.clear();
    }
  } finally {
    Du = false, to(t), Cl = null;
  }
}
function wx() {
  try {
    ZE();
  } catch (t) {
    Yi(t, Cl);
  }
}
var rr = null;
function Ih(t) {
  var e = t.length;
  if (e !== 0) {
    for (var r = 0; r < e; ) {
      var s = t[r++];
      if ((s.f & (Ar | Jt)) === 0 && ra(s) && (rr = /* @__PURE__ */ new Set(), $s(s), s.deps === null && s.first === null && s.nodes === null && (s.teardown === null && s.ac === null ? gd(s) : s.fn = null), (rr == null ? void 0 : rr.size) > 0)) {
        Tr.clear();
        for (const u of rr) {
          if ((u.f & (Ar | Jt)) !== 0) continue;
          const l = [u];
          let f = u.parent;
          for (; f !== null; )
            rr.has(f) && (rr.delete(f), l.push(f)), f = f.parent;
          for (let h = l.length - 1; h >= 0; h--) {
            const p = l[h];
            (p.f & (Ar | Jt)) === 0 && $s(p);
          }
        }
        rr.clear();
      }
    }
    rr = null;
  }
}
function $g(t, e, r, s) {
  if (!r.has(t) && (r.add(t), t.reactions !== null))
    for (const u of t.reactions) {
      const l = u.f;
      (l & ft) !== 0 ? $g(
        /** @type {Derived} */
        u,
        e,
        r,
        s
      ) : (l & (Tl | jn)) !== 0 && (l & Ft) === 0 && Vg(u, e, s) && (_t3(u, Ft), ti(
        /** @type {Effect} */
        u
      ));
    }
}
function Vg(t, e, r) {
  const s = r.get(t);
  if (s !== void 0) return s;
  if (t.deps !== null)
    for (const u of t.deps) {
      if (e.includes(u))
        return true;
      if ((u.f & ft) !== 0 && Vg(
        /** @type {Derived} */
        u,
        e,
        r
      ))
        return r.set(
          /** @type {Derived} */
          u,
          true
        ), true;
    }
  return r.set(t, false), false;
}
function ti(t) {
  for (var e = Cl = t; e.parent !== null; ) {
    e = e.parent;
    var r = e.f;
    if (Du && e === Oe && (r & jn) !== 0 && (r & Pg) === 0)
      return;
    if ((r & (li | mr)) !== 0) {
      if ((r & vt) === 0) return;
      e.f ^= vt;
    }
  }
  Bn.push(e);
}
function kx(t) {
  let e = 0, r = ni(0), s;
  return () => {
    Vs() && (_e3(r), ld(() => (e === 0 && (s = ia(() => t(() => Rs(r)))), e += 1, () => {
      ea(() => {
        e -= 1, e === 0 && (s == null ? void 0 : s(), s = void 0, Rs(r));
      });
    })));
  };
}
var Sx = Qr | ji | Mo;
function Mx(t, e, r) {
  new Ix(t, e, r);
}
var _e2, _t2, _r2, _n2, _u2, _s2, _i2, _a2, _o2, _l2, _c, _h2, _f, _d, _g2, __2, _Ix_instances, E_fn, x_fn, v_fn, p_fn, m_fn, y_fn;
var Ix = class {
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, r, s) {
    __privateAdd(this, _Ix_instances);
    /** @type {Boundary | null} */
    __publicField(this, "parent");
    __privateAdd(this, _e2, false);
    /** @type {TemplateNode} */
    __privateAdd(this, _t2);
    /** @type {TemplateNode | null} */
    __privateAdd(this, _r2, null);
    /** @type {BoundaryProps} */
    __privateAdd(this, _n2);
    /** @type {((anchor: Node) => void)} */
    __privateAdd(this, _u2);
    /** @type {Effect} */
    __privateAdd(this, _s2);
    /** @type {Effect | null} */
    __privateAdd(this, _i2, null);
    /** @type {Effect | null} */
    __privateAdd(this, _a2, null);
    /** @type {Effect | null} */
    __privateAdd(this, _o2, null);
    /** @type {DocumentFragment | null} */
    __privateAdd(this, _l2, null);
    /** @type {TemplateNode | null} */
    __privateAdd(this, _c, null);
    __privateAdd(this, _h2, 0);
    __privateAdd(this, _f, 0);
    __privateAdd(this, _d, false);
    /**
     * A source containing the number of pending async deriveds/expressions.
     * Only created if `$effect.pending()` is used inside the boundary,
     * otherwise updating the source results in needless `Batch.ensure()`
     * calls followed by no-op flushes
     * @type {Source<number> | null}
     */
    __privateAdd(this, _g2, null);
    __privateAdd(this, __2, kx(() => (__privateSet(this, _g2, ni(__privateGet(this, _h2))), () => {
      __privateSet(this, _g2, null);
    })));
    __privateSet(this, _t2, e), __privateSet(this, _n2, r), __privateSet(this, _u2, s), this.parent = /** @type {Effect} */
    Oe.b, __privateSet(this, _e2, !!__privateGet(this, _n2).pending), __privateSet(this, _s2, Rl(() => {
      Oe.b = this;
      {
        var u = __privateMethod(this, _Ix_instances, v_fn).call(this);
        try {
          __privateSet(this, _i2, sn(() => s(u)));
        } catch (l) {
          this.error(l);
        }
        __privateGet(this, _f) > 0 ? __privateMethod(this, _Ix_instances, m_fn).call(this) : __privateSet(this, _e2, false);
      }
      return () => {
        var _a6;
        (_a6 = __privateGet(this, _c)) == null ? void 0 : _a6.remove();
      };
    }, Sx));
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return __privateGet(this, _e2) || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!__privateGet(this, _n2).pending;
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    __privateMethod(this, _Ix_instances, y_fn).call(this, e), __privateSet(this, _h2, __privateGet(this, _h2) + e), __privateGet(this, _g2) && Hi(__privateGet(this, _g2), __privateGet(this, _h2));
  }
  get_effect_pending() {
    return __privateGet(this, __2).call(this), _e3(
      /** @type {Source<number>} */
      __privateGet(this, _g2)
    );
  }
  /** @param {unknown} error */
  error(e) {
    var r = __privateGet(this, _n2).onerror;
    let s = __privateGet(this, _n2).failed;
    if (__privateGet(this, _d) || !r && !s)
      throw e;
    __privateGet(this, _i2) && (Dt(__privateGet(this, _i2)), __privateSet(this, _i2, null)), __privateGet(this, _a2) && (Dt(__privateGet(this, _a2)), __privateSet(this, _a2, null)), __privateGet(this, _o2) && (Dt(__privateGet(this, _o2)), __privateSet(this, _o2, null));
    var u = false, l = false;
    const f = () => {
      if (u) {
        vx();
        return;
      }
      u = true, l && tx(), zn.ensure(), __privateSet(this, _h2, 0), __privateGet(this, _o2) !== null && jr(__privateGet(this, _o2), () => {
        __privateSet(this, _o2, null);
      }), __privateSet(this, _e2, this.has_pending_snippet()), __privateSet(this, _i2, __privateMethod(this, _Ix_instances, p_fn).call(this, () => (__privateSet(this, _d, false), sn(() => __privateGet(this, _u2).call(this, __privateGet(this, _t2)))))), __privateGet(this, _f) > 0 ? __privateMethod(this, _Ix_instances, m_fn).call(this) : __privateSet(this, _e2, false);
    };
    var h = Le;
    try {
      Rt(null), l = true, r == null ? void 0 : r(e, f), l = false;
    } catch (p) {
      Yi(p, __privateGet(this, _s2) && __privateGet(this, _s2).parent);
    } finally {
      Rt(h);
    }
    s && ea(() => {
      __privateSet(this, _o2, __privateMethod(this, _Ix_instances, p_fn).call(this, () => {
        zn.ensure(), __privateSet(this, _d, true);
        try {
          return sn(() => {
            s(
              __privateGet(this, _t2),
              () => e,
              () => f
            );
          });
        } catch (p) {
          return Yi(
            p,
            /** @type {Effect} */
            __privateGet(this, _s2).parent
          ), null;
        } finally {
          __privateSet(this, _d, false);
        }
      }));
    });
  }
};
_e2 = new WeakMap();
_t2 = new WeakMap();
_r2 = new WeakMap();
_n2 = new WeakMap();
_u2 = new WeakMap();
_s2 = new WeakMap();
_i2 = new WeakMap();
_a2 = new WeakMap();
_o2 = new WeakMap();
_l2 = new WeakMap();
_c = new WeakMap();
_h2 = new WeakMap();
_f = new WeakMap();
_d = new WeakMap();
_g2 = new WeakMap();
__2 = new WeakMap();
_Ix_instances = new WeakSet();
E_fn = function() {
  try {
    __privateSet(this, _i2, sn(() => __privateGet(this, _u2).call(this, __privateGet(this, _t2))));
  } catch (e) {
    this.error(e);
  }
  __privateSet(this, _e2, false);
};
x_fn = function() {
  const e = __privateGet(this, _n2).pending;
  e && (__privateSet(this, _a2, sn(() => e(__privateGet(this, _t2)))), zn.enqueue(() => {
    var r = __privateMethod(this, _Ix_instances, v_fn).call(this);
    __privateSet(this, _i2, __privateMethod(this, _Ix_instances, p_fn).call(this, () => (zn.ensure(), sn(() => __privateGet(this, _u2).call(this, r))))), __privateGet(this, _f) > 0 ? __privateMethod(this, _Ix_instances, m_fn).call(this) : (jr(
      /** @type {Effect} */
      __privateGet(this, _a2),
      () => {
        __privateSet(this, _a2, null);
      }
    ), __privateSet(this, _e2, false));
  }));
};
v_fn = function() {
  var e = __privateGet(this, _t2);
  return __privateGet(this, _e2) && (__privateSet(this, _c, ur()), __privateGet(this, _t2).before(__privateGet(this, _c)), e = __privateGet(this, _c)), e;
};
/**
 * @param {() => Effect | null} fn
 */
p_fn = function(e) {
  var r = Oe, s = Le, u = yt;
  Vn(__privateGet(this, _s2)), Rt(__privateGet(this, _s2)), qi(__privateGet(this, _s2).ctx);
  try {
    return e();
  } catch (l) {
    return Jg(l), null;
  } finally {
    Vn(r), Rt(s), qi(u);
  }
};
m_fn = function() {
  const e = (
    /** @type {(anchor: Node) => void} */
    __privateGet(this, _n2).pending
  );
  __privateGet(this, _i2) !== null && (__privateSet(this, _l2, document.createDocumentFragment()), __privateGet(this, _l2).append(
    /** @type {TemplateNode} */
    __privateGet(this, _c)
  ), md(__privateGet(this, _i2), __privateGet(this, _l2))), __privateGet(this, _a2) === null && __privateSet(this, _a2, sn(() => e(__privateGet(this, _t2))));
};
/**
 * Updates the pending count associated with the currently visible pending snippet,
 * if any, such that we can replace the snippet with content once work is done
 * @param {1 | -1} d
 */
y_fn = function(e) {
  var _a6;
  if (!this.has_pending_snippet()) {
    this.parent && __privateMethod(_a6 = this.parent, _Ix_instances, y_fn).call(_a6, e);
    return;
  }
  __privateSet(this, _f, __privateGet(this, _f) + e), __privateGet(this, _f) === 0 && (__privateSet(this, _e2, false), __privateGet(this, _a2) && jr(__privateGet(this, _a2), () => {
    __privateSet(this, _a2, null);
  }), __privateGet(this, _l2) && (__privateGet(this, _t2).before(__privateGet(this, _l2)), __privateSet(this, _l2, null)));
};
function bx(t, e, r, s) {
  const u = Nl;
  if (r.length === 0 && t.length === 0) {
    s(e.map(u));
    return;
  }
  var l = Ye, f = (
    /** @type {Effect} */
    Oe
  ), h = Ax();
  function p() {
    Promise.all(r.map((d) => Lx(d))).then((d) => {
      h();
      try {
        s([...e.map(u), ...d]);
      } catch (v) {
        (f.f & Ar) === 0 && Yi(v, f);
      }
      l == null ? void 0 : l.deactivate(), eo();
    }).catch((d) => {
      Yi(d, f);
    });
  }
  t.length > 0 ? Promise.all(t).then(() => {
    h();
    try {
      return p();
    } finally {
      l == null ? void 0 : l.deactivate(), eo();
    }
  }) : p();
}
function Ax() {
  var t = Oe, e = Le, r = yt, s = Ye;
  return function(l = true) {
    Vn(t), Rt(e), qi(r), l && (s == null ? void 0 : s.activate());
  };
}
function eo() {
  Vn(null), Rt(null), qi(null);
}
function Nl(t) {
  var e = ft | Ft, r = Le !== null && (Le.f & ft) !== 0 ? (
    /** @type {Derived} */
    Le
  ) : null;
  return Oe !== null && (Oe.f |= ji), {
    ctx: yt,
    deps: null,
    effects: null,
    equals: Og,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      pt
    ),
    wv: 0,
    parent: r ?? Oe,
    ac: null
  };
}
function Lx(t, e) {
  let r = (
    /** @type {Effect | null} */
    Oe
  );
  r === null && VE();
  var s = (
    /** @type {Boundary} */
    r.b
  ), u = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), l = ni(
    /** @type {V} */
    pt
  ), f = !Le, h = /* @__PURE__ */ new Map();
  return zx(() => {
    var _a6;
    var p = Ng();
    u = p.promise;
    try {
      Promise.resolve(t()).then(p.resolve, p.reject).then(() => {
        d === Ye && d.committed && d.deactivate(), eo();
      });
    } catch (E) {
      p.reject(E), eo();
    }
    var d = (
      /** @type {Batch} */
      Ye
    );
    if (f) {
      var v = !s.is_pending();
      s.update_pending_count(1), d.increment(v), (_a6 = h.get(d)) == null ? void 0 : _a6.reject(Ni), h.delete(d), h.set(d, p);
    }
    const _ = (E, S = void 0) => {
      if (d.activate(), S)
        S !== Ni && (l.f |= Lr, Hi(l, S));
      else {
        (l.f & Lr) !== 0 && (l.f ^= Lr), Hi(l, E);
        for (const [I, D] of h) {
          if (h.delete(I), I === d) break;
          D.reject(Ni);
        }
      }
      f && (s.update_pending_count(-1), d.decrement(v));
    };
    p.promise.then(_, (E) => _(null, E || "unknown"));
  }), Ol(() => {
    for (const p of h.values())
      p.reject(Ni);
  }), new Promise((p) => {
    function d(v) {
      function _() {
        v === u ? p(l) : d(u);
      }
      v.then(_, _);
    }
    d(u);
  });
}
function vn(t) {
  const e = Nl(t);
  return ed(e), e;
}
function Tx(t) {
  const e = Nl(t);
  return e.equals = Dg, e;
}
function Xg(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var r = 0; r < e.length; r += 1)
      Dt(
        /** @type {Effect} */
        e[r]
      );
  }
}
function Cx(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & ft) === 0)
      return (e.f & Ar) === 0 ? (
        /** @type {Effect} */
        e
      ) : null;
    e = e.parent;
  }
  return null;
}
function Pl(t) {
  var e, r = Oe;
  Vn(Cx(t));
  try {
    t.f &= ~ei, Xg(t), e = id(t);
  } finally {
    Vn(r);
  }
  return e;
}
function Wg(t) {
  var e = Pl(t);
  if (t.equals(e) || ((Ye == null ? void 0 : Ye.is_fork) || (t.v = e), t.wv = nd()), !Qi)
    if (an !== null)
      (Vs() || (Ye == null ? void 0 : Ye.is_fork)) && an.set(t, e);
    else {
      var r = (t.f & kn) === 0 ? $n : vt;
      _t3(t, r);
    }
}
var Fu = /* @__PURE__ */ new Set();
var Tr = /* @__PURE__ */ new Map();
var jg = false;
function ni(t, e) {
  var r = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: Og,
    rv: 0,
    wv: 0
  };
  return r;
}
function Gn(t, e) {
  const r = ni(t);
  return ed(r), r;
}
function Zg(t, e = false, r = true) {
  const s = ni(t);
  return e || (s.equals = Dg), s;
}
function It(t, e, r = false) {
  Le !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!qn || (Le.f & kh) !== 0) && Ug() && (Le.f & (ft | jn | Tl | kh)) !== 0 && !(lr == null ? void 0 : lr.includes(t)) && ex();
  let s = r ? ws(e) : e;
  return Hi(t, s);
}
function Hi(t, e) {
  if (!t.equals(e)) {
    var r = t.v;
    Qi ? Tr.set(t, e) : Tr.set(t, r), t.v = e;
    var s = zn.ensure();
    s.capture(t, r), (t.f & ft) !== 0 && ((t.f & Ft) !== 0 && Pl(
      /** @type {Derived} */
      t
    ), _t3(t, (t.f & kn) !== 0 ? vt : $n)), t.wv = nd(), Kg(t, Ft), Oe !== null && (Oe.f & vt) !== 0 && (Oe.f & (mr | li)) === 0 && (nn === null ? Ox([t]) : nn.push(t)), !s.is_fork && Fu.size > 0 && !jg && Nx();
  }
  return e;
}
function Nx() {
  jg = false;
  var t = Xr;
  to(true);
  const e = Array.from(Fu);
  try {
    for (const r of e)
      (r.f & vt) !== 0 && _t3(r, $n), ra(r) && $s(r);
  } finally {
    to(t);
  }
  Fu.clear();
}
function Rs(t) {
  It(t, t.v + 1);
}
function Kg(t, e) {
  var r = t.reactions;
  if (r !== null)
    for (var s = r.length, u = 0; u < s; u++) {
      var l = r[u], f = l.f, h = (f & Ft) === 0;
      if (h && _t3(l, e), (f & ft) !== 0) {
        var p = (
          /** @type {Derived} */
          l
        );
        an == null ? void 0 : an.delete(p), (f & ei) === 0 && (f & kn && (l.f |= ei), Kg(p, $n));
      } else h && ((f & jn) !== 0 && rr !== null && rr.add(
        /** @type {Effect} */
        l
      ), ti(
        /** @type {Effect} */
        l
      ));
    }
}
var bh = false;
function Px() {
  bh || (bh = true, document.addEventListener(
    "reset",
    (t) => {
      Promise.resolve().then(() => {
        var _a6;
        if (!t.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            t.target.elements
          )
            (_a6 = e.__on_r) == null ? void 0 : _a6.call(e);
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
    { capture: true }
  ));
}
function na(t) {
  var e = Le, r = Oe;
  Rt(null), Vn(null);
  try {
    return t();
  } finally {
    Rt(e), Vn(r);
  }
}
function Qg(t, e, r, s = r) {
  t.addEventListener(e, () => na(r));
  const u = t.__on_r;
  u ? t.__on_r = () => {
    u(), s(true);
  } : t.__on_r = () => s(true), Px();
}
var Xr = false;
function to(t) {
  Xr = t;
}
var Qi = false;
function Ah(t) {
  Qi = t;
}
var Le = null;
var qn = false;
function Rt(t) {
  Le = t;
}
var Oe = null;
function Vn(t) {
  Oe = t;
}
var lr = null;
function ed(t) {
  Le !== null && (lr === null ? lr = [t] : lr.push(t));
}
var Mt = null;
var zt = 0;
var nn = null;
function Ox(t) {
  nn = t;
}
var td = 1;
var Js = 0;
var Wr = Js;
function Lh(t) {
  Wr = t;
}
function nd() {
  return ++td;
}
function ra(t) {
  var e = t.f;
  if ((e & Ft) !== 0)
    return true;
  if (e & ft && (t.f &= ~ei), (e & $n) !== 0) {
    var r = t.deps;
    if (r !== null)
      for (var s = r.length, u = 0; u < s; u++) {
        var l = r[u];
        if (ra(
          /** @type {Derived} */
          l
        ) && Wg(
          /** @type {Derived} */
          l
        ), l.wv > t.wv)
          return true;
      }
    (e & kn) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    an === null && _t3(t, vt);
  }
  return false;
}
function rd(t, e, r = true) {
  var s = t.reactions;
  if (s !== null && !(lr == null ? void 0 : lr.includes(t)))
    for (var u = 0; u < s.length; u++) {
      var l = s[u];
      (l.f & ft) !== 0 ? rd(
        /** @type {Derived} */
        l,
        e,
        false
      ) : e === l && (r ? _t3(l, Ft) : (l.f & vt) !== 0 && _t3(l, $n), ti(
        /** @type {Effect} */
        l
      ));
    }
}
function id(t) {
  var _a6;
  var e = Mt, r = zt, s = nn, u = Le, l = lr, f = yt, h = qn, p = Wr, d = t.f;
  Mt = /** @type {null | Value[]} */
  null, zt = 0, nn = null, Le = (d & (mr | li)) === 0 ? t : null, lr = null, qi(t.ctx), qn = false, Wr = ++Js, t.ac !== null && (na(() => {
    t.ac.abort(Ni);
  }), t.ac = null);
  try {
    t.f |= Ru;
    var v = (
      /** @type {Function} */
      t.fn
    ), _ = v(), E = t.deps;
    if (Mt !== null) {
      var S;
      if (no(t, zt), E !== null && zt > 0)
        for (E.length = zt + Mt.length, S = 0; S < Mt.length; S++)
          E[zt + S] = Mt[S];
      else
        t.deps = E = Mt;
      if (Vs() && (t.f & kn) !== 0)
        for (S = zt; S < E.length; S++)
          ((_a6 = E[S]).reactions ?? (_a6.reactions = [])).push(t);
    } else E !== null && zt < E.length && (no(t, zt), E.length = zt);
    if (Ug() && nn !== null && !qn && E !== null && (t.f & (ft | $n | Ft)) === 0)
      for (S = 0; S < /** @type {Source[]} */
      nn.length; S++)
        rd(
          nn[S],
          /** @type {Effect} */
          t
        );
    return u !== null && u !== t && (Js++, nn !== null && (s === null ? s = nn : s.push(.../** @type {Source[]} */
    nn))), (t.f & Lr) !== 0 && (t.f ^= Lr), _;
  } catch (I) {
    return Jg(I);
  } finally {
    t.f ^= Ru, Mt = e, zt = r, nn = s, Le = u, lr = l, qi(f), qn = h, Wr = p;
  }
}
function Rx(t, e) {
  let r = e.reactions;
  if (r !== null) {
    var s = GE.call(r, t);
    if (s !== -1) {
      var u = r.length - 1;
      u === 0 ? r = e.reactions = null : (r[s] = r[u], r.pop());
    }
  }
  r === null && (e.f & ft) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Mt === null || !Mt.includes(e)) && (_t3(e, $n), (e.f & kn) !== 0 && (e.f ^= kn, e.f &= ~ei), Xg(
    /** @type {Derived} **/
    e
  ), no(
    /** @type {Derived} **/
    e,
    0
  ));
}
function no(t, e) {
  var r = t.deps;
  if (r !== null)
    for (var s = e; s < r.length; s++)
      Rx(t, r[s]);
}
function $s(t) {
  var e = t.f;
  if ((e & Ar) === 0) {
    _t3(t, vt);
    var r = Oe, s = Xr;
    Oe = t, Xr = true;
    try {
      (e & (jn | HE)) !== 0 ? qx(t) : hd(t), cd(t);
      var u = id(t);
      t.teardown = typeof u == "function" ? u : null, t.wv = td;
      var l;
      Ou && nx && (t.f & Ft) !== 0 && t.deps;
    } finally {
      Xr = s, Oe = r;
    }
  }
}
function _e3(t) {
  var e = t.f, r = (e & ft) !== 0;
  if (Le !== null && !qn) {
    var s = Oe !== null && (Oe.f & Ar) !== 0;
    if (!s && !(lr == null ? void 0 : lr.includes(t))) {
      var u = Le.deps;
      if ((Le.f & Ru) !== 0)
        t.rv < Js && (t.rv = Js, Mt === null && u !== null && u[zt] === t ? zt++ : Mt === null ? Mt = [t] : Mt.includes(t) || Mt.push(t));
      else {
        (Le.deps ?? (Le.deps = [])).push(t);
        var l = t.reactions;
        l === null ? t.reactions = [Le] : l.includes(Le) || l.push(Le);
      }
    }
  }
  if (Qi) {
    if (Tr.has(t))
      return Tr.get(t);
    if (r) {
      var f = (
        /** @type {Derived} */
        t
      ), h = f.v;
      return ((f.f & vt) === 0 && f.reactions !== null || ad(f)) && (h = Pl(f)), Tr.set(f, h), h;
    }
  } else r && (!(an == null ? void 0 : an.has(t)) || (Ye == null ? void 0 : Ye.is_fork) && !Vs()) && (f = /** @type {Derived} */
  t, ra(f) && Wg(f), Xr && Vs() && (f.f & kn) === 0 && sd(f));
  if (an == null ? void 0 : an.has(t))
    return an.get(t);
  if ((t.f & Lr) !== 0)
    throw t.v;
  return t.v;
}
function sd(t) {
  if (t.deps !== null) {
    t.f ^= kn;
    for (const e of t.deps)
      (e.reactions ?? (e.reactions = [])).push(t), (e.f & ft) !== 0 && (e.f & kn) === 0 && sd(
        /** @type {Derived} */
        e
      );
  }
}
function ad(t) {
  if (t.v === pt) return true;
  if (t.deps === null) return false;
  for (const e of t.deps)
    if (Tr.has(e) || (e.f & ft) !== 0 && ad(
      /** @type {Derived} */
      e
    ))
      return true;
  return false;
}
function ia(t) {
  var e = qn;
  try {
    return qn = true, t();
  } finally {
    qn = e;
  }
}
var Dx = -7169;
function _t3(t, e) {
  t.f = t.f & Dx | e;
}
function Fx(t) {
  Oe === null && (Le === null && jE(), WE()), Qi && XE();
}
function Gx(t, e) {
  var r = e.last;
  r === null ? e.last = e.first = t : (r.next = t, t.prev = r, e.last = t);
}
function vr(t, e, r) {
  var s = Oe;
  s !== null && (s.f & Jt) !== 0 && (t |= Jt);
  var u = {
    ctx: yt,
    deps: null,
    nodes: null,
    f: t | Ft | kn,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: s,
    b: s && s.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (r)
    try {
      $s(u), u.f |= Io;
    } catch (h) {
      throw Dt(u), h;
    }
  else e !== null && ti(u);
  var l = u;
  if (r && l.deps === null && l.teardown === null && l.nodes === null && l.first === l.last && // either `null`, or a singular child
  (l.f & ji) === 0 && (l = l.first, (t & jn) !== 0 && (t & Qr) !== 0 && l !== null && (l.f |= Qr)), l !== null && (l.parent = s, s !== null && Gx(l, s), Le !== null && (Le.f & ft) !== 0 && (t & li) === 0)) {
    var f = (
      /** @type {Derived} */
      Le
    );
    (f.effects ?? (f.effects = [])).push(l);
  }
  return u;
}
function Vs() {
  return Le !== null && !qn;
}
function Ol(t) {
  const e = vr(Ll, null, false);
  return _t3(e, vt), e.teardown = t, e;
}
function Bx(t) {
  Fx();
  var e = (
    /** @type {Effect} */
    Oe.f
  ), r = !Le && (e & mr) !== 0 && (e & Io) === 0;
  if (r) {
    var s = (
      /** @type {ComponentContext} */
      yt
    );
    (s.e ?? (s.e = [])).push(t);
  } else
    return od(t);
}
function od(t) {
  return vr(Al | JE, t, false);
}
function Ux(t) {
  zn.ensure();
  const e = vr(li | ji, t, true);
  return (r = {}) => new Promise((s) => {
    r.outro ? jr(e, () => {
      Dt(e), s(void 0);
    }) : (Dt(e), s(void 0));
  });
}
function ud(t) {
  return vr(Al, t, false);
}
function zx(t) {
  return vr(Tl | ji, t, true);
}
function ld(t, e = 0) {
  return vr(Ll | e, t, true);
}
function _n3(t, e = [], r = [], s = []) {
  bx(s, e, r, (u) => {
    vr(Ll, () => t(...u.map(_e3)), true);
  });
}
function Rl(t, e = 0) {
  var r = vr(jn | e, t, true);
  return r;
}
function sn(t) {
  return vr(mr | ji, t, true);
}
function cd(t) {
  var e = t.teardown;
  if (e !== null) {
    const r = Qi, s = Le;
    Ah(true), Rt(null);
    try {
      e.call(null);
    } finally {
      Ah(r), Rt(s);
    }
  }
}
function hd(t, e = false) {
  var r = t.first;
  for (t.first = t.last = null; r !== null; ) {
    const u = r.ac;
    u !== null && na(() => {
      u.abort(Ni);
    });
    var s = r.next;
    (r.f & li) !== 0 ? r.parent = null : Dt(r, e), r = s;
  }
}
function qx(t) {
  for (var e = t.first; e !== null; ) {
    var r = e.next;
    (e.f & mr) === 0 && Dt(e), e = r;
  }
}
function Dt(t, e = true) {
  var r = false;
  (e || (t.f & Pg) !== 0) && t.nodes !== null && t.nodes.end !== null && (fd(
    t.nodes.start,
    /** @type {TemplateNode} */
    t.nodes.end
  ), r = true), hd(t, e && !r), no(t, 0), _t3(t, Ar);
  var s = t.nodes && t.nodes.t;
  if (s !== null)
    for (const l of s)
      l.stop();
  cd(t);
  var u = t.parent;
  u !== null && u.first !== null && gd(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes = t.ac = null;
}
function fd(t, e) {
  for (; t !== null; ) {
    var r = t === e ? null : ta(t);
    t.remove(), t = r;
  }
}
function gd(t) {
  var e = t.parent, r = t.prev, s = t.next;
  r !== null && (r.next = s), s !== null && (s.prev = r), e !== null && (e.first === t && (e.first = s), e.last === t && (e.last = r));
}
function jr(t, e, r = true) {
  var s = [];
  dd(t, s, true);
  var u = () => {
    r && Dt(t), e && e();
  }, l = s.length;
  if (l > 0) {
    var f = () => --l || u();
    for (var h of s)
      h.out(f);
  } else
    u();
}
function dd(t, e, r) {
  if ((t.f & Jt) === 0) {
    t.f ^= Jt;
    var s = t.nodes && t.nodes.t;
    if (s !== null)
      for (const h of s)
        (h.is_global || r) && e.push(h);
    for (var u = t.first; u !== null; ) {
      var l = u.next, f = (u.f & Qr) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (u.f & mr) !== 0 && (t.f & jn) !== 0;
      dd(u, e, f ? r : false), u = l;
    }
  }
}
function Dl(t) {
  pd(t, true);
}
function pd(t, e) {
  if ((t.f & Jt) !== 0) {
    t.f ^= Jt, (t.f & vt) === 0 && (_t3(t, Ft), ti(t));
    for (var r = t.first; r !== null; ) {
      var s = r.next, u = (r.f & Qr) !== 0 || (r.f & mr) !== 0;
      pd(r, u ? e : false), r = s;
    }
    var l = t.nodes && t.nodes.t;
    if (l !== null)
      for (const f of l)
        (f.is_global || e) && f.in();
  }
}
function md(t, e) {
  if (t.nodes)
    for (var r = t.nodes.start, s = t.nodes.end; r !== null; ) {
      var u = r === s ? null : ta(r);
      e.append(r), r = u;
    }
}
var Yx = ["touchstart", "touchmove"];
function Hx(t) {
  return Yx.includes(t);
}
var vd = /* @__PURE__ */ new Set();
var Gu = /* @__PURE__ */ new Set();
function bo(t) {
  for (var e = 0; e < t.length; e++)
    vd.add(t[e]);
  for (var r of Gu)
    r(t);
}
var Th = null;
function xa(t) {
  var _a6;
  var e = this, r = (
    /** @type {Node} */
    e.ownerDocument
  ), s = t.type, u = ((_a6 = t.composedPath) == null ? void 0 : _a6.call(t)) || [], l = (
    /** @type {null | Element} */
    u[0] || t.target
  );
  Th = t;
  var f = 0, h = Th === t && t.__root;
  if (h) {
    var p = u.indexOf(h);
    if (p !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var d = u.indexOf(e);
    if (d === -1)
      return;
    p <= d && (f = p);
  }
  if (l = /** @type {Element} */
  u[f] || t.target, l !== e) {
    Tg(t, "currentTarget", {
      configurable: true,
      get() {
        return l || r;
      }
    });
    var v = Le, _ = Oe;
    Rt(null), Vn(null);
    try {
      for (var E, S = []; l !== null; ) {
        var I = l.assignedSlot || l.parentNode || /** @type {any} */
        l.host || null;
        try {
          var D = l["__" + s];
          D != null && (!/** @type {any} */
          l.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === l) && D.call(l, t);
        } catch (O) {
          E ? S.push(O) : E = O;
        }
        if (t.cancelBubble || I === e || I === null)
          break;
        l = I;
      }
      if (E) {
        for (let O of S)
          queueMicrotask(() => {
            throw O;
          });
        throw E;
      }
    } finally {
      t.__root = e, delete t.currentTarget, Rt(v), Vn(_);
    }
  }
}
function yd(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function Xs(t, e) {
  var r = (
    /** @type {Effect} */
    Oe
  );
  r.nodes === null && (r.nodes = { start: t, end: e, a: null, t: null });
}
function ln(t, e) {
  var r = (e & cx) !== 0, s = (e & hx) !== 0, u, l = !t.startsWith("<!>");
  return () => {
    u === void 0 && (u = yd(l ? t : "<!>" + t), r || (u = /** @type {TemplateNode} */
    Ir(u)));
    var f = (
      /** @type {TemplateNode} */
      s || zg ? document.importNode(u, true) : u.cloneNode(true)
    );
    if (r) {
      var h = (
        /** @type {TemplateNode} */
        Ir(f)
      ), p = (
        /** @type {TemplateNode} */
        f.lastChild
      );
      Xs(h, p);
    } else
      Xs(f, f);
    return f;
  };
}
function Ch(t = "") {
  {
    var e = ur(t + "");
    return Xs(e, e), e;
  }
}
function cr() {
  var t = document.createDocumentFragment(), e = document.createComment(""), r = ur();
  return t.append(e, r), Xs(e, r), t;
}
function We(t, e) {
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
var Bu = true;
function Fi(t, e) {
  var r = e == null ? "" : typeof e == "object" ? e + "" : e;
  r !== (t.__t ?? (t.__t = t.nodeValue)) && (t.__t = r, t.nodeValue = r + "");
}
function Jx(t, e) {
  return $x(t, e);
}
var Ii = /* @__PURE__ */ new Map();
function $x(t, { target: e, anchor: r, props: s = {}, events: u, context: l, intro: f = true }) {
  _x();
  var h = /* @__PURE__ */ new Set(), p = (_) => {
    for (var E = 0; E < _.length; E++) {
      var S = _[E];
      if (!h.has(S)) {
        h.add(S);
        var I = Hx(S);
        e.addEventListener(S, xa, { passive: I });
        var D = Ii.get(S);
        D === void 0 ? (document.addEventListener(S, xa, { passive: I }), Ii.set(S, 1)) : Ii.set(S, D + 1);
      }
    }
  };
  p(So(vd)), Gu.add(p);
  var d = void 0, v = Ux(() => {
    var _ = r ?? e.appendChild(ur());
    return Mx(
      /** @type {TemplateNode} */
      _,
      {
        pending: () => {
        }
      },
      (E) => {
        if (l) {
          Zi({});
          var S = (
            /** @type {ComponentContext} */
            yt
          );
          S.c = l;
        }
        u && (s.$$events = u), Bu = f, d = t(E, s) || {}, Bu = true, l && Ki();
      }
    ), () => {
      var _a6;
      for (var E of h) {
        e.removeEventListener(E, xa);
        var S = (
          /** @type {number} */
          Ii.get(E)
        );
        --S === 0 ? (document.removeEventListener(E, xa), Ii.delete(E)) : Ii.set(E, S);
      }
      Gu.delete(p), _ !== r && ((_a6 = _.parentNode) == null ? void 0 : _a6.removeChild(_));
    };
  });
  return Uu.set(d, v), d;
}
var Uu = /* @__PURE__ */ new WeakMap();
function Vx(t, e) {
  const r = Uu.get(t);
  return r ? (Uu.delete(t), r(e)) : Promise.resolve();
}
var _e4, _t4, _r3, _n4, _u3, _s3, _i3;
var Xx = class {
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, r = true) {
    /** @type {TemplateNode} */
    __publicField(this, "anchor");
    /** @type {Map<Batch, Key>} */
    __privateAdd(this, _e4, /* @__PURE__ */ new Map());
    /**
     * Map of keys to effects that are currently rendered in the DOM.
     * These effects are visible and actively part of the document tree.
     * Example:
     * ```
     * {#if condition}
     * 	foo
     * {:else}
     * 	bar
     * {/if}
     * ```
     * Can result in the entries `true->Effect` and `false->Effect`
     * @type {Map<Key, Effect>}
     */
    __privateAdd(this, _t4, /* @__PURE__ */ new Map());
    /**
     * Similar to #onscreen with respect to the keys, but contains branches that are not yet
     * in the DOM, because their insertion is deferred.
     * @type {Map<Key, Branch>}
     */
    __privateAdd(this, _r3, /* @__PURE__ */ new Map());
    /**
     * Keys of effects that are currently outroing
     * @type {Set<Key>}
     */
    __privateAdd(this, _n4, /* @__PURE__ */ new Set());
    /**
     * Whether to pause (i.e. outro) on change, or destroy immediately.
     * This is necessary for `<svelte:element>`
     */
    __privateAdd(this, _u3, true);
    __privateAdd(this, _s3, () => {
      var e = (
        /** @type {Batch} */
        Ye
      );
      if (__privateGet(this, _e4).has(e)) {
        var r = (
          /** @type {Key} */
          __privateGet(this, _e4).get(e)
        ), s = __privateGet(this, _t4).get(r);
        if (s)
          Dl(s), __privateGet(this, _n4).delete(r);
        else {
          var u = __privateGet(this, _r3).get(r);
          u && (__privateGet(this, _t4).set(r, u.effect), __privateGet(this, _r3).delete(r), u.fragment.lastChild.remove(), this.anchor.before(u.fragment), s = u.effect);
        }
        for (const [l, f] of __privateGet(this, _e4)) {
          if (__privateGet(this, _e4).delete(l), l === e)
            break;
          const h = __privateGet(this, _r3).get(f);
          h && (Dt(h.effect), __privateGet(this, _r3).delete(f));
        }
        for (const [l, f] of __privateGet(this, _t4)) {
          if (l === r || __privateGet(this, _n4).has(l)) continue;
          const h = () => {
            if (Array.from(__privateGet(this, _e4).values()).includes(l)) {
              var d = document.createDocumentFragment();
              md(f, d), d.append(ur()), __privateGet(this, _r3).set(l, { effect: f, fragment: d });
            } else
              Dt(f);
            __privateGet(this, _n4).delete(l), __privateGet(this, _t4).delete(l);
          };
          __privateGet(this, _u3) || !s ? (__privateGet(this, _n4).add(l), jr(f, h, false)) : h();
        }
      }
    });
    /**
     * @param {Batch} batch
     */
    __privateAdd(this, _i3, (e) => {
      __privateGet(this, _e4).delete(e);
      const r = Array.from(__privateGet(this, _e4).values());
      for (const [s, u] of __privateGet(this, _r3))
        r.includes(s) || (Dt(u.effect), __privateGet(this, _r3).delete(s));
    });
    this.anchor = e, __privateSet(this, _u3, r);
  }
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, r) {
    var s = (
      /** @type {Batch} */
      Ye
    ), u = Hg();
    if (r && !__privateGet(this, _t4).has(e) && !__privateGet(this, _r3).has(e))
      if (u) {
        var l = document.createDocumentFragment(), f = ur();
        l.append(f), __privateGet(this, _r3).set(e, {
          effect: sn(() => r(f)),
          fragment: l
        });
      } else
        __privateGet(this, _t4).set(
          e,
          sn(() => r(this.anchor))
        );
    if (__privateGet(this, _e4).set(s, e), u) {
      for (const [h, p] of __privateGet(this, _t4))
        h === e ? s.skipped_effects.delete(p) : s.skipped_effects.add(p);
      for (const [h, p] of __privateGet(this, _r3))
        h === e ? s.skipped_effects.delete(p.effect) : s.skipped_effects.add(p.effect);
      s.oncommit(__privateGet(this, _s3)), s.ondiscard(__privateGet(this, _i3));
    } else
      __privateGet(this, _s3).call(this);
  }
};
_e4 = new WeakMap();
_t4 = new WeakMap();
_r3 = new WeakMap();
_n4 = new WeakMap();
_u3 = new WeakMap();
_s3 = new WeakMap();
_i3 = new WeakMap();
function Yt(t, e, r = false) {
  var s = new Xx(t), u = r ? Qr : 0;
  function l(f, h) {
    s.ensure(f, h);
  }
  Rl(() => {
    var f = false;
    e((h, p = true) => {
      f = true, l(p, h);
    }), f || l(false, null);
  }, u);
}
function Wx(t, e) {
  return e;
}
function jx(t, e, r) {
  for (var s = [], u = e.length, l, f = e.length, h = 0; h < u; h++) {
    let _ = e[h];
    jr(
      _,
      () => {
        if (l) {
          if (l.pending.delete(_), l.done.add(_), l.pending.size === 0) {
            var E = (
              /** @type {Set<EachOutroGroup>} */
              t.outrogroups
            );
            zu(So(l.done)), E.delete(l), E.size === 0 && (t.outrogroups = null);
          }
        } else
          f -= 1;
      },
      false
    );
  }
  if (f === 0) {
    var p = s.length === 0 && r !== null;
    if (p) {
      var d = (
        /** @type {Element} */
        r
      ), v = (
        /** @type {Element} */
        d.parentNode
      );
      Ex(v), v.append(d), t.items.clear();
    }
    zu(e, !p);
  } else
    l = {
      pending: new Set(e),
      done: /* @__PURE__ */ new Set()
    }, (t.outrogroups ?? (t.outrogroups = /* @__PURE__ */ new Set())).add(l);
}
function zu(t, e = true) {
  for (var r = 0; r < t.length; r++)
    Dt(t[r], e);
}
var Nh;
function Ws(t, e, r, s, u, l = null) {
  var f = t, h = /* @__PURE__ */ new Map(), p = (e & Gg) !== 0;
  if (p) {
    var d = (
      /** @type {Element} */
      t
    );
    f = d.appendChild(ur());
  }
  var v = null, _ = Tx(() => {
    var T = r();
    return bl(T) ? T : T == null ? [] : So(T);
  }), E, S = true;
  function I() {
    O.fallback = v, Zx(O, E, f, e, s), v !== null && (E.length === 0 ? (v.f & ar) === 0 ? Dl(v) : (v.f ^= ar, ks(v, null, f)) : jr(v, () => {
      v = null;
    }));
  }
  var D = Rl(() => {
    E = /** @type {V[]} */
    _e3(_);
    for (var T = E.length, M = /* @__PURE__ */ new Set(), J = (
      /** @type {Batch} */
      Ye
    ), X = Hg(), $ = 0; $ < T; $ += 1) {
      var Y = E[$], j = s(Y, $), x = S ? null : h.get(j);
      x ? (x.v && Hi(x.v, Y), x.i && Hi(x.i, $), X && J.skipped_effects.delete(x.e)) : (x = Kx(
        h,
        S ? f : Nh ?? (Nh = ur()),
        Y,
        j,
        $,
        u,
        e,
        r
      ), S || (x.e.f |= ar), h.set(j, x)), M.add(j);
    }
    if (T === 0 && l && !v && (S ? v = sn(() => l(f)) : (v = sn(() => l(Nh ?? (Nh = ur()))), v.f |= ar)), !S)
      if (X) {
        for (const [k, b] of h)
          M.has(k) || J.skipped_effects.add(b.e);
        J.oncommit(I), J.ondiscard(() => {
        });
      } else
        I();
    _e3(_);
  }), O = { effect: D, items: h, outrogroups: null, fallback: v };
  S = false;
}
function Zx(t, e, r, s, u) {
  var _a6, _b2, _c2, _d3, _e5, _f3, _g3, _h3, _i4;
  var l = (s & sx) !== 0, f = e.length, h = t.items, p = t.effect.first, d, v = null, _, E = [], S = [], I, D, O, T;
  if (l)
    for (T = 0; T < f; T += 1)
      I = e[T], D = u(I, T), O = /** @type {EachItem} */
      h.get(D).e, (O.f & ar) === 0 && ((_b2 = (_a6 = O.nodes) == null ? void 0 : _a6.a) == null ? void 0 : _b2.measure(), (_ ?? (_ = /* @__PURE__ */ new Set())).add(O));
  for (T = 0; T < f; T += 1) {
    if (I = e[T], D = u(I, T), O = /** @type {EachItem} */
    h.get(D).e, t.outrogroups !== null)
      for (const b of t.outrogroups)
        b.pending.delete(O), b.done.delete(O);
    if ((O.f & ar) !== 0)
      if (O.f ^= ar, O === p)
        ks(O, null, r);
      else {
        var M = v ? v.next : p;
        O === t.effect.last && (t.effect.last = O.prev), O.prev && (O.prev.next = O.next), O.next && (O.next.prev = O.prev), kr(t, v, O), kr(t, O, M), ks(O, M, r), v = O, E = [], S = [], p = v.next;
        continue;
      }
    if ((O.f & Jt) !== 0 && (Dl(O), l && ((_d3 = (_c2 = O.nodes) == null ? void 0 : _c2.a) == null ? void 0 : _d3.unfix(), (_ ?? (_ = /* @__PURE__ */ new Set())).delete(O))), O !== p) {
      if (d !== void 0 && d.has(O)) {
        if (E.length < S.length) {
          var J = S[0], X;
          v = J.prev;
          var $ = E[0], Y = E[E.length - 1];
          for (X = 0; X < E.length; X += 1)
            ks(E[X], J, r);
          for (X = 0; X < S.length; X += 1)
            d.delete(S[X]);
          kr(t, $.prev, Y.next), kr(t, v, $), kr(t, Y, J), p = J, v = Y, T -= 1, E = [], S = [];
        } else
          d.delete(O), ks(O, p, r), kr(t, O.prev, O.next), kr(t, O, v === null ? t.effect.first : v.next), kr(t, v, O), v = O;
        continue;
      }
      for (E = [], S = []; p !== null && p !== O; )
        (d ?? (d = /* @__PURE__ */ new Set())).add(p), S.push(p), p = p.next;
      if (p === null)
        continue;
    }
    (O.f & ar) === 0 && E.push(O), v = O, p = O.next;
  }
  if (t.outrogroups !== null) {
    for (const b of t.outrogroups)
      b.pending.size === 0 && (zu(So(b.done)), (_e5 = t.outrogroups) == null ? void 0 : _e5.delete(b));
    t.outrogroups.size === 0 && (t.outrogroups = null);
  }
  if (p !== null || d !== void 0) {
    var j = [];
    if (d !== void 0)
      for (O of d)
        (O.f & Jt) === 0 && j.push(O);
    for (; p !== null; )
      (p.f & Jt) === 0 && p !== t.fallback && j.push(p), p = p.next;
    var x = j.length;
    if (x > 0) {
      var k = (s & Gg) !== 0 && f === 0 ? r : null;
      if (l) {
        for (T = 0; T < x; T += 1)
          (_g3 = (_f3 = j[T].nodes) == null ? void 0 : _f3.a) == null ? void 0 : _g3.measure();
        for (T = 0; T < x; T += 1)
          (_i4 = (_h3 = j[T].nodes) == null ? void 0 : _h3.a) == null ? void 0 : _i4.fix();
      }
      jx(t, j, k);
    }
  }
  l && ea(() => {
    var _a7, _b3;
    if (_ !== void 0)
      for (O of _)
        (_b3 = (_a7 = O.nodes) == null ? void 0 : _a7.a) == null ? void 0 : _b3.apply();
  });
}
function Kx(t, e, r, s, u, l, f, h) {
  var p = (f & rx) !== 0 ? (f & ax) === 0 ? Zg(r, false, false) : ni(r) : null, d = (f & ix) !== 0 ? ni(u) : null;
  return {
    v: p,
    i: d,
    e: sn(() => (l(e, p ?? r, d ?? u, h), () => {
      t.delete(s);
    }))
  };
}
function ks(t, e, r) {
  if (t.nodes)
    for (var s = t.nodes.start, u = t.nodes.end, l = e && (e.f & ar) === 0 ? (
      /** @type {EffectNodes} */
      e.nodes.start
    ) : r; s !== null; ) {
      var f = (
        /** @type {TemplateNode} */
        ta(s)
      );
      if (l.before(s), s === u)
        return;
      s = f;
    }
}
function kr(t, e, r) {
  e === null ? t.effect.first = r : e.next = r, r === null ? t.effect.last = e : r.prev = e;
}
function _d2(t, e, r = false, s = false, u = false) {
  var l = t, f = "";
  _n3(() => {
    var h = (
      /** @type {Effect} */
      Oe
    );
    if (f !== (f = e() ?? "") && (h.nodes !== null && (fd(
      h.nodes.start,
      /** @type {TemplateNode} */
      h.nodes.end
    ), h.nodes = null), f !== "")) {
      var p = f + "";
      r ? p = `<svg>${p}</svg>` : s && (p = `<math>${p}</math>`);
      var d = yd(p);
      if ((r || s) && (d = /** @type {Element} */
      Ir(d)), Xs(
        /** @type {TemplateNode} */
        Ir(d),
        /** @type {TemplateNode} */
        d.lastChild
      ), r || s)
        for (; Ir(d); )
          l.before(
            /** @type {TemplateNode} */
            Ir(d)
          );
      else
        l.before(d);
    }
  });
}
var Qx = () => performance.now();
var sr = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    ((t) => requestAnimationFrame(t))
  ),
  now: () => Qx(),
  tasks: /* @__PURE__ */ new Set()
};
function Ed() {
  const t = sr.now();
  sr.tasks.forEach((e) => {
    e.c(t) || (sr.tasks.delete(e), e.f());
  }), sr.tasks.size !== 0 && sr.tick(Ed);
}
function ew(t) {
  let e;
  return sr.tasks.size === 0 && sr.tick(Ed), {
    promise: new Promise((r) => {
      sr.tasks.add(e = { c: t, f: r });
    }),
    abort() {
      sr.tasks.delete(e);
    }
  };
}
function wa(t, e) {
  na(() => {
    t.dispatchEvent(new CustomEvent(e));
  });
}
function tw(t) {
  if (t === "float") return "cssFloat";
  if (t === "offset") return "cssOffset";
  if (t.startsWith("--")) return t;
  const e = t.split("-");
  return e.length === 1 ? e[0] : e[0] + e.slice(1).map(
    /** @param {any} word */
    (r) => r[0].toUpperCase() + r.slice(1)
  ).join("");
}
function Ph(t) {
  const e = {}, r = t.split(";");
  for (const s of r) {
    const [u, l] = s.split(":");
    if (!u || l === void 0) break;
    const f = tw(u.trim());
    e[f] = l.trim();
  }
  return e;
}
var nw = (t) => t;
function Oh(t, e, r, s) {
  var _a6;
  var u = (t & ox) !== 0, l = (t & ux) !== 0, f = u && l, h = (t & lx) !== 0, p = f ? "both" : u ? "in" : "out", d, v = e.inert, _ = e.style.overflow, E, S;
  function I() {
    return na(() => d ?? (d = r()(e, (s == null ? void 0 : s()) ?? /** @type {P} */
    {}, {
      direction: p
    })));
  }
  var D = {
    is_global: h,
    in() {
      var _a7;
      if (e.inert = v, !u) {
        S == null ? void 0 : S.abort(), (_a7 = S == null ? void 0 : S.reset) == null ? void 0 : _a7.call(S);
        return;
      }
      l || (E == null ? void 0 : E.abort()), wa(e, "introstart"), E = qu(e, I(), S, 1, () => {
        wa(e, "introend"), E == null ? void 0 : E.abort(), E = d = void 0, e.style.overflow = _;
      });
    },
    out(J) {
      if (!l) {
        J == null ? void 0 : J(), d = void 0;
        return;
      }
      e.inert = true, wa(e, "outrostart"), S = qu(e, I(), E, 0, () => {
        wa(e, "outroend"), J == null ? void 0 : J();
      });
    },
    stop: () => {
      E == null ? void 0 : E.abort(), S == null ? void 0 : S.abort();
    }
  }, O = (
    /** @type {Effect & { nodes: EffectNodes }} */
    Oe
  );
  if (((_a6 = O.nodes).t ?? (_a6.t = [])).push(D), u && Bu) {
    var T = h;
    if (!T) {
      for (var M = (
        /** @type {Effect | null} */
        O.parent
      ); M && (M.f & Qr) !== 0; )
        for (; (M = M.parent) && (M.f & jn) === 0; )
          ;
      T = !M || (M.f & Io) !== 0;
    }
    T && ud(() => {
      ia(() => D.in());
    });
  }
}
function qu(t, e, r, s, u) {
  var l = s === 1;
  if (qE(e)) {
    var f, h = false;
    return ea(() => {
      if (!h) {
        var O = e({ direction: l ? "in" : "out" });
        f = qu(t, O, r, s, u);
      }
    }), {
      abort: () => {
        h = true, f == null ? void 0 : f.abort();
      },
      deactivate: () => f.deactivate(),
      reset: () => f.reset(),
      t: () => f.t()
    };
  }
  if (r == null ? void 0 : r.deactivate(), !(e == null ? void 0 : e.duration))
    return u(), {
      abort: mn,
      deactivate: mn,
      reset: mn,
      t: () => s
    };
  const { delay: p = 0, css: d, tick: v, easing: _ = nw } = e;
  var E = [];
  if (l && r === void 0 && (v && v(0, 1), d)) {
    var S = Ph(d(0, 1));
    E.push(S, S);
  }
  var I = () => 1 - s, D = t.animate(E, { duration: p, fill: "forwards" });
  return D.onfinish = () => {
    D.cancel();
    var O = (r == null ? void 0 : r.t()) ?? 1 - s;
    r == null ? void 0 : r.abort();
    var T = s - O, M = (
      /** @type {number} */
      e.duration * Math.abs(T)
    ), J = [];
    if (M > 0) {
      var X = false;
      if (d)
        for (var $ = Math.ceil(M / 16.666666666666668), Y = 0; Y <= $; Y += 1) {
          var j = O + T * _(Y / $), x = Ph(d(j, 1 - j));
          J.push(x), X || (X = x.overflow === "hidden");
        }
      X && (t.style.overflow = "hidden"), I = () => {
        var k = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          D.currentTime
        );
        return O + T * _(k / M);
      }, v && ew(() => {
        if (D.playState !== "running") return false;
        var k = I();
        return v(k, 1 - k), true;
      });
    }
    D = t.animate(J, { duration: M, fill: "forwards" }), D.onfinish = () => {
      I = () => s, v == null ? void 0 : v(s, 1 - s), u();
    };
  }, {
    abort: () => {
      D && (D.cancel(), D.effect = null, D.onfinish = mn);
    },
    deactivate: () => {
      u = mn;
    },
    reset: () => {
      s === 0 && (v == null ? void 0 : v(1, 0));
    },
    t: () => I()
  };
}
function xd(t) {
  var e, r, s = "";
  if (typeof t == "string" || typeof t == "number") s += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var u = t.length;
    for (e = 0; e < u; e++) t[e] && (r = xd(t[e])) && (s && (s += " "), s += r);
  } else for (r in t) t[r] && (s && (s += " "), s += r);
  return s;
}
function rw() {
  for (var t, e, r = 0, s = "", u = arguments.length; r < u; r++) (t = arguments[r]) && (e = xd(t)) && (s && (s += " "), s += e);
  return s;
}
function iw(t) {
  return typeof t == "object" ? rw(t) : t ?? "";
}
var Rh = [...` 	
\r\f\v\uFEFF`];
function sw(t, e, r) {
  var s = t == null ? "" : "" + t;
  if (e && (s = s ? s + " " + e : e), r) {
    for (var u in r)
      if (r[u])
        s = s ? s + " " + u : u;
      else if (s.length)
        for (var l = u.length, f = 0; (f = s.indexOf(u, f)) >= 0; ) {
          var h = f + l;
          (f === 0 || Rh.includes(s[f - 1])) && (h === s.length || Rh.includes(s[h])) ? s = (f === 0 ? "" : s.substring(0, f)) + s.substring(h + 1) : f = h;
        }
  }
  return s === "" ? null : s;
}
function Ds(t, e, r, s, u, l) {
  var f = t.__className;
  if (f !== r || f === void 0) {
    var h = sw(r, s, l);
    h == null ? t.removeAttribute("class") : t.className = h, t.__className = r;
  } else if (l && u !== l)
    for (var p in l) {
      var d = !!l[p];
      (u == null || d !== !!u[p]) && t.classList.toggle(p, d);
    }
  return l;
}
function wd(t, e, r = false) {
  if (t.multiple) {
    if (e == null)
      return;
    if (!bl(e))
      return mx();
    for (var s of t.options)
      s.selected = e.includes(Fs(s));
    return;
  }
  for (s of t.options) {
    var u = Fs(s);
    if (yx(u, e)) {
      s.selected = true;
      return;
    }
  }
  (!r || e !== void 0) && (t.selectedIndex = -1);
}
function aw(t) {
  var e = new MutationObserver(() => {
    wd(t, t.__value);
  });
  e.observe(t, {
    // Listen to option element changes
    childList: true,
    subtree: true,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: true,
    attributeFilter: ["value"]
  }), Ol(() => {
    e.disconnect();
  });
}
function ow(t, e, r = e) {
  var s = /* @__PURE__ */ new WeakSet(), u = true;
  Qg(t, "change", (l) => {
    var f = l ? "[selected]" : ":checked", h;
    if (t.multiple)
      h = [].map.call(t.querySelectorAll(f), Fs);
    else {
      var p = t.querySelector(f) ?? // will fall back to first non-disabled option if no option is selected
      t.querySelector("option:not([disabled])");
      h = p && Fs(p);
    }
    r(h), Ye !== null && s.add(Ye);
  }), ud(() => {
    var l = e();
    if (t === document.activeElement) {
      var f = (
        /** @type {Batch} */
        Ua ?? Ye
      );
      if (s.has(f))
        return;
    }
    if (wd(t, l, u), u && l === void 0) {
      var h = t.querySelector(":checked");
      h !== null && (l = Fs(h), r(l));
    }
    t.__value = l, u = false;
  }), aw(t);
}
function Fs(t) {
  return "__value" in t ? t.__value : t.value;
}
var uw = Symbol("is custom element");
var lw = Symbol("is html");
function br(t, e, r, s) {
  var u = cw(t);
  u[e] !== (u[e] = r) && (e === "loading" && (t[$E] = r), r == null ? t.removeAttribute(e) : typeof r != "string" && hw(t).includes(e) ? t[e] = r : t.setAttribute(e, r));
}
function cw(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ?? (t.__attributes = {
      [uw]: t.nodeName.includes("-"),
      [lw]: t.namespaceURI === fx
    })
  );
}
var Dh = /* @__PURE__ */ new Map();
function hw(t) {
  var e = t.getAttribute("is") || t.nodeName, r = Dh.get(e);
  if (r) return r;
  Dh.set(e, r = []);
  for (var s, u = t, l = Element.prototype; l !== u; ) {
    s = BE(u);
    for (var f in s)
      s[f].set && r.push(f);
    u = Cg(u);
  }
  return r;
}
function fw(t, e, r = e) {
  Qg(t, "change", (s) => {
    var u = s ? t.defaultChecked : t.checked;
    r(u);
  }), // If we are hydrating and the value has since changed,
  // then use the update value from the input instead.
  // If defaultChecked is set, then checked == defaultChecked
  ia(e) == null && r(t.checked), ld(() => {
    var s = e();
    t.checked = !!s;
  });
}
var Yu = Symbol();
function kd(t, e, r) {
  const s = r[e] ?? (r[e] = {
    store: null,
    source: Zg(void 0),
    unsubscribe: mn
  });
  if (s.store !== t && !(Yu in r))
    if (s.unsubscribe(), s.store = t ?? null, t == null)
      s.source.v = void 0, s.unsubscribe = mn;
    else {
      var u = true;
      s.unsubscribe = Md(t, (l) => {
        u ? s.source.v = l : It(s.source, l);
      }), u = false;
    }
  return t && Yu in r ? pw(t) : _e3(s.source);
}
function Sd() {
  const t = {};
  function e() {
    Ol(() => {
      for (var r in t)
        t[r].unsubscribe();
      Tg(t, Yu, {
        enumerable: false,
        value: true
      });
    });
  }
  return [t, e];
}
function gw(t) {
  yt === null && Fg(), Bx(() => {
    const e = ia(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function Md(t, e, r) {
  if (t == null)
    return e(void 0), mn;
  const s = ia(
    () => t.subscribe(
      e,
      // @ts-expect-error
      r
    )
  );
  return s.unsubscribe ? () => s.unsubscribe() : s;
}
var bi = [];
function dw(t, e = mn) {
  let r = null;
  const s = /* @__PURE__ */ new Set();
  function u(h) {
    if (Rg(t, h) && (t = h, r)) {
      const p = !bi.length;
      for (const d of s)
        d[1](), bi.push(d, t);
      if (p) {
        for (let d = 0; d < bi.length; d += 2)
          bi[d][0](bi[d + 1]);
        bi.length = 0;
      }
    }
  }
  function l(h) {
    u(h(
      /** @type {T} */
      t
    ));
  }
  function f(h, p = mn) {
    const d = [h, p];
    return s.add(d), s.size === 1 && (r = e(u, l) || mn), h(
      /** @type {T} */
      t
    ), () => {
      s.delete(d), s.size === 0 && r && (r(), r = null);
    };
  }
  return { set: u, update: l, subscribe: f };
}
function pw(t) {
  let e;
  return Md(t, (r) => e = r)(), e;
}
var mw = {
  controls: $t(Wf),
  options: Pu().controls,
  settings: Pu().settings
};
var Fl = dw(mw);
var vw = "5";
var _a3;
typeof window < "u" && ((_a3 = window.__svelte ?? (window.__svelte = {})).v ?? (_a3.v = /* @__PURE__ */ new Set())).add(vw);
var yw = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M7.474 17.988h49.045L31.996 46.012zm-3.85 3.37 24.522 28.019a5.113 5.113 0 0 0 7.7 0l24.523-28.02c2.894-3.308.542-8.482-3.85-8.482H7.474a5.113 5.113 0 0 0-3.85 8.482"/>
</svg>
`;
var _w = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M7.474 46.012h49.045L31.996 17.988Zm-3.85-3.37 24.522-28.019a5.113 5.113 0 0 1 7.7 0l24.523 28.02c2.894 3.308.542 8.482-3.85 8.482H7.474a5.113 5.113 0 0 1-3.85-8.482"/>
</svg>
`;
var Ew = ln("<option> </option>");
var xw = ln('<label class="svelte-18zciyf"> </label> <select class="svelte-18zciyf"></select>', 1);
var ww = ln('<label class="svelte-18zciyf"><input type="checkbox" class="svelte-18zciyf"/> </label>');
var kw = ln('<div class="action-option svelte-18zciyf"><!></div>');
function Sw(t, e) {
  Zi(e, true);
  let r = Gn("");
  gw(() => {
    e.actionOption && (e.actionOption.type === "select" ? It(r, e.actionOption.value.value, true) : e.actionOption.type === "toggle" && It(r, e.actionOption.value, true));
  });
  const s = (h) => {
    var _a6, _b2;
    if (!e.actionInstance || !e.actionOption) {
      te.error("Can't apply option value", e.actionInstance, e.actionOption);
      return;
    }
    if (((_a6 = e.actionOption) == null ? void 0 : _a6.type) === "toggle") {
      const p = h.target;
      It(r, p.checked, true);
    } else if (((_b2 = e.actionOption) == null ? void 0 : _b2.type) === "select") {
      const p = h.target;
      It(r, p.value, true);
    }
    e.actionInstance.applyOptionValue(e.name, _e3(r));
  };
  var u = cr(), l = wn(u);
  {
    var f = (h) => {
      var p = kw(), d = yn(p);
      {
        var v = (E) => {
          var S = xw(), I = wn(S), D = yn(I), O = Hs(I, 2);
          O.__change = s, Ws(O, 21, () => e.actionOption.choices, Wx, (T, M) => {
            var J = Ew(), X = yn(J), $ = {};
            _n3(() => {
              Fi(X, _e3(M).title), $ !== ($ = _e3(M).value) && (J.value = (J.__value = _e3(M).value) ?? "");
            }), We(T, J);
          }), _n3(() => {
            br(I, "for", e.name), Fi(D, e.actionOption.label), br(O, "id", e.name);
          }), ow(O, () => _e3(r), (T) => It(r, T)), We(E, S);
        }, _ = (E) => {
          var S = cr(), I = wn(S);
          {
            var D = (O) => {
              var T = ww(), M = yn(T);
              M.__change = s;
              var J = Hs(M);
              _n3(
                (X) => {
                  br(T, "for", e.name), br(M, "id", X), Fi(J, ` ${e.actionOption.label ?? ""}`);
                },
                [() => String(e.name)]
              ), fw(M, () => _e3(r), (X) => It(r, X)), We(O, T);
            };
            Yt(
              I,
              (O) => {
                e.actionOption.type === "toggle" && typeof _e3(r) == "boolean" && O(D);
              },
              true
            );
          }
          We(E, S);
        };
        Yt(d, (E) => {
          e.actionOption.type === "select" ? E(v) : E(_, false);
        });
      }
      We(h, p);
    };
    Yt(l, (h) => {
      e.actionOption && h(f);
    });
  }
  We(t, u), Ki();
}
bo(["change"]);
var Mw = ln('<button type="submit" class="sub-action svelte-1xmw7n6"> </button>');
function Iw(t, e) {
  Zi(e, true);
  const r = (f) => {
    if (f.preventDefault(), !e.actionInstance || !e.subAction) {
      te.error("Can't run a SubAction", e.actionInstance, e.subAction);
      return;
    }
    e.subAction.method();
  };
  var s = cr(), u = wn(s);
  {
    var l = (f) => {
      var h = Mw();
      h.__click = r;
      var p = yn(h);
      _n3(() => {
        br(h, "id", `subaction-${e.name}`), br(h, "title", e.subAction.label), Fi(p, e.subAction.label);
      }), We(f, h);
    };
    Yt(u, (f) => {
      e.subAction && f(l);
    });
  }
  We(t, s), Ki();
}
bo(["click"]);
var bw = ln("<!> <!>", 1);
function Aw(t, e) {
  Zi(e, true);
  const r = Bg("gm"), s = vn(() => e.control.type), u = vn(() => e.control.targetMode), l = vn(() => _e3(s) && _e3(u) && r.actionInstances[`${_e3(s)}__${_e3(u)}`] || null);
  var f = cr(), h = wn(f);
  {
    var p = (d) => {
      var v = bw(), _ = wn(v);
      Ws(_, 17, () => Object.entries(_e3(l).options), ([S, I]) => S, (S, I) => {
        var D = vn(() => Qa(_e3(I), 2));
        let O = () => _e3(D)[0], T = () => _e3(D)[1];
        Sw(S, {
          get name() {
            return O();
          },
          get actionInstance() {
            return _e3(l);
          },
          get actionOption() {
            return T();
          }
        });
      });
      var E = Hs(_, 2);
      Ws(E, 17, () => Object.entries(_e3(l).actions), ([S, I]) => S, (S, I) => {
        var D = vn(() => Qa(_e3(I), 2));
        let O = () => _e3(D)[0], T = () => _e3(D)[1];
        Iw(S, {
          get name() {
            return O();
          },
          get actionInstance() {
            return _e3(l);
          },
          get subAction() {
            return T();
          }
        });
      }), We(d, v);
    };
    Yt(h, (d) => {
      _e3(l) && d(p);
    });
  }
  We(t, f), Ki();
}
var {
  entries: Id,
  setPrototypeOf: Fh,
  isFrozen: Lw,
  getPrototypeOf: Tw,
  getOwnPropertyDescriptor: Cw
} = Object;
var {
  freeze: Lt,
  seal: un,
  create: Hu
} = Object;
var {
  apply: Ju,
  construct: $u
} = typeof Reflect < "u" && Reflect;
Lt || (Lt = function(e) {
  return e;
});
un || (un = function(e) {
  return e;
});
Ju || (Ju = function(e, r) {
  for (var s = arguments.length, u = new Array(s > 2 ? s - 2 : 0), l = 2; l < s; l++)
    u[l - 2] = arguments[l];
  return e.apply(r, u);
});
$u || ($u = function(e) {
  for (var r = arguments.length, s = new Array(r > 1 ? r - 1 : 0), u = 1; u < r; u++)
    s[u - 1] = arguments[u];
  return new e(...s);
});
var ka = Tt(Array.prototype.forEach);
var Nw = Tt(Array.prototype.lastIndexOf);
var Gh = Tt(Array.prototype.pop);
var gs = Tt(Array.prototype.push);
var Pw = Tt(Array.prototype.splice);
var za = Tt(String.prototype.toLowerCase);
var nu = Tt(String.prototype.toString);
var ru = Tt(String.prototype.match);
var ds = Tt(String.prototype.replace);
var Ow = Tt(String.prototype.indexOf);
var Rw = Tt(String.prototype.trim);
var dn = Tt(Object.prototype.hasOwnProperty);
var kt = Tt(RegExp.prototype.test);
var ps = Dw(TypeError);
function Tt(t) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var r = arguments.length, s = new Array(r > 1 ? r - 1 : 0), u = 1; u < r; u++)
      s[u - 1] = arguments[u];
    return Ju(t, e, s);
  };
}
function Dw(t) {
  return function() {
    for (var e = arguments.length, r = new Array(e), s = 0; s < e; s++)
      r[s] = arguments[s];
    return $u(t, r);
  };
}
function Se(t, e) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : za;
  Fh && Fh(t, null);
  let s = e.length;
  for (; s--; ) {
    let u = e[s];
    if (typeof u == "string") {
      const l = r(u);
      l !== u && (Lw(e) || (e[s] = l), u = l);
    }
    t[u] = true;
  }
  return t;
}
function Fw(t) {
  for (let e = 0; e < t.length; e++)
    dn(t, e) || (t[e] = null);
  return t;
}
function Fn(t) {
  const e = Hu(null);
  for (const [r, s] of Id(t))
    dn(t, r) && (Array.isArray(s) ? e[r] = Fw(s) : s && typeof s == "object" && s.constructor === Object ? e[r] = Fn(s) : e[r] = s);
  return e;
}
function ms(t, e) {
  for (; t !== null; ) {
    const s = Cw(t, e);
    if (s) {
      if (s.get)
        return Tt(s.get);
      if (typeof s.value == "function")
        return Tt(s.value);
    }
    t = Tw(t);
  }
  function r() {
    return null;
  }
  return r;
}
var Bh = Lt(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var iu = Lt(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var su = Lt(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var Gw = Lt(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var au = Lt(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
var Bw = Lt(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var Uh = Lt(["#text"]);
var zh = Lt(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
var ou = Lt(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var qh = Lt(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var Sa = Lt(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var Uw = un(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var zw = un(/<%[\w\W]*|[\w\W]*%>/gm);
var qw = un(/\$\{[\w\W]*/gm);
var Yw = un(/^data-[\-\w.\u00B7-\uFFFF]+$/);
var Hw = un(/^aria-[\-\w]+$/);
var bd = un(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var Jw = un(/^(?:\w+script|data):/i);
var $w = un(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var Ad = un(/^html$/i);
var Vw = un(/^[a-z][.\w]*(-[.\w]+)+$/i);
var Yh = Object.freeze({
  __proto__: null,
  ARIA_ATTR: Hw,
  ATTR_WHITESPACE: $w,
  CUSTOM_ELEMENT: Vw,
  DATA_ATTR: Yw,
  DOCTYPE_NAME: Ad,
  ERB_EXPR: zw,
  IS_ALLOWED_URI: bd,
  IS_SCRIPT_OR_DATA: Jw,
  MUSTACHE_EXPR: Uw,
  TMPLIT_EXPR: qw
});
var vs = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
};
var Xw = function() {
  return typeof window > "u" ? null : window;
};
var Ww = function(e, r) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let s = null;
  const u = "data-tt-policy-suffix";
  r && r.hasAttribute(u) && (s = r.getAttribute(u));
  const l = "dompurify" + (s ? "#" + s : "");
  try {
    return e.createPolicy(l, {
      createHTML(f) {
        return f;
      },
      createScriptURL(f) {
        return f;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + l + " could not be created."), null;
  }
};
var Hh = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function Ld() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Xw();
  const e = (de) => Ld(de);
  if (e.version = "3.3.1", e.removed = [], !t || !t.document || t.document.nodeType !== vs.document || !t.Element)
    return e.isSupported = false, e;
  let {
    document: r
  } = t;
  const s = r, u = s.currentScript, {
    DocumentFragment: l,
    HTMLTemplateElement: f,
    Node: h,
    Element: p,
    NodeFilter: d,
    NamedNodeMap: v = t.NamedNodeMap || t.MozNamedAttrMap,
    HTMLFormElement: _,
    DOMParser: E,
    trustedTypes: S
  } = t, I = p.prototype, D = ms(I, "cloneNode"), O = ms(I, "remove"), T = ms(I, "nextSibling"), M = ms(I, "childNodes"), J = ms(I, "parentNode");
  if (typeof f == "function") {
    const de = r.createElement("template");
    de.content && de.content.ownerDocument && (r = de.content.ownerDocument);
  }
  let X, $ = "";
  const {
    implementation: Y,
    createNodeIterator: j,
    createDocumentFragment: x,
    getElementsByTagName: k
  } = r, {
    importNode: b
  } = s;
  let L = Hh();
  e.isSupported = typeof Id == "function" && typeof J == "function" && Y && Y.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: C,
    ERB_EXPR: G,
    TMPLIT_EXPR: R,
    DATA_ATTR: P,
    ARIA_ATTR: F,
    IS_SCRIPT_OR_DATA: q,
    ATTR_WHITESPACE: U,
    CUSTOM_ELEMENT: W
  } = Yh;
  let {
    IS_ALLOWED_URI: Z
  } = Yh, ne = null;
  const ge = Se({}, [...Bh, ...iu, ...su, ...au, ...Uh]);
  let le = null;
  const ae = Se({}, [...zh, ...ou, ...qh, ...Sa]);
  let oe = Object.seal(Hu(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  })), xe = null, Te = null;
  const H = Object.seal(Hu(null, {
    tagCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    }
  }));
  let bn = true, Ie = true, ce = false, N = true, Ce = false, De = true, ke = false, hi = false, Gr = false, _r4 = false, re = false, Br = false, rs = true, An = false;
  const Po = "user-content-";
  let Ee = true, cn = false, hn = {}, Ct = null;
  const ve = Se({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let fi = null;
  const Me = Se({}, ["audio", "video", "img", "source", "image", "track"]);
  let ye = null;
  const la = Se({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Nt = "http://www.w3.org/1998/Math/MathML", gi = "http://www.w3.org/2000/svg", pe = "http://www.w3.org/1999/xhtml";
  let Er = pe, is = false, Ur = null;
  const Pt = Se({}, [Nt, gi, pe], nu);
  let Ln = Se({}, ["mi", "mo", "mn", "ms", "mtext"]), Et = Se({}, ["annotation-xml"]);
  const ca = Se({}, ["title", "style", "font", "a", "script"]);
  let Tn = null;
  const Oo = ["application/xhtml+xml", "text/html"], ha = "text/html";
  let Fe = null, ie = null;
  const di = r.createElement("form"), zr = function(B) {
    return B instanceof RegExp || B instanceof Function;
  }, Zn = function() {
    let B = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(ie && ie === B)) {
      if ((!B || typeof B != "object") && (B = {}), B = Fn(B), Tn = // eslint-disable-next-line unicorn/prefer-includes
      Oo.indexOf(B.PARSER_MEDIA_TYPE) === -1 ? ha : B.PARSER_MEDIA_TYPE, Fe = Tn === "application/xhtml+xml" ? nu : za, ne = dn(B, "ALLOWED_TAGS") ? Se({}, B.ALLOWED_TAGS, Fe) : ge, le = dn(B, "ALLOWED_ATTR") ? Se({}, B.ALLOWED_ATTR, Fe) : ae, Ur = dn(B, "ALLOWED_NAMESPACES") ? Se({}, B.ALLOWED_NAMESPACES, nu) : Pt, ye = dn(B, "ADD_URI_SAFE_ATTR") ? Se(Fn(la), B.ADD_URI_SAFE_ATTR, Fe) : la, fi = dn(B, "ADD_DATA_URI_TAGS") ? Se(Fn(Me), B.ADD_DATA_URI_TAGS, Fe) : Me, Ct = dn(B, "FORBID_CONTENTS") ? Se({}, B.FORBID_CONTENTS, Fe) : ve, xe = dn(B, "FORBID_TAGS") ? Se({}, B.FORBID_TAGS, Fe) : Fn({}), Te = dn(B, "FORBID_ATTR") ? Se({}, B.FORBID_ATTR, Fe) : Fn({}), hn = dn(B, "USE_PROFILES") ? B.USE_PROFILES : false, bn = B.ALLOW_ARIA_ATTR !== false, Ie = B.ALLOW_DATA_ATTR !== false, ce = B.ALLOW_UNKNOWN_PROTOCOLS || false, N = B.ALLOW_SELF_CLOSE_IN_ATTR !== false, Ce = B.SAFE_FOR_TEMPLATES || false, De = B.SAFE_FOR_XML !== false, ke = B.WHOLE_DOCUMENT || false, _r4 = B.RETURN_DOM || false, re = B.RETURN_DOM_FRAGMENT || false, Br = B.RETURN_TRUSTED_TYPE || false, Gr = B.FORCE_BODY || false, rs = B.SANITIZE_DOM !== false, An = B.SANITIZE_NAMED_PROPS || false, Ee = B.KEEP_CONTENT !== false, cn = B.IN_PLACE || false, Z = B.ALLOWED_URI_REGEXP || bd, Er = B.NAMESPACE || pe, Ln = B.MATHML_TEXT_INTEGRATION_POINTS || Ln, Et = B.HTML_INTEGRATION_POINTS || Et, oe = B.CUSTOM_ELEMENT_HANDLING || {}, B.CUSTOM_ELEMENT_HANDLING && zr(B.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (oe.tagNameCheck = B.CUSTOM_ELEMENT_HANDLING.tagNameCheck), B.CUSTOM_ELEMENT_HANDLING && zr(B.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (oe.attributeNameCheck = B.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), B.CUSTOM_ELEMENT_HANDLING && typeof B.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (oe.allowCustomizedBuiltInElements = B.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ce && (Ie = false), re && (_r4 = true), hn && (ne = Se({}, Uh), le = [], hn.html === true && (Se(ne, Bh), Se(le, zh)), hn.svg === true && (Se(ne, iu), Se(le, ou), Se(le, Sa)), hn.svgFilters === true && (Se(ne, su), Se(le, ou), Se(le, Sa)), hn.mathMl === true && (Se(ne, au), Se(le, qh), Se(le, Sa))), B.ADD_TAGS && (typeof B.ADD_TAGS == "function" ? H.tagCheck = B.ADD_TAGS : (ne === ge && (ne = Fn(ne)), Se(ne, B.ADD_TAGS, Fe))), B.ADD_ATTR && (typeof B.ADD_ATTR == "function" ? H.attributeCheck = B.ADD_ATTR : (le === ae && (le = Fn(le)), Se(le, B.ADD_ATTR, Fe))), B.ADD_URI_SAFE_ATTR && Se(ye, B.ADD_URI_SAFE_ATTR, Fe), B.FORBID_CONTENTS && (Ct === ve && (Ct = Fn(Ct)), Se(Ct, B.FORBID_CONTENTS, Fe)), B.ADD_FORBID_CONTENTS && (Ct === ve && (Ct = Fn(Ct)), Se(Ct, B.ADD_FORBID_CONTENTS, Fe)), Ee && (ne["#text"] = true), ke && Se(ne, ["html", "head", "body"]), ne.table && (Se(ne, ["tbody"]), delete xe.tbody), B.TRUSTED_TYPES_POLICY) {
        if (typeof B.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw ps('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof B.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw ps('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        X = B.TRUSTED_TYPES_POLICY, $ = X.createHTML("");
      } else
        X === void 0 && (X = Ww(S, u)), X !== null && typeof $ == "string" && ($ = X.createHTML(""));
      Lt && Lt(B), ie = B;
    }
  }, ss = Se({}, [...iu, ...su, ...Gw]), pi = Se({}, [...au, ...Bw]), fa = function(B) {
    let Q = J(B);
    (!Q || !Q.tagName) && (Q = {
      namespaceURI: Er,
      tagName: "template"
    });
    const he = za(B.tagName), Ue = za(Q.tagName);
    return Ur[B.namespaceURI] ? B.namespaceURI === gi ? Q.namespaceURI === pe ? he === "svg" : Q.namespaceURI === Nt ? he === "svg" && (Ue === "annotation-xml" || Ln[Ue]) : !!ss[he] : B.namespaceURI === Nt ? Q.namespaceURI === pe ? he === "math" : Q.namespaceURI === gi ? he === "math" && Et[Ue] : !!pi[he] : B.namespaceURI === pe ? Q.namespaceURI === gi && !Et[Ue] || Q.namespaceURI === Nt && !Ln[Ue] ? false : !pi[he] && (ca[he] || !ss[he]) : !!(Tn === "application/xhtml+xml" && Ur[B.namespaceURI]) : false;
  }, rt = function(B) {
    gs(e.removed, {
      element: B
    });
    try {
      J(B).removeChild(B);
    } catch {
      O(B);
    }
  }, Cn = function(B, Q) {
    try {
      gs(e.removed, {
        attribute: Q.getAttributeNode(B),
        from: Q
      });
    } catch {
      gs(e.removed, {
        attribute: null,
        from: Q
      });
    }
    if (Q.removeAttribute(B), B === "is")
      if (_r4 || re)
        try {
          rt(Q);
        } catch {
        }
      else
        try {
          Q.setAttribute(B, "");
        } catch {
        }
  }, qr = function(B) {
    let Q = null, he = null;
    if (Gr)
      B = "<remove></remove>" + B;
    else {
      const ze = ru(B, /^[\r\n\t ]+/);
      he = ze && ze[0];
    }
    Tn === "application/xhtml+xml" && Er === pe && (B = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + B + "</body></html>");
    const Ue = X ? X.createHTML(B) : B;
    if (Er === pe)
      try {
        Q = new E().parseFromString(Ue, Tn);
      } catch {
      }
    if (!Q || !Q.documentElement) {
      Q = Y.createDocument(Er, "template", null);
      try {
        Q.documentElement.innerHTML = is ? $ : Ue;
      } catch {
      }
    }
    const Qe = Q.body || Q.documentElement;
    return B && he && Qe.insertBefore(r.createTextNode(he), Qe.childNodes[0] || null), Er === pe ? k.call(Q, ke ? "html" : "body")[0] : ke ? Q.documentElement : Qe;
  }, ga = function(B) {
    return j.call(
      B.ownerDocument || B,
      B,
      // eslint-disable-next-line no-bitwise
      d.SHOW_ELEMENT | d.SHOW_COMMENT | d.SHOW_TEXT | d.SHOW_PROCESSING_INSTRUCTION | d.SHOW_CDATA_SECTION,
      null
    );
  }, mi = function(B) {
    return B instanceof _ && (typeof B.nodeName != "string" || typeof B.textContent != "string" || typeof B.removeChild != "function" || !(B.attributes instanceof v) || typeof B.removeAttribute != "function" || typeof B.setAttribute != "function" || typeof B.namespaceURI != "string" || typeof B.insertBefore != "function" || typeof B.hasChildNodes != "function");
  }, da = function(B) {
    return typeof h == "function" && B instanceof h;
  };
  function Ve(de, B, Q) {
    ka(de, (he) => {
      he.call(e, B, Q, ie);
    });
  }
  const vi = function(B) {
    let Q = null;
    if (Ve(L.beforeSanitizeElements, B, null), mi(B))
      return rt(B), true;
    const he = Fe(B.nodeName);
    if (Ve(L.uponSanitizeElement, B, {
      tagName: he,
      allowedTags: ne
    }), De && B.hasChildNodes() && !da(B.firstElementChild) && kt(/<[/\w!]/g, B.innerHTML) && kt(/<[/\w!]/g, B.textContent) || B.nodeType === vs.progressingInstruction || De && B.nodeType === vs.comment && kt(/<[/\w]/g, B.data))
      return rt(B), true;
    if (!(H.tagCheck instanceof Function && H.tagCheck(he)) && (!ne[he] || xe[he])) {
      if (!xe[he] && Nn(he) && (oe.tagNameCheck instanceof RegExp && kt(oe.tagNameCheck, he) || oe.tagNameCheck instanceof Function && oe.tagNameCheck(he)))
        return false;
      if (Ee && !Ct[he]) {
        const Ue = J(B) || B.parentNode, Qe = M(B) || B.childNodes;
        if (Qe && Ue) {
          const ze = Qe.length;
          for (let it = ze - 1; it >= 0; --it) {
            const Gt = D(Qe[it], true);
            Gt.__removalCount = (B.__removalCount || 0) + 1, Ue.insertBefore(Gt, T(B));
          }
        }
      }
      return rt(B), true;
    }
    return B instanceof p && !fa(B) || (he === "noscript" || he === "noembed" || he === "noframes") && kt(/<\/no(script|embed|frames)/i, B.innerHTML) ? (rt(B), true) : (Ce && B.nodeType === vs.text && (Q = B.textContent, ka([C, G, R], (Ue) => {
      Q = ds(Q, Ue, " ");
    }), B.textContent !== Q && (gs(e.removed, {
      element: B.cloneNode()
    }), B.textContent = Q)), Ve(L.afterSanitizeElements, B, null), false);
  }, xr = function(B, Q, he) {
    if (rs && (Q === "id" || Q === "name") && (he in r || he in di))
      return false;
    if (!(Ie && !Te[Q] && kt(P, Q))) {
      if (!(bn && kt(F, Q))) {
        if (!(H.attributeCheck instanceof Function && H.attributeCheck(Q, B))) {
          if (!le[Q] || Te[Q]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              !(Nn(B) && (oe.tagNameCheck instanceof RegExp && kt(oe.tagNameCheck, B) || oe.tagNameCheck instanceof Function && oe.tagNameCheck(B)) && (oe.attributeNameCheck instanceof RegExp && kt(oe.attributeNameCheck, Q) || oe.attributeNameCheck instanceof Function && oe.attributeNameCheck(Q, B)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              Q === "is" && oe.allowCustomizedBuiltInElements && (oe.tagNameCheck instanceof RegExp && kt(oe.tagNameCheck, he) || oe.tagNameCheck instanceof Function && oe.tagNameCheck(he)))
            ) return false;
          } else if (!ye[Q]) {
            if (!kt(Z, ds(he, U, ""))) {
              if (!((Q === "src" || Q === "xlink:href" || Q === "href") && B !== "script" && Ow(he, "data:") === 0 && fi[B])) {
                if (!(ce && !kt(q, ds(he, U, "")))) {
                  if (he)
                    return false;
                }
              }
            }
          }
        }
      }
    }
    return true;
  }, Nn = function(B) {
    return B !== "annotation-xml" && ru(B, W);
  }, Pn = function(B) {
    Ve(L.beforeSanitizeAttributes, B, null);
    const {
      attributes: Q
    } = B;
    if (!Q || mi(B))
      return;
    const he = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: le,
      forceKeepAttr: void 0
    };
    let Ue = Q.length;
    for (; Ue--; ) {
      const Qe = Q[Ue], {
        name: ze,
        namespaceURI: it,
        value: Gt
      } = Qe, Kn = Fe(ze), os = Gt;
      let Re = ze === "value" ? os : Rw(os);
      if (he.attrName = Kn, he.attrValue = Re, he.keepAttr = true, he.forceKeepAttr = void 0, Ve(L.uponSanitizeAttribute, B, he), Re = he.attrValue, An && (Kn === "id" || Kn === "name") && (Cn(ze, B), Re = Po + Re), De && kt(/((--!?|])>)|<\/(style|title|textarea)/i, Re)) {
        Cn(ze, B);
        continue;
      }
      if (Kn === "attributename" && ru(Re, "href")) {
        Cn(ze, B);
        continue;
      }
      if (he.forceKeepAttr)
        continue;
      if (!he.keepAttr) {
        Cn(ze, B);
        continue;
      }
      if (!N && kt(/\/>/i, Re)) {
        Cn(ze, B);
        continue;
      }
      Ce && ka([C, G, R], (yi) => {
        Re = ds(Re, yi, " ");
      });
      const Qn = Fe(B.nodeName);
      if (!xr(Qn, Kn, Re)) {
        Cn(ze, B);
        continue;
      }
      if (X && typeof S == "object" && typeof S.getAttributeType == "function" && !it)
        switch (S.getAttributeType(Qn, Kn)) {
          case "TrustedHTML": {
            Re = X.createHTML(Re);
            break;
          }
          case "TrustedScriptURL": {
            Re = X.createScriptURL(Re);
            break;
          }
        }
      if (Re !== os)
        try {
          it ? B.setAttributeNS(it, ze, Re) : B.setAttribute(ze, Re), mi(B) ? rt(B) : Gh(e.removed);
        } catch {
          Cn(ze, B);
        }
    }
    Ve(L.afterSanitizeAttributes, B, null);
  }, as = function de(B) {
    let Q = null;
    const he = ga(B);
    for (Ve(L.beforeSanitizeShadowDOM, B, null); Q = he.nextNode(); )
      Ve(L.uponSanitizeShadowNode, Q, null), vi(Q), Pn(Q), Q.content instanceof l && de(Q.content);
    Ve(L.afterSanitizeShadowDOM, B, null);
  };
  return e.sanitize = function(de) {
    let B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Q = null, he = null, Ue = null, Qe = null;
    if (is = !de, is && (de = "<!-->"), typeof de != "string" && !da(de))
      if (typeof de.toString == "function") {
        if (de = de.toString(), typeof de != "string")
          throw ps("dirty is not a string, aborting");
      } else
        throw ps("toString is not a function");
    if (!e.isSupported)
      return de;
    if (hi || Zn(B), e.removed = [], typeof de == "string" && (cn = false), cn) {
      if (de.nodeName) {
        const Gt = Fe(de.nodeName);
        if (!ne[Gt] || xe[Gt])
          throw ps("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (de instanceof h)
      Q = qr("<!---->"), he = Q.ownerDocument.importNode(de, true), he.nodeType === vs.element && he.nodeName === "BODY" || he.nodeName === "HTML" ? Q = he : Q.appendChild(he);
    else {
      if (!_r4 && !Ce && !ke && // eslint-disable-next-line unicorn/prefer-includes
      de.indexOf("<") === -1)
        return X && Br ? X.createHTML(de) : de;
      if (Q = qr(de), !Q)
        return _r4 ? null : Br ? $ : "";
    }
    Q && Gr && rt(Q.firstChild);
    const ze = ga(cn ? de : Q);
    for (; Ue = ze.nextNode(); )
      vi(Ue), Pn(Ue), Ue.content instanceof l && as(Ue.content);
    if (cn)
      return de;
    if (_r4) {
      if (re)
        for (Qe = x.call(Q.ownerDocument); Q.firstChild; )
          Qe.appendChild(Q.firstChild);
      else
        Qe = Q;
      return (le.shadowroot || le.shadowrootmode) && (Qe = b.call(s, Qe, true)), Qe;
    }
    let it = ke ? Q.outerHTML : Q.innerHTML;
    return ke && ne["!doctype"] && Q.ownerDocument && Q.ownerDocument.doctype && Q.ownerDocument.doctype.name && kt(Ad, Q.ownerDocument.doctype.name) && (it = "<!DOCTYPE " + Q.ownerDocument.doctype.name + `>
` + it), Ce && ka([C, G, R], (Gt) => {
      it = ds(it, Gt, " ");
    }), X && Br ? X.createHTML(it) : it;
  }, e.setConfig = function() {
    let de = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Zn(de), hi = true;
  }, e.clearConfig = function() {
    ie = null, hi = false;
  }, e.isValidAttribute = function(de, B, Q) {
    ie || Zn({});
    const he = Fe(de), Ue = Fe(B);
    return xr(he, Ue, Q);
  }, e.addHook = function(de, B) {
    typeof B == "function" && gs(L[de], B);
  }, e.removeHook = function(de, B) {
    if (B !== void 0) {
      const Q = Nw(L[de], B);
      return Q === -1 ? void 0 : Pw(L[de], Q, 1)[0];
    }
    return Gh(L[de]);
  }, e.removeHooks = function(de) {
    L[de] = [];
  }, e.removeAllHooks = function() {
    L = Hh();
  }, e;
}
var Td = Ld();
var jw = ln("<div><!></div>");
var Zw = ln('<div><button type="button"><!></button> <!></div>');
function Kw(t, e) {
  Zi(e, true);
  const r = () => kd(Fl, "$controlsStore", s), [s, u] = Sd(), l = vn(() => {
    var _a6;
    return ((_a6 = e.controlOptions) == null ? void 0 : _a6.icon) ? Td.sanitize(e.controlOptions.icon.trim()) : null;
  }), f = Bg("gm"), h = f.control.getDefaultPosition(), p = () => {
    e.control && e.controlOptions ? f.options.toggleMode(e.control.type, e.control.targetMode) : te.error("Control or controlOptions not defined", e.control, e.controlOptions);
  };
  var d = cr(), v = wn(d);
  {
    var _ = (E) => {
      var S = Zw(), I = yn(S);
      let D;
      I.__click = p;
      var O = yn(I);
      {
        var T = ($) => {
          var Y = cr(), j = wn(Y);
          _d2(j, () => _e3(l)), We($, Y);
        }, M = ($) => {
          var Y = cr(), j = wn(Y);
          {
            var x = (b) => {
              var L = Ch();
              _n3((C) => Fi(L, C), [() => e.controlOptions.title.slice(0, 2)]), We(b, L);
            }, k = (b) => {
              var L = Ch();
              _n3(() => Fi(L, e.control.targetMode)), We(b, L);
            };
            Yt(
              j,
              (b) => {
                e.controlOptions.title ? b(x) : b(k, false);
              },
              true
            );
          }
          We($, Y);
        };
        Yt(O, ($) => {
          e.controlOptions.icon ? $(T) : $(M, false);
        });
      }
      var J = Hs(I, 2);
      {
        var X = ($) => {
          var Y = jw();
          let j;
          var x = yn(Y);
          Aw(x, {
            get control() {
              return e.control;
            }
          }), _n3((k) => j = Ds(Y, 1, "control-menu svelte-1q85gr9", null, j, k), [
            () => ({
              "menu-right": h.endsWith("left"),
              "menu-left": h.endsWith("right")
            })
          ]), We($, Y);
        };
        Yt(J, ($) => {
          e.controlOptions.active && $(X);
        });
      }
      _n3(() => {
        Ds(S, 1, iw(r().settings.controlsStyles.controlContainerClass), "svelte-1q85gr9"), br(I, "id", `id_${e.control.type}_${e.control.targetMode}`), D = Ds(I, 1, `${r().settings.controlsStyles.controlButtonClass} ${e.control.type}-${e.control.targetMode}`, "svelte-1q85gr9", D, { active: e.controlOptions.active }), br(I, "title", e.controlOptions.title);
      }), We(E, S);
    };
    Yt(v, (E) => {
      e.control && e.controlOptions && e.controlOptions.uiEnabled && E(_);
    });
  }
  We(t, d), Ki(), u();
}
bo(["click"]);
function Qw(t) {
  const e = t - 1;
  return e * e * e + 1;
}
function Jh(t, { delay: e = 0, duration: r = 400, easing: s = Qw, axis: u = "y" } = {}) {
  const l = getComputedStyle(t), f = +l.opacity, h = u === "y" ? "height" : "width", p = parseFloat(l[h]), d = u === "y" ? ["top", "bottom"] : ["left", "right"], v = d.map(
    (T) => (
      /** @type {'Left' | 'Right' | 'Top' | 'Bottom'} */
      `${T[0].toUpperCase()}${T.slice(1)}`
    )
  ), _ = parseFloat(l[`padding${v[0]}`]), E = parseFloat(l[`padding${v[1]}`]), S = parseFloat(l[`margin${v[0]}`]), I = parseFloat(l[`margin${v[1]}`]), D = parseFloat(
    l[`border${v[0]}Width`]
  ), O = parseFloat(
    l[`border${v[1]}Width`]
  );
  return {
    delay: e,
    duration: r,
    easing: s,
    css: (T) => `overflow: hidden;opacity: ${Math.min(T * 20, 1) * f};${h}: ${T * p}px;padding-${d[0]}: ${T * _}px;padding-${d[1]}: ${T * E}px;margin-${d[0]}: ${T * S}px;margin-${d[1]}: ${T * I}px;border-${d[0]}-width: ${T * D}px;border-${d[1]}-width: ${T * O}px;min-${h}: 0`
  };
}
var ek = ln('<div><button class="gm-control-button"><!></button></div>');
var tk = ln("<div></div>");
var nk = ln("<div></div>");
var rk = ln('<div class="gm-reactive-controls"><!> <!></div>');
function ik(t, e) {
  Zi(e, true);
  const r = () => kd(Fl, "$controlsStore", s), [s, u] = Sd();
  let l = Gn(true), f = vn(() => r().settings.controlsCollapsible), h = vn(() => r().settings.controlsStyles);
  const p = (T, M) => {
    var _a6, _b2;
    return ((_b2 = (_a6 = r().controls) == null ? void 0 : _a6[T]) == null ? void 0 : _b2[M]) || null;
  }, d = (T, M) => Object.entries(M).some(([J, X]) => p(T, J) && X && X.uiEnabled), v = () => {
    It(l, !_e3(l));
  }, _ = () => Td.sanitize(_e3(l) ? yw : _w);
  var E = rk(), S = yn(E);
  {
    var I = (T) => {
      var M = ek(), J = yn(M);
      J.__click = v;
      var X = yn(J);
      _d2(X, _), _n3(() => Ds(M, 1, `${_e3(h).controlGroupClass} group-settings`)), We(T, M);
    };
    Yt(S, (T) => {
      _e3(f) && T(I);
    });
  }
  var D = Hs(S, 2);
  {
    var O = (T) => {
      var M = nk();
      Ws(M, 5, () => Object.entries(r().options), ([J, X]) => J, (J, X) => {
        var $ = vn(() => Qa(_e3(X), 2));
        let Y = () => _e3($)[0], j = () => _e3($)[1];
        var x = cr(), k = wn(x);
        {
          var b = (L) => {
            var C = tk();
            Ws(C, 21, () => Object.entries(j()), ([G, R]) => G, (G, R) => {
              var P = vn(() => Qa(_e3(R), 2));
              let F = () => _e3(P)[0], q = () => _e3(P)[1];
              const U = vn(() => p(Y(), F()));
              var W = cr(), Z = wn(W);
              {
                var ne = (ge) => {
                  Kw(ge, {
                    get control() {
                      return _e3(U);
                    },
                    get controlOptions() {
                      return q();
                    }
                  });
                };
                Yt(Z, (ge) => {
                  _e3(U) && ge(ne);
                });
              }
              We(G, W);
            }), _n3(() => Ds(C, 1, `${_e3(h).controlGroupClass} group-${Y()}`)), We(L, C);
          };
          Yt(k, (L) => {
            d(Y(), j()) && L(b);
          });
        }
        We(J, x);
      }), Oh(1, M, () => Jh, () => ({ duration: 180 })), Oh(2, M, () => Jh, () => ({ duration: 140 })), We(T, M);
    };
    Yt(D, (T) => {
      _e3(l) && T(O);
    });
  }
  We(t, E), Ki(), u();
}
bo(["click"]);
var sk = class {
  constructor(e) {
    __publicField(this, "gm");
    this.gm = e;
  }
};
var et = (t) => Object.keys(t);
var Vu = (t) => Object.values(t);
var Cr = (t, e) => e.includes(t);
var ak = class extends sk {
  constructor() {
    super(...arguments);
    __publicField(this, "controls", $t(Wf));
    __publicField(this, "reactiveControls", null);
    __publicField(this, "container");
    __publicField(this, "eventHandlers", {
      [`${se}:draw`]: this.handleModeEvent.bind(this),
      [`${se}:edit`]: this.handleModeEvent.bind(this),
      [`${se}:helper`]: this.handleModeEvent.bind(this)
    });
  }
  onAdd() {
    if (this.createControls(), this.gm.events.bus.attachEvents(this.eventHandlers), !this.container)
      throw new Error("Controls container is not initialized");
    return this.container;
  }
  createControls(e = void 0) {
    if (this.controlsAdded()) {
      te.warn("Can't add controls: controls already added");
      return;
    }
    this.container = e || this.createHtmlContainer(), this.createReactivePanel();
  }
  onRemove() {
    this.gm.events.bus.detachEvents(this.eventHandlers), this.reactiveControls && (Vx(this.reactiveControls), this.reactiveControls = null), this.container && this.container.parentNode && this.container.parentNode.removeChild(this.container), this.container = void 0;
  }
  handleModeEvent(e) {
    return rc(e) ? (["mode_started", "mode_ended"].includes(e.action) && this.updateReactivePanel(), { next: true }) : { next: true };
  }
  controlsAdded() {
    return !!this.reactiveControls;
  }
  createReactivePanel() {
    if (!this.container) {
      te.error("Can't create reactive panel: container is not initialized");
      return;
    }
    this.syncModeStates();
    const e = /* @__PURE__ */ new Map();
    e.set("gm", this.gm), this.reactiveControls = Jx(ik, {
      target: this.container,
      context: e
    }), this.updateReactivePanel();
  }
  updateReactivePanel() {
    Fl.update(() => ({
      controls: this.controls,
      options: this.gm.options.controls,
      settings: this.gm.options.settings
    }));
  }
  createHtmlContainer() {
    const e = document.createElement("div");
    return e.classList.add("geoman-controls"), e;
  }
  syncModeStates() {
    this.eachControlWithOptions(({ control: e }) => {
      this.gm.options.syncModeState(e.type, e.targetMode);
    });
  }
  eachControlWithOptions(e) {
    return et(this.controls).forEach((r) => {
      const s = this.controls[r];
      return Object.keys(s).forEach((u) => {
        const l = u, f = this.getControl({ modeType: r, modeName: l }), h = this.gm.options.getControlOptions({
          modeType: r,
          modeName: l
        });
        f && h && e({ control: f, controlOptions: h });
      });
    });
  }
  getControl({
    modeType: e,
    modeName: r
  }) {
    return e && r && this.controls[e][r] || null;
  }
  getDefaultPosition() {
    return this.gm.options.settings.controlsPosition;
  }
};
var ok = class {
  constructor(e) {
    __publicField(this, "gm");
    __publicField(this, "globalEventsListener", null);
    this.gm = e;
  }
  get map() {
    return this.gm.mapAdapter.getMapInstance();
  }
  async processEvent(e, r) {
    await this.fireToMap({
      type: "system",
      eventName: e.split(":")[1],
      payload: {
        ...r,
        level: "user"
      }
    }), r.action === "mode_start" || r.action === "mode_end" ? await this.forwardModeToggledEvent(r) : r.action === "feature_created" ? await this.forwardFeatureCreated(r) : r.action === "feature_removed" ? await this.forwardFeatureRemoved(r) : r.action === "feature_updated" ? await this.forwardFeatureUpdated(r) : r.action === "feature_edit_start" ? await this.forwardFeatureEditStart(r) : r.action === "feature_edit_end" ? await this.forwardFeatureEditEnd(r) : (r.action === "loaded" || r.action === "unloaded") && await this.forwardGeomanLoaded(r);
  }
  async forwardModeToggledEvent(e) {
    const r = e.action === "mode_start";
    if (e.actionType === "draw") {
      const s = "globaldrawmodetoggled", u = {
        name: `${ut}:${s}`,
        actionType: e.actionType,
        action: e.action,
        enabled: r,
        shape: e.mode,
        map: this.map
      };
      await this.fireToMap({ type: "converted", eventName: s, payload: u });
      const l = r ? "drawstart" : "drawend", f = {
        name: `${ut}:${l}`,
        actionType: e.actionType,
        action: e.action,
        shape: e.mode,
        map: this.map
      };
      await this.fireToMap({
        type: "converted",
        eventName: l,
        payload: f
      });
    } else if (e.actionType === "edit") {
      const u = `global${this.getConvertedEditModeName(e.mode)}modetoggled`, l = {
        name: `${ut}:${u}`,
        actionType: e.actionType,
        action: e.action,
        enabled: r,
        map: this.map
      };
      await this.fireToMap({
        type: "converted",
        eventName: u,
        payload: l
      });
    } else if (e.actionType === "helper") {
      const s = `global${e.mode}modetoggled`, u = {
        name: `${ut}:${s}`,
        actionType: e.actionType,
        action: e.action,
        enabled: r,
        map: this.map
      };
      await this.fireToMap({
        type: "converted",
        eventName: s,
        payload: u
      });
    }
  }
  async forwardFeatureCreated(e) {
    const r = {
      name: `${ut}:create`,
      actionType: e.actionType,
      action: e.action,
      shape: e.mode,
      feature: e.featureData,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: "create", payload: r });
  }
  async forwardFeatureRemoved(e) {
    const r = {
      name: `${ut}:remove`,
      actionType: e.actionType,
      action: e.action,
      shape: e.mode,
      feature: e.featureData,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: "remove", payload: r });
  }
  async forwardFeatureUpdated(e) {
    const r = this.getConvertedEditModeName(e.mode), s = ["lasso"], u = {
      name: `${ut}:${r}`,
      actionType: e.actionType,
      action: e.action,
      map: this.map
    };
    e.sourceFeatures.length === 1 && !s.includes(e.mode) ? u.originalFeature = e.sourceFeatures[0] : u.originalFeatures = e.sourceFeatures, e.targetFeatures.length === 1 && !s.includes(e.mode) ? (u.feature = e.targetFeatures[0], u.shape = u.feature.shape) : u.features = e.targetFeatures, await this.fireToMap({ type: "converted", eventName: `${r}`, payload: u });
  }
  async forwardFeatureEditStart(e) {
    const r = this.getConvertedEditModeName(e.mode), s = {
      name: `${ut}:${r}start`,
      actionType: e.actionType,
      action: e.action,
      shape: e.feature.shape,
      feature: e.feature,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: `${r}start`, payload: s });
  }
  async forwardFeatureEditEnd(e) {
    const r = this.getConvertedEditModeName(e.mode), s = {
      name: `${ut}:${r}end`,
      actionType: e.actionType,
      action: e.action,
      shape: e.feature.shape,
      feature: e.feature,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: `${r}end`, payload: s });
  }
  async forwardGeomanLoaded(e) {
    const r = {
      name: `${ut}:${e.action}`,
      actionType: e.actionType,
      action: e.action,
      map: this.map,
      [ut]: this.gm
    };
    await this.fireToMap({
      type: "converted",
      eventName: `${r.action}`,
      payload: r
    });
  }
  async fireToMap({
    type: e,
    eventName: r,
    payload: s
  }) {
    var _a6, _b2;
    const l = `${e === "system" ? se : ut}:${r}`;
    if (this.gm.options.settings.awaitDataUpdatesOnEvents && "feature" in s && ((_a6 = s.feature) == null ? void 0 : _a6.source)) {
      const h = s.feature.source.id;
      await this.gm.features.updateManager.waitForPendingUpdates(h);
    }
    (_b2 = this.globalEventsListener) == null ? void 0 : _b2.call(this, s), this.gm.mapAdapter.fire(l, s);
  }
  getConvertedEditModeName(e) {
    return e === "change" ? "edit" : e;
  }
};
var Cd = (t) => Sn(t) && t.name === `${se}:control:switch`;
var Sn = (t) => !!(t && typeof t == "object" && ["level", "name", "actionType", "action"].every((r) => r in t));
var uk = (t) => !!(t && typeof t == "object" && ["type", "originalEvent", "target"].every((r) => r in t));
var lk = class {
  constructor(e) {
    __publicField(this, "gm");
    __publicField(this, "forwarder");
    __publicField(this, "mapEventHandlers", {});
    __publicField(this, "gmEventHandlers", {});
    // Track pending event forwarding to maintain event ordering
    // Events are processed sequentially to ensure dragstart fires before drag, etc.
    __publicField(this, "pendingForward", Promise.resolve());
    this.gm = e, this.forwarder = new ok(e);
  }
  fireEvent(e, r) {
    const s = this.gmEventHandlers[e];
    if (!s)
      return;
    const { controlHandler: u } = s;
    u(r), this.pendingForward = this.pendingForward.then(
      () => this.forwarder.processEvent(e, r)
    );
  }
  attachEvents(e) {
    et(e).forEach((r) => {
      const s = e[r];
      s && this.on(r, s);
    });
  }
  detachEvents(e) {
    et(e).forEach((r) => {
      const s = e[r];
      s && this.off(r, s);
    });
  }
  detachAllEvents() {
    et(this.gmEventHandlers).forEach((e) => {
      var _a6;
      Array.from(((_a6 = this.gmEventHandlers[e]) == null ? void 0 : _a6.handlers) || []).forEach((s) => {
        this.off(e, s);
      });
    }), et(this.mapEventHandlers).forEach((e) => {
      var _a6;
      Array.from(((_a6 = this.mapEventHandlers[e]) == null ? void 0 : _a6.handlers) || []).forEach((s) => {
        this.off(e, s);
      });
    });
  }
  on(e, r) {
    e.startsWith(se) ? this.onGmEvent(e, r) : this.onMapEvent(e, r);
  }
  onGmEvent(e, r) {
    var _a6;
    this.gmEventHandlers[e] || (this.gmEventHandlers[e] = this.createEventSection(e)), (_a6 = this.gmEventHandlers[e]) == null ? void 0 : _a6.handlers.unshift(r);
  }
  onMapEvent(e, r) {
    var _a6;
    if (!this.mapEventHandlers[e]) {
      const s = this.createEventSection(e);
      this.gm.mapAdapter.on(e, s.controlHandler), this.mapEventHandlers[e] = s;
    }
    (_a6 = this.mapEventHandlers[e]) == null ? void 0 : _a6.handlers.unshift(r);
  }
  off(e, r) {
    e.startsWith(`${se}`) ? this.offGmEvent(e, r) : this.offMapEvent(e, r);
  }
  offGmEvent(e, r) {
    var _a6;
    const s = ((_a6 = this.gmEventHandlers[e]) == null ? void 0 : _a6.handlers) || [], u = s.findIndex((l) => r === l);
    u === -1 ? te.warn("MapEvents: handler not found", e, r) : (s.splice(u, 1), s.length === 0 && delete this.gmEventHandlers[e]);
  }
  offMapEvent(e, r) {
    var _a6, _b2;
    const s = ((_a6 = this.mapEventHandlers[e]) == null ? void 0 : _a6.handlers) || [], u = s.findIndex((l) => r === l);
    if (u === -1)
      te.warn("MapEvents: handler not found", e, r);
    else if (s.splice(u, 1), s.length === 0) {
      const l = (_b2 = this.mapEventHandlers[e]) == null ? void 0 : _b2.controlHandler;
      l && this.gm.mapAdapter.off(e, l), delete this.mapEventHandlers[e];
    }
  }
  createEventSection(e) {
    return {
      handlers: [],
      controlHandler: (r) => {
        let s;
        if (Sn(r) && e.startsWith(`${se}`) ? s = this.gmEventHandlers[e] : s = this.mapEventHandlers[e], !s) {
          te.debug(`No handlers for eventName: "${e}"`);
          return;
        }
        s.handlers.some((u) => {
          let l;
          return Sn(r) || uk(r) ? l = u(r) : te.error("EventsBus: unknown event type", r), l && typeof l == "object" && "next" in l ? !l.next : (te.error('EventsBus: handler should return an object with a "next" property'), false);
        });
      }
    };
  }
};
var Ao = class {
  constructor(e) {
    __publicField(this, "gm");
    this.gm = e;
  }
  trackExclusiveModes(e) {
    var _a6;
    if (e.action !== "mode_start")
      return;
    const { sectionName: r, modeName: s } = this.getControlIds(e) || {};
    ((_a6 = this.getControl(e)) == null ? void 0 : _a6.settings.exclusive) && this.gm.control.eachControlWithOptions((l) => {
      const f = l.control.type, h = l.control.targetMode;
      f === r && h === s || l.controlOptions.active && l.control.settings.exclusive && this.gm.options.disableMode(f, h);
    });
  }
  trackRelatedModes(e) {
    rc(e) && this.gm.control.eachControlWithOptions((r) => {
      var _a6;
      const s = r.control, { type: u, targetMode: l } = s;
      ((_a6 = s.settings.enabledBy) == null ? void 0 : _a6.includes(e.mode)) && (e.action === "mode_start" ? (this.gm.options.isModeEnabled(u, l) && this.gm.options.disableMode(u, l), this.gm.options.enableMode(u, l)) : e.action === "mode_end" ? this.gm.options.disableMode(u, l) : te.error("Unknown mode action", e.action));
    });
  }
  getControl(e) {
    const { modeName: r, sectionName: s } = this.getControlIds(e) || {};
    return r && s ? this.gm.control.getControl({ modeType: s, modeName: r }) : null;
  }
  getControlOptions(e) {
    const { modeName: r, sectionName: s } = this.getControlIds(e) || {};
    return r && s ? this.gm.options.getControlOptions({ modeType: s, modeName: r }) : null;
  }
  getControlIds(e) {
    let r = null, s = null;
    return e.action === "mode_start" ? (r = e.actionType, s = e.mode) : Cd(e) && (r = e.section, s = e.mode), r && s ? { sectionName: r, modeName: s } : null;
  }
};
var ck = class extends Ao {
  constructor(e, r) {
    super(e);
    __publicField(this, "eventHandlers", {
      [`${se}:control`]: this.handleControlEvent.bind(this)
    });
    r.attachEvents(this.eventHandlers);
  }
  handleControlEvent(e) {
    return Cd(e) ? (this.getControl(e) || te.error("Control not found, event payload", e), { next: true }) : { next: true };
  }
};
var Nd = ["draw", "edit", "helper"];
var hk = [...Nd, "control"];
var or = [
  // shapes
  "marker",
  "circle",
  "circle_marker",
  "ellipse",
  "text_marker",
  "line",
  "rectangle",
  "polygon"
];
var fk = [
  "dom_marker",
  "vertex_marker",
  "center_marker",
  "edge_marker",
  "snap_guide"
];
var Pd = [...or, ...fk];
var gk = ["freehand", "custom_shape"];
var Od = [...or, ...gk];
var Rd = [
  "shape_markers",
  "pin",
  "snapping",
  "snap_guides",
  "measurements",
  "auto_trace",
  "geofencing",
  "zoom_to_features",
  "click_to_edit"
];
var Dd = [
  "drag",
  "change",
  "rotate",
  "scale",
  "copy",
  "cut",
  "split",
  "union",
  "difference",
  "line_simplification",
  "lasso",
  "delete"
];
var dk = (t) => Array.isArray(t) && t.length === 2 && typeof t[0] == "number" && typeof t[1] == "number";
var uu = {
  id: (t) => typeof t == "string" || typeof t == "number",
  shape: (t) => typeof t == "string" && Cr(t, Pd),
  center: (t) => dk(t),
  xSemiAxis: (t) => typeof t == "number",
  ySemiAxis: (t) => typeof t == "number",
  angle: (t) => typeof t == "number",
  text: (t) => typeof t == "string",
  disableEdit: (t) => typeof t == "boolean"
};
var Gl = class {
  isMarkerInstanceAvailable() {
    return this.markerInstance ? true : (te.error("Marker instance is not available"), false);
  }
};
var ot = 63710088e-1;
var Fd = {
  centimeters: ot * 100,
  centimetres: ot * 100,
  degrees: 360 / (2 * Math.PI),
  feet: ot * 3.28084,
  inches: ot * 39.37,
  kilometers: ot / 1e3,
  kilometres: ot / 1e3,
  meters: ot,
  metres: ot,
  miles: ot / 1609.344,
  millimeters: ot * 1e3,
  millimetres: ot * 1e3,
  nauticalmiles: ot / 1852,
  radians: 1,
  yards: ot * 1.0936
};
function Mn(t, e, r = {}) {
  const s = { type: "Feature" };
  return (r.id === 0 || r.id) && (s.id = r.id), r.bbox && (s.bbox = r.bbox), s.properties = e || {}, s.geometry = t, s;
}
function En(t, e, r = {}) {
  if (!t)
    throw new Error("coordinates is required");
  if (!Array.isArray(t))
    throw new Error("coordinates must be an Array");
  if (t.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!ro(t[0]) || !ro(t[1]))
    throw new Error("coordinates must contain numbers");
  return Mn({
    type: "Point",
    coordinates: t
  }, e, r);
}
function fr(t, e, r = {}) {
  for (const u of t) {
    if (u.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (u[u.length - 1].length !== u[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let l = 0; l < u[u.length - 1].length; l++)
      if (u[u.length - 1][l] !== u[0][l])
        throw new Error("First and last Position are not equivalent.");
  }
  return Mn({
    type: "Polygon",
    coordinates: t
  }, e, r);
}
function Nr(t, e, r = {}) {
  if (t.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  return Mn({
    type: "LineString",
    coordinates: t
  }, e, r);
}
function nt(t, e = {}) {
  const r = { type: "FeatureCollection" };
  return e.id && (r.id = e.id), e.bbox && (r.bbox = e.bbox), r.features = t, r;
}
function pk(t, e, r = {}) {
  return Mn({
    type: "MultiLineString",
    coordinates: t
  }, e, r);
}
function Bl(t, e, r = {}) {
  return Mn({
    type: "MultiPolygon",
    coordinates: t
  }, e, r);
}
function Ul(t, e = "kilometers") {
  const r = Fd[e];
  if (!r)
    throw new Error(e + " units is invalid");
  return t * r;
}
function zl(t, e = "kilometers") {
  const r = Fd[e];
  if (!r)
    throw new Error(e + " units is invalid");
  return t / r;
}
function ri(t) {
  return t % (2 * Math.PI) * 180 / Math.PI;
}
function lt(t) {
  return t % 360 * Math.PI / 180;
}
function Gd(t, e = "kilometers", r = "kilometers") {
  if (!(t >= 0))
    throw new Error("length must be a positive number");
  return Ul(zl(t, e), r);
}
function ro(t) {
  return !isNaN(t) && t !== null && !Array.isArray(t);
}
function Lo(t) {
  return t !== null && typeof t == "object" && !Array.isArray(t);
}
function Or(t, e, r) {
  if (t !== null)
    for (var s, u, l, f, h, p, d, v = 0, _ = 0, E, S = t.type, I = S === "FeatureCollection", D = S === "Feature", O = I ? t.features.length : 1, T = 0; T < O; T++) {
      d = I ? t.features[T].geometry : D ? t.geometry : t, E = d ? d.type === "GeometryCollection" : false, h = E ? d.geometries.length : 1;
      for (var M = 0; M < h; M++) {
        var J = 0, X = 0;
        if (f = E ? d.geometries[M] : d, f !== null) {
          p = f.coordinates;
          var $ = f.type;
          switch (v = r && ($ === "Polygon" || $ === "MultiPolygon") ? 1 : 0, $) {
            case null:
              break;
            case "Point":
              if (e(
                p,
                _,
                T,
                J,
                X
              ) === false)
                return false;
              _++, J++;
              break;
            case "LineString":
            case "MultiPoint":
              for (s = 0; s < p.length; s++) {
                if (e(
                  p[s],
                  _,
                  T,
                  J,
                  X
                ) === false)
                  return false;
                _++, $ === "MultiPoint" && J++;
              }
              $ === "LineString" && J++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (s = 0; s < p.length; s++) {
                for (u = 0; u < p[s].length - v; u++) {
                  if (e(
                    p[s][u],
                    _,
                    T,
                    J,
                    X
                  ) === false)
                    return false;
                  _++;
                }
                $ === "MultiLineString" && J++, $ === "Polygon" && X++;
              }
              $ === "Polygon" && J++;
              break;
            case "MultiPolygon":
              for (s = 0; s < p.length; s++) {
                for (X = 0, u = 0; u < p[s].length; u++) {
                  for (l = 0; l < p[s][u].length - v; l++) {
                    if (e(
                      p[s][u][l],
                      _,
                      T,
                      J,
                      X
                    ) === false)
                      return false;
                    _++;
                  }
                  X++;
                }
                J++;
              }
              break;
            case "GeometryCollection":
              for (s = 0; s < f.geometries.length; s++)
                if (Or(f.geometries[s], e, r) === false)
                  return false;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function Xn(t, e) {
  if (t.type === "Feature")
    e(t, 0);
  else if (t.type === "FeatureCollection")
    for (var r = 0; r < t.features.length && e(t.features[r], r) !== false; r++)
      ;
}
function mk(t, e, r) {
  var s = r;
  return Xn(t, function(u, l) {
    l === 0 && r === void 0 ? s = u : s = e(s, u, l);
  }), s;
}
function Rr(t, e) {
  var r, s, u, l, f, h, p, d, v, _, E = 0, S = t.type === "FeatureCollection", I = t.type === "Feature", D = S ? t.features.length : 1;
  for (r = 0; r < D; r++) {
    for (h = S ? t.features[r].geometry : I ? t.geometry : t, d = S ? t.features[r].properties : I ? t.properties : {}, v = S ? t.features[r].bbox : I ? t.bbox : void 0, _ = S ? t.features[r].id : I ? t.id : void 0, p = h ? h.type === "GeometryCollection" : false, f = p ? h.geometries.length : 1, u = 0; u < f; u++) {
      if (l = p ? h.geometries[u] : h, l === null) {
        if (e(
          null,
          E,
          d,
          v,
          _
        ) === false)
          return false;
        continue;
      }
      switch (l.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (e(
            l,
            E,
            d,
            v,
            _
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (s = 0; s < l.geometries.length; s++)
            if (e(
              l.geometries[s],
              E,
              d,
              v,
              _
            ) === false)
              return false;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    E++;
  }
}
function vk(t, e, r) {
  var s = r;
  return Rr(
    t,
    function(u, l, f, h, p) {
      s = e(
        s,
        u,
        l,
        f,
        h,
        p
      );
    }
  ), s;
}
function Pr(t, e) {
  Rr(t, function(r, s, u, l, f) {
    var h = r === null ? null : r.type;
    switch (h) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return e(
          Mn(r, u, { bbox: l, id: f }),
          s,
          0
        ) === false ? false : void 0;
    }
    var p;
    switch (h) {
      case "MultiPoint":
        p = "Point";
        break;
      case "MultiLineString":
        p = "LineString";
        break;
      case "MultiPolygon":
        p = "Polygon";
        break;
    }
    for (var d = 0; d < r.coordinates.length; d++) {
      var v = r.coordinates[d], _ = {
        type: p,
        coordinates: v
      };
      if (e(Mn(_, u), s, d) === false)
        return false;
    }
  });
}
function ir(t, e = {}) {
  if (t.bbox != null && e.recompute !== true)
    return t.bbox;
  const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return Or(t, (s) => {
    r[0] > s[0] && (r[0] = s[0]), r[1] > s[1] && (r[1] = s[1]), r[2] < s[0] && (r[2] = s[0]), r[3] < s[1] && (r[3] = s[1]);
  }), r;
}
var Bd = ir;
function tt(t) {
  if (!t)
    throw new Error("coord is required");
  if (!Array.isArray(t)) {
    if (t.type === "Feature" && t.geometry !== null && t.geometry.type === "Point")
      return [...t.geometry.coordinates];
    if (t.type === "Point")
      return [...t.coordinates];
  }
  if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1]))
    return [...t];
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function Ht(t) {
  if (Array.isArray(t))
    return t;
  if (t.type === "Feature") {
    if (t.geometry !== null)
      return t.geometry.coordinates;
  } else if (t.coordinates)
    return t.coordinates;
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function sa(t) {
  return t.type === "Feature" ? t.geometry : t;
}
function $h(t, e) {
  return t.type === "FeatureCollection" ? "FeatureCollection" : t.type === "GeometryCollection" ? "GeometryCollection" : t.type === "Feature" && t.geometry !== null ? t.geometry.type : t.type;
}
function Ud(t, e, r, s = {}) {
  const u = tt(t), l = lt(u[0]), f = lt(u[1]), h = lt(r), p = zl(e, s.units), d = Math.asin(
    Math.sin(f) * Math.cos(p) + Math.cos(f) * Math.sin(p) * Math.cos(h)
  ), v = l + Math.atan2(
    Math.sin(h) * Math.sin(p) * Math.cos(f),
    Math.cos(p) - Math.sin(f) * Math.sin(d)
  ), _ = ri(v), E = ri(d);
  return u[2] !== void 0 ? En([_, E, u[2]], s.properties) : En([_, E], s.properties);
}
function yk(t, e, r = {}) {
  const s = r.steps || 64, u = r.properties ? r.properties : !Array.isArray(t) && t.type === "Feature" && t.properties ? t.properties : {}, l = [];
  for (let f = 0; f < s; f++)
    l.push(
      Ud(t, e, f * -360 / s, r).geometry.coordinates
    );
  return l.push(l[0]), fr([l], u);
}
var _k = yk;
function zd(t, e = {}) {
  let r = 0, s = 0, u = 0;
  return Or(
    t,
    function(l) {
      r += l[0], s += l[1], u++;
    },
    true
  ), En([r / u, s / u], e.properties);
}
var Xu = zd;
function Ek(t, e, r = {}) {
  let s;
  return r.final ? s = Vh(tt(e), tt(t)) : s = Vh(tt(t), tt(e)), s > 180 ? -(360 - s) : s;
}
function Vh(t, e) {
  const r = lt(t[1]), s = lt(e[1]);
  let u = lt(e[0] - t[0]);
  u > Math.PI && (u -= 2 * Math.PI), u < -Math.PI && (u += 2 * Math.PI);
  const l = Math.log(
    Math.tan(s / 2 + Math.PI / 4) / Math.tan(r / 2 + Math.PI / 4)
  ), f = Math.atan2(u, l);
  return (ri(f) + 360) % 360;
}
function xk(t, e, r = {}) {
  const s = tt(t), u = tt(e);
  u[0] += u[0] - s[0] > 180 ? -360 : s[0] - u[0] > 180 ? 360 : 0;
  const l = wk(s, u);
  return Gd(l, "meters", r.units);
}
function wk(t, e, r) {
  r = r === void 0 ? ot : Number(r);
  const s = r, u = t[1] * Math.PI / 180, l = e[1] * Math.PI / 180, f = l - u;
  let h = Math.abs(e[0] - t[0]) * Math.PI / 180;
  h > Math.PI && (h -= 2 * Math.PI);
  const p = Math.log(
    Math.tan(l / 2 + Math.PI / 4) / Math.tan(u / 2 + Math.PI / 4)
  ), d = Math.abs(p) > 1e-11 ? f / p : Math.cos(u);
  return Math.sqrt(
    f * f + d * d * h * h
  ) * s;
}
function kk(t, e, r, s = {}) {
  const u = e < 0;
  let l = Gd(
    Math.abs(e),
    s.units,
    "meters"
  );
  u && (l = -Math.abs(l));
  const f = tt(t), h = Sk(
    f,
    l,
    r
  );
  return h[0] += h[0] - f[0] > 180 ? -360 : f[0] - h[0] > 180 ? 360 : 0, En(h, s.properties);
}
function Sk(t, e, r, s) {
  s = s === void 0 ? ot : Number(s);
  const u = e / s, l = t[0] * Math.PI / 180, f = lt(t[1]), h = lt(r), p = u * Math.cos(h);
  let d = f + p;
  Math.abs(d) > Math.PI / 2 && (d = d > 0 ? Math.PI - d : -Math.PI - d);
  const v = Math.log(
    Math.tan(d / 2 + Math.PI / 4) / Math.tan(f / 2 + Math.PI / 4)
  ), _ = Math.abs(v) > 1e-11 ? p / v : Math.cos(f), E = u * Math.sin(h) / _;
  return [
    ((l + E) * 180 / Math.PI + 540) % 360 - 180,
    d * 180 / Math.PI
  ];
}
function To(t) {
  if (!t)
    throw new Error("geojson is required");
  switch (t.type) {
    case "Feature":
      return qd(t);
    case "FeatureCollection":
      return Mk(t);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return ql(t);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function qd(t) {
  const e = { type: "Feature" };
  return Object.keys(t).forEach((r) => {
    switch (r) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        e[r] = t[r];
    }
  }), e.properties = Yd(t.properties), t.geometry == null ? e.geometry = null : e.geometry = ql(t.geometry), e;
}
function Yd(t) {
  const e = {};
  return t && Object.keys(t).forEach((r) => {
    const s = t[r];
    typeof s == "object" ? s === null ? e[r] = null : Array.isArray(s) ? e[r] = s.map((u) => u) : e[r] = Yd(s) : e[r] = s;
  }), e;
}
function Mk(t) {
  const e = { type: "FeatureCollection" };
  return Object.keys(t).forEach((r) => {
    switch (r) {
      case "type":
      case "features":
        return;
      default:
        e[r] = t[r];
    }
  }), e.features = t.features.map((r) => qd(r)), e;
}
function ql(t) {
  const e = { type: t.type };
  return t.bbox && (e.bbox = t.bbox), t.type === "GeometryCollection" ? (e.geometries = t.geometries.map((r) => ql(r)), e) : (e.coordinates = Hd(t.coordinates), e);
}
function Hd(t) {
  const e = t;
  return typeof e[0] != "object" ? e.slice() : e.map((r) => Hd(r));
}
var Ik = To;
function Jd(t, e, r) {
  if (r = r || {}, !Lo(r)) throw new Error("options is invalid");
  const s = r.pivot, u = r.mutate;
  if (!t) throw new Error("geojson is required");
  if (e == null || isNaN(e))
    throw new Error("angle is required");
  if (e === 0) return t;
  const l = s ?? zd(t);
  return (u === false || u === void 0) && (t = To(t)), Or(t, function(f) {
    const p = Ek(l, f) + e, d = xk(l, f), v = Ht(
      kk(l, d, p)
    );
    f[0] = v[0], f[1] = v[1];
  }), t;
}
var bk = Jd;
function Xh(t, e, r, s) {
  s = s || {};
  let u = s.steps || 64;
  const l = s.units || "kilometers";
  let f = s.angle || 0;
  const h = s.pivot || t, p = s.properties || {};
  if (!t) throw new Error("center is required");
  if (!e) throw new Error("xSemiAxis is required");
  if (!r) throw new Error("ySemiAxis is required");
  if (!Lo(s)) throw new Error("options must be an object");
  if (!ro(u)) throw new Error("steps must be a number");
  if (!ro(f)) throw new Error("angle must be a number");
  const d = tt(Jd(En(tt(t)), f, { pivot: h }));
  f = -90 + f, u = Math.ceil(u / 4);
  const v = [], _ = [], E = e, S = r, I = S, D = (E - S) / (Math.PI / 2), O = (E + S) * Math.PI / 4, T = 0.5, M = u;
  let J = 0, X = 0;
  for (let Y = 0; Y < u; Y++)
    X += J, D === 0 ? J = O / M / I : J = (-(D * X + I) + Math.sqrt(Math.pow(D * X + I, 2) - 4 * (T * D) * -(O / M))) / (2 * (T * D)), X != 0 && v.push(X);
  _.push(0);
  for (let Y = 0; Y < v.length; Y++)
    _.push(v[Y]);
  _.push(Math.PI / 2);
  for (let Y = 0; Y < v.length; Y++)
    _.push(Math.PI - v[v.length - Y - 1]);
  _.push(Math.PI);
  for (let Y = 0; Y < v.length; Y++)
    _.push(Math.PI + v[Y]);
  _.push(3 * Math.PI / 2);
  for (let Y = 0; Y < v.length; Y++)
    _.push(2 * Math.PI - v[v.length - Y - 1]);
  _.push(0);
  const $ = [];
  for (const Y of _) {
    const j = Math.atan2(S * Math.sin(Y), E * Math.cos(Y)), x = Math.sqrt(
      Math.pow(E, 2) * Math.pow(S, 2) / (Math.pow(E * Math.sin(j), 2) + Math.pow(S * Math.cos(j), 2))
    );
    $.push(
      Ud(d, x, f + ri(j), {
        units: l
      }).geometry.coordinates
    );
  }
  return fr([$], p);
}
function $d(t, e, r = {}) {
  if (r.final === true)
    return Ak(t, e);
  const s = tt(t), u = tt(e), l = lt(s[0]), f = lt(u[0]), h = lt(s[1]), p = lt(u[1]), d = Math.sin(f - l) * Math.cos(p), v = Math.cos(h) * Math.sin(p) - Math.sin(h) * Math.cos(p) * Math.cos(f - l);
  return ri(Math.atan2(d, v));
}
function Ak(t, e) {
  let r = $d(e, t);
  return r = (r + 180) % 360, r;
}
var io = $d;
function Zr(t, e, r = {}) {
  var s = tt(t), u = tt(e), l = lt(u[1] - s[1]), f = lt(u[0] - s[0]), h = lt(s[1]), p = lt(u[1]), d = Math.pow(Math.sin(l / 2), 2) + Math.pow(Math.sin(f / 2), 2) * Math.cos(h) * Math.cos(p);
  return Ul(
    2 * Math.atan2(Math.sqrt(d), Math.sqrt(1 - d)),
    r.units
  );
}
var Vd = Zr;
function Wu(t, e = {}) {
  const r = sa(t);
  switch (!e.properties && t.type === "Feature" && (e.properties = t.properties), r.type) {
    case "Polygon":
      return Xd(r, e);
    case "MultiPolygon":
      return Wd(r, e);
    default:
      throw new Error("invalid poly");
  }
}
function Xd(t, e = {}) {
  const s = sa(t).coordinates, u = e.properties ? e.properties : t.type === "Feature" ? t.properties : {};
  return jd(s, u);
}
function Wd(t, e = {}) {
  const s = sa(t).coordinates, u = e.properties ? e.properties : t.type === "Feature" ? t.properties : {}, l = [];
  return s.forEach((f) => {
    l.push(jd(f, u));
  }), nt(l);
}
function jd(t, e) {
  return t.length > 1 ? pk(t, e) : Nr(t[0], e);
}
var Wh = (t, e) => t[0] === e[0] && t[1] === e[1];
var Gs = (t) => t.type === "Feature" && t.geometry.type === "LineString";
var jh = (t) => t.type === "Feature" && t.geometry.type === "MultiLineString";
var Yl = (t) => t.type === "Feature" && t.geometry.type === "Polygon";
var Hl = (t) => t.type === "Feature" && t.geometry.type === "MultiPolygon";
var Zh = (t) => ({
  type: "FeatureCollection",
  features: t.geometry.coordinates.map((e) => ({
    type: "Feature",
    properties: t.properties,
    geometry: {
      type: "LineString",
      coordinates: e
    }
  }))
});
var lu = (t, e) => ({
  lng: e[0] - t[0],
  lat: e[1] - t[1]
});
var so = (t) => Array.isArray(t) && t.length >= 2 && t.length <= 3 && t.every((e) => typeof e == "number");
var aa = (t, e, r = false) => {
  let s = 0;
  const u = ["features", "geometries", "geometry", "coordinates"], l = (f, h, p = false) => {
    so(f) ? (e({ coordinate: f, path: h }, s), s += 1) : Array.isArray(f) ? f.forEach((d, v) => {
      p && r && v === f.length - 1 && so(d) || l(d, [...h, v], p);
    }) : typeof f == "object" && f !== null && et(f).forEach((d) => {
      const v = f[d];
      if (u.includes(d) && v) {
        const _ = "type" in f && f.type, E = _ === "Polygon" || _ === "MultiPolygon";
        l(v, [...h, d], E);
      }
    });
  };
  l(t, []);
};
var Lk = (t, e) => {
  let r = { coordinate: [0, 0], path: [] }, s = -1;
  try {
    aa(t, (u, l) => {
      if (e[0] === u.coordinate[0] && e[1] === u.coordinate[1])
        throw s = l, r = u, new Error("stop");
    });
  } catch {
    if (r)
      return {
        index: s,
        coordinate: r.coordinate,
        path: r.path
      };
  }
  return null;
};
var Jl = (t, e) => {
  let r = 0;
  const s = ["features", "geometries", "geometry", "coordinates"], u = (l, f, h, p) => {
    so(l) && so(f) ? (e(
      {
        start: { coordinate: [...l], path: h },
        end: { coordinate: [...f], path: p }
      },
      r
    ), r += 1) : Array.isArray(l) ? l.forEach((d, v) => {
      u(
        d,
        l[v + 1],
        [...h, v],
        [...h, v + 1]
      );
    }) : typeof l == "object" && l !== null && et(l).forEach((d) => {
      const v = l[d];
      s.includes(d) && v && u(v, void 0, [...h, d], []);
    });
  };
  u(t, void 0, [], []);
};
var Co = (t, e) => {
  let r = {
    absCoordIndex: -1,
    featureIndex: -1,
    multiFeatureIndex: -1,
    geometryIndex: -1
  };
  try {
    Or(
      t,
      (s, u, l, f, h) => {
        if (s[0] === e[0] && s[1] === e[1])
          throw r = { absCoordIndex: u, featureIndex: l, multiFeatureIndex: f, geometryIndex: h }, new Error("found");
      }
    );
  } catch {
  }
  return r;
};
var hI = (t, e, r = {}) => ({
  type: "Feature",
  properties: r,
  geometry: {
    type: "LineString",
    coordinates: [t, e]
  }
});
var Ti = (t, e) => {
  const [r, s] = t, [u, l] = e, f = Math.min(r, u), h = Math.min(s, l), p = Math.max(r, u), d = Math.max(s, l);
  return [f, h, p, d];
};
var ju = (t, e) => {
  const r = Ti(t, e), s = [r[0], r[1]], u = [r[2], r[3]], l = s[0], f = s[1], h = u[0], p = u[1];
  return {
    type: "Feature",
    properties: {
      shape: "rectangle"
    },
    geometry: {
      type: "Polygon",
      coordinates: [
        [
          [l, f],
          [h, f],
          [h, p],
          [l, p],
          [l, f]
        ]
      ]
    }
  };
};
var Zu = (t) => [t.geometry.coordinates[0], t.geometry.coordinates[1]];
var $l = (t) => {
  const e = Bd(t);
  return [
    [e[0], e[1]],
    // South-West (min-x, min-y)
    [e[2], e[3]]
    // North-East (max-x, max-y)
  ];
};
var Tk = (t) => [t[0][0], t[0][1], t[1][0], t[1][1]];
var Ck = (t, e) => {
  const [r, s, u, l] = t, [f, h] = e;
  return f >= r && f <= u && h >= s && h <= l;
};
var fI = (t, e) => {
  const r = Tk(t);
  return Ck(r, e);
};
var cu = (t) => {
  let e = 0;
  return Or(
    t,
    () => {
      e += 1;
    },
    true
  ), e;
};
var Nk = (t) => {
  const e = [];
  return Or(
    t,
    (r) => {
      e.push([r[0], r[1]]);
    },
    true
  ), e;
};
var Vl = (t) => {
  const e = Nk(t);
  return e.some((r) => !Wi(e[0], r));
};
var Zd = (t) => {
  let e = null;
  try {
    aa(t, (r) => {
      throw e = r.coordinate, new Error("found");
    });
  } catch {
    return e;
  }
  return null;
};
var qa = (t, e) => Math.sqrt((t[0] - e[0]) ** 2 + (t[1] - e[1]) ** 2);
var Pk = (t, e, r) => {
  const [s, u] = [t[0], t[1]], [l, f] = [e[0], e[1]], [h, p] = [r[0], r[1]], d = l - s, v = f - u, _ = h - s, E = p - u, S = _ * d + E * v, I = d * d + v * v;
  let D = S / I;
  return D = Math.max(0, Math.min(1, D)), [s + D * d, u + D * v];
};
var Ok = (t, e) => {
  const { absCoordIndex: r } = Co(t, e);
  return r !== -1 ? (t.geometry.coordinates.splice(r, 1), true) : false;
};
var Rk = (t, e) => {
  const r = Co(t, e);
  if (r.absCoordIndex !== -1) {
    const s = [r.geometryIndex], u = Ui(
      t.geometry.coordinates,
      s
    ), l = u.findIndex((f) => Wi(f, e));
    return u.length <= 4 ? (t.geometry.coordinates.splice(r.geometryIndex, 1), true) : (u.splice(l, 1), l === 0 && (u[u.length - 1] = [...u[0]]), true);
  }
  return false;
};
var Dk = (t, e) => {
  const r = Co(t, e);
  if (r.absCoordIndex !== -1) {
    const s = [
      r.multiFeatureIndex,
      r.geometryIndex
    ], u = Ui(
      t.geometry.coordinates,
      s
    ), l = u.findIndex((f) => Wi(f, e));
    if (u.length <= 4) {
      s.pop();
      const f = Ui(
        t.geometry.coordinates,
        r.multiFeatureIndex
      );
      return f.splice(r.geometryIndex, 1), f.length === 0 && t.geometry.coordinates.splice(r.multiFeatureIndex, 1), true;
    }
    return u.splice(l, 1), l === 0 && (u[u.length - 1] = [...u[0]]), true;
  }
  return false;
};
var Fk = (t, e) => Gs(t) ? Ok(t, e) : Yl(t) ? Rk(t, e) : Hl(t) ? Dk(t, e) : false;
var gI = (t) => {
  let e = 0;
  return Jl(t, (r) => {
    e += Zr(r.start.coordinate, r.end.coordinate, {
      units: "meters"
    });
  }), e;
};
var dI = (t) => {
  const e = {
    type: "FeatureCollection",
    features: []
  };
  return t.features.forEach((r) => {
    if (Gs(r))
      e.features.push(r);
    else if (Yl(r)) {
      const s = Xd(r);
      Gs(s) ? e.features.push(s) : jh(s) && Zh(s).features.forEach((l) => {
        e.features.push(l);
      });
    } else Hl(r) ? Wd(r).features.forEach((u) => {
      Gs(u) ? e.features.push(u) : jh(u) && Zh(u).features.forEach((f) => {
        e.features.push(f);
      });
    }) : te.warn("AutoTraceHelper.getFeaturesGeoJsonAsLines: Feature is not supported", r);
  }), e;
};
var Gk = (t, e = "marker") => ({
  type: "Feature",
  properties: {
    shape: e
  },
  geometry: {
    type: "Point",
    coordinates: t
  }
});
var Xl = ({
  center: t,
  radius: e,
  steps: r = 80
}) => {
  const s = _k(t, e, {
    steps: r,
    units: "meters"
  });
  return s.geometry.coordinates[0][0] = [...s.geometry.coordinates[0][0]], s;
};
var Kh = ({
  center: t,
  xSemiAxisLngLat: e,
  rimLngLat: r
}) => {
  let s = Zr(t, e, { units: "meters" });
  s === 0 && (s = 1);
  const u = io(t, e) - 90;
  let l = 0;
  if (r) {
    const h = -u * Math.PI / 180, d = -(io(t, r) - 90) * Math.PI / 180, v = Zr(t, r, { units: "meters" }), _ = v * Math.cos(d), E = v * Math.sin(d), S = _ * Math.cos(h) + E * Math.sin(h), I = _ * -Math.sin(h) + E * Math.cos(h), D = S * S / (s * s);
    l = Math.abs(I) / Math.sqrt(1 - D), isNaN(l) && (l = 0);
  }
  return {
    xSemiAxis: s,
    ySemiAxis: l,
    angle: u
  };
};
var Kd = 80;
var No = ({
  center: t,
  xSemiAxis: e,
  ySemiAxis: r,
  angle: s,
  properties: u = {}
}) => {
  const l = {
    steps: Kd,
    angle: s,
    units: "meters"
  };
  if (r === void 0 || r === 0) {
    const h = Xh(t, e, 1, l);
    return Nr(h.geometry.coordinates[0].slice(0, 41), {
      shape: "line"
    });
  }
  const f = Xh(t, e, r, {
    ...l,
    properties: {
      ...u,
      [`${mt}shape`]: "ellipse",
      [`${mt}center`]: t,
      [`${mt}xSemiAxis`]: e,
      [`${mt}ySemiAxis`]: r,
      [`${mt}angle`]: s
    }
  });
  return f.geometry.coordinates[0][0] = [...f.geometry.coordinates[0][0]], f;
};
var Bk = [
  "circle",
  "ellipse",
  "rectangle"
];
var Bs = class _Bs {
  constructor(e) {
    __publicField(this, "gm");
    __publicField(this, "id", "no-id");
    __publicField(this, "parent", null);
    __publicField(this, "markers");
    __publicField(this, "source");
    __publicField(this, "_geoJson", null);
    this.gm = e.gm, this.id = e.id, this.source = e.source, this.parent = e.parent, this.markers = /* @__PURE__ */ new Map();
    const r = {
      ...e.geoJsonShapeFeature,
      properties: {
        ...this.parseExtraProperties(e.geoJsonShapeFeature),
        ...this.parseGmShapeProperties(e.geoJsonShapeFeature)
      }
    };
    if (e.skipSourceUpdate) {
      if (this._geoJson = {
        ...r,
        id: this.id
      }, this.shape === "circle") {
        const s = Zu(Xu(this._geoJson));
        this._geoJson.properties[`${mt}center`] = s;
      }
    } else
      this.addGeoJson(r);
  }
  get shape() {
    const e = this.getShapeProperty("shape");
    if (typeof e == "string" && Cr(e, Pd))
      return e;
    throw new Error(`Wrong shape type: "${e}"`);
  }
  set shape(e) {
    this.setShapeProperty("shape", e);
  }
  get temporary() {
    return this.source.id === K.temporary;
  }
  get sourceName() {
    return this.source.id;
  }
  getShapeProperty(e, r) {
    var _a6;
    const s = (r == null ? void 0 : r.properties) || ((_a6 = this._geoJson) == null ? void 0 : _a6.properties) || {}, u = uu[e], l = s[`${mt}${e}`] ?? s[e];
    if (u && u(l))
      return l;
  }
  setShapeProperty(e, r) {
    if (!this._geoJson) {
      te.error("FeatureData.setShapeProperty(): geojson is not set");
      return;
    }
    this._geoJson.properties[`${mt}${e}`] = r, this._updateAllProperties(this._geoJson.properties);
  }
  deleteShapeProperty(e) {
    if (!this._geoJson) {
      te.error("FeatureData.deleteShapeProperty(): geojson is not set");
      return;
    }
    delete this._geoJson.properties[`${mt}${e}`], this._updateAllProperties(this._geoJson.properties);
  }
  parseGmShapeProperties(e) {
    const r = this.getShapeProperty("shape", e) || this.gm.features.getFeatureShapeByGeoJson(e);
    r || te.error(`FeatureData.importGmShapeProperties(): unknown shape: ${r}`);
    const u = {
      ...Object.fromEntries(
        et(uu).map((l) => [l, this.getShapeProperty(l, e)])
      ),
      id: this.id,
      shape: r || void 0
    };
    return Object.fromEntries(
      et(u).filter((l) => u[l] !== void 0).map((l) => [`${mt}${l}`, u[l]])
    );
  }
  parseExtraProperties(e) {
    const r = $t(e.properties) || {};
    return et(uu).forEach((s) => {
      delete r[s], delete r[`${mt}${s}`];
    }), r;
  }
  getGeoJson() {
    if (this._geoJson)
      return this._geoJson;
    throw new Error(`Missing GeoJSON for feature: "${this.shape}:${this.id}"`);
  }
  addGeoJson(e) {
    if (this._geoJson = {
      ...e,
      id: this.id
    }, this.shape === "circle") {
      const r = Zu(Xu(this._geoJson));
      this._geoJson.properties[`${mt}center`] = r;
    }
    this.gm.features.updateManager.updateSource({
      diff: { add: [this._geoJson] },
      sourceName: this.sourceName
    });
  }
  removeGeoJson() {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    this.gm.features.updateManager.updateSource({
      diff: { remove: [this.id] },
      sourceName: this.sourceName
    });
  }
  removeMarkers() {
    this.markers.forEach((e) => {
      e.instance instanceof Gl ? e.instance.remove() : this.gm.features.delete(e.instance);
    }), this.markers = /* @__PURE__ */ new Map();
  }
  /**
   * Updates the geometry of this feature.
   *
   * @param geometry - The new geometry for the feature
   *
   * @example
   * // Update a marker's position
   * feature.updateGeometry({ type: 'Point', coordinates: [10, 52] });
   *
   * // Update a polygon's coordinates
   * feature.updateGeometry({
   *   type: 'Polygon',
   *   coordinates: [[[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]]
   * });
   */
  updateGeometry(e) {
    const r = this.getGeoJson();
    if (!r)
      throw new Error(`Feature not found: "${this.id}"`);
    this._geoJson = { ...r, geometry: e };
    const s = {
      update: [this._geoJson]
    };
    this.gm.features.updateManager.updateSource({
      diff: s,
      sourceName: this.sourceName
    });
  }
  /**
   * @deprecated Use `updateGeometry()` instead.
   */
  updateGeoJsonGeometry(e) {
    this.updateGeometry(e);
  }
  /**
   * Updates custom properties on this feature. Properties are merged with existing ones.
   * Set a property value to `undefined` to delete it.
   *
   * Internal Geoman properties (prefixed with `gm_`) cannot be modified through this method
   * and will be preserved.
   *
   * @param properties - Object containing properties to update or delete (set to undefined)
   *
   * @example
   * // Add or update properties
   * feature.updateProperties({ color: 'red', size: 10 });
   *
   * // Delete a property
   * feature.updateProperties({ color: undefined });
   *
   * // Mix of updates and deletions
   * feature.updateProperties({ color: 'blue', oldProp: undefined });
   */
  updateProperties(e) {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    const r = this.parseGmShapeProperties(this._geoJson), s = new Set(Object.keys(r)), u = {};
    for (const [h, p] of Object.entries(this._geoJson.properties))
      h in e || (u[h] = p);
    for (const [h, p] of Object.entries(e))
      s.has(h) || p !== void 0 && (u[h] = p);
    Object.assign(u, r), this._geoJson.properties = u;
    const l = { ...u };
    for (const [h, p] of Object.entries(e))
      s.has(h) || p === void 0 && (l[h] = void 0);
    const f = { update: [{ ...this._geoJson, properties: l }] };
    this.gm.features.updateManager.updateSource({
      diff: f,
      sourceName: this.sourceName
    });
  }
  /**
   * Replaces all custom properties on this feature. Existing custom properties are removed
   * and replaced with the provided ones.
   *
   * Internal Geoman properties (prefixed with `gm_`) cannot be modified and will be preserved.
   *
   * @param properties - Object containing the new properties (replaces all existing custom properties)
   *
   * @example
   * // Replace all custom properties
   * feature.setProperties({ name: 'New Feature', category: 'poi' });
   */
  setProperties(e) {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    const r = this.parseGmShapeProperties(this._geoJson), s = {};
    for (const [l, f] of Object.entries(e))
      f !== void 0 && !(l in r) && (s[l] = f);
    this._geoJson.properties = {
      ...s,
      ...r
    };
    const u = { update: [this._geoJson] };
    this.gm.features.updateManager.updateSource({
      diff: u,
      sourceName: this.sourceName
    });
  }
  /**
   * Internal method to update all properties including Geoman system properties.
   * This should only be used by internal Geoman code (edit modes, draw modes, etc.).
   *
   * @internal
   * @param properties - Properties to merge with existing ones
   */
  _updateAllProperties(e) {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    this._geoJson.properties = { ...this._geoJson.properties, ...e };
    const r = { update: [this._geoJson] };
    this.gm.features.updateManager.updateSource({
      diff: r,
      sourceName: this.sourceName
    });
  }
  /**
   * @deprecated Use `updateProperties()` instead. Set property value to `undefined` to delete it.
   */
  updateGeoJsonProperties(e) {
    this._updateAllProperties(e);
  }
  /**
   * @deprecated Use `setProperties()` instead.
   */
  setGeoJsonCustomProperties(e) {
    this.setProperties(e || {});
  }
  /**
   * @deprecated Use `updateProperties()` instead.
   */
  updateGeoJsonCustomProperties(e) {
    this.updateProperties(e || {});
  }
  /**
   * @deprecated Use `updateProperties({ propName: undefined })` instead.
   */
  deleteGeoJsonCustomProperties(e) {
    const r = {};
    for (const s of e)
      r[s] = void 0;
    this.updateProperties(r);
  }
  convertToPolygon() {
    return this.isConvertableToPolygon() ? (this.shape = "polygon", this.deleteShapeProperty("center"), this.deleteShapeProperty("angle"), this.deleteShapeProperty("xSemiAxis"), this.deleteShapeProperty("ySemiAxis"), true) : false;
  }
  isConvertableToPolygon() {
    return Bk.includes(this.shape);
  }
  // changeSource({ sourceName, atomic }: { sourceName: FeatureSourceName; atomic: boolean }) {
  //   if (atomic) {
  //     this.gm.features.updateManager.withAtomicSourcesUpdate(() =>
  //       this.actualChangeSource({ sourceName, atomic }),
  //     );
  //   } else {
  //     this.actualChangeSource({ sourceName, atomic });
  //   }
  // }
  changeSource({ sourceName: e, atomic: r }) {
    if (this.source.id === e) {
      te.error(
        `FeatureData.changeSource: feature "${this.id}" already has the source "${e}"`
      );
      return;
    }
    const s = this.gm.features.sources[e];
    if (!s) {
      te.error(`FeatureData.changeSource: missing source "${e}"`);
      return;
    }
    const u = this.getGeoJson();
    if (!u) {
      te.error("FeatureData.changeSource: missing shape GeoJSON");
      return;
    }
    this.removeGeoJson(), this.source = s, this.addGeoJson(u), this.markers.forEach((l) => {
      l.instance instanceof _Bs && l.instance.changeSource({ sourceName: e, atomic: r });
    });
  }
  fireFeatureUpdatedEvent({ mode: e }) {
    const r = {
      name: `${se}:edit:feature_updated`,
      level: "system",
      actionType: "edit",
      action: "feature_updated",
      mode: e,
      sourceFeatures: [this],
      targetFeatures: [this],
      markerData: null
    };
    this.gm.events.fire(`${se}:edit`, r);
  }
  delete() {
    this.removeGeoJson(), this.removeMarkers();
  }
};
var Wl = (t) => Sn(t) && t.actionType === "helper";
var Uk = (t) => Sn(t) && t.name === `${se}:helper:geofencing_violation`;
var jl = class {
  constructor(e) {
    __publicField(this, "gm");
    __publicField(this, "options", {});
    __publicField(this, "settings", {});
    __publicField(this, "actions", {});
    __publicField(this, "flags", {
      featureCreateAllowed: true,
      featureUpdateAllowed: true,
      actionInProgress: false
    });
    __publicField(this, "internalEventHandlers", {
      [`${se}:helper`]: this.handleHelperEvent.bind(this)
    });
    this.gm = e;
  }
  get snappingHelper() {
    return this.gm.actionInstances.helper__snapping || null;
  }
  startAction() {
    this.gm.events.bus.attachEvents(this.internalEventHandlers), this.gm.events.bus.attachEvents(this.eventHandlers), this.onStartAction();
  }
  endAction() {
    this.onEndAction(), this.gm.events.bus.detachEvents(this.eventHandlers), this.gm.events.bus.detachEvents(this.internalEventHandlers);
  }
  getOptionValue(e) {
    const r = this.options[e];
    if (!r)
      throw new Error(`Option ${e} not found`);
    if (["toggle", "hidden"].includes(r.type))
      return r.value;
    if (r.type === "select")
      return r.value.value;
    throw new Error(`Unknown option type: ${JSON.stringify(r)}`);
  }
  getSettingValue(e) {
    if (e in this.settings)
      return this.settings[e];
  }
  applyOptionValue(e, r) {
    const s = this.options[e];
    if (!s) {
      te.error("Option not found", e, r);
      return;
    }
    if (s.type === "toggle" && typeof r == "boolean")
      s.value = r;
    else if (s.type === "select") {
      const u = s.choices.find((l) => l.value === r);
      u && (s.value = u);
    } else s.type === "hidden" ? s.value = r : te.error("Can't apply option value", e, r, s);
  }
  handleHelperEvent(e) {
    return Uk(e) ? this.handleGeofencingViolationEvent(e) : { next: true };
  }
  handleGeofencingViolationEvent(e) {
    return e.actionType === "draw" ? this.flags.featureCreateAllowed = false : e.actionType === "edit" && (this.flags.featureUpdateAllowed = false), { next: true };
  }
};
var Zl = (t) => Sn(t) && t.actionType === "draw";
var Qd = (t) => Sn(t) && (t.name === `${se}:draw:shape` || t.name === `${se}:draw:shape_with_data`);
var ep = (t) => Qd(t) && t.variant === "line_drawer";
var pI = (t) => Qd(t) && t.variant === "freehand_drawer";
var yr = class extends jl {
  constructor() {
    super(...arguments);
    __publicField(this, "actionType", "draw");
    __publicField(this, "shape", null);
    __publicField(this, "featureData", null);
  }
  saveFeature() {
    if (this.featureData) {
      const e = this.featureData.getGeoJson();
      this.removeTmpFeature(), this.gm.features.createFeature({
        sourceName: K.main,
        shapeGeoJson: e
      });
    } else
      te.error("BaseDraw.saveFeature: no featureData to save");
  }
  removeTmpFeature() {
    this.featureData && (this.featureData.temporary || te.error("Not a temporary feature to remove", this.featureData), this.gm.features.delete(this.featureData), this.featureData = null);
  }
  fireBeforeFeatureCreate({
    geoJsonFeatures: e,
    forceMode: r = void 0
  }) {
    this.flags.featureCreateAllowed = true;
    const s = {
      name: `${se}:feature:before_create`,
      level: "system",
      actionType: "draw",
      mode: r || this.mode,
      action: "before_create",
      geoJsonFeatures: e
    };
    this.gm.events.fire(`${se}:${this.actionType}`, s);
  }
  fireMarkerPointerStartEvent() {
    if (!this.gm.markerPointer.marker || !this.shape)
      return;
    const e = this.gm.markerPointer.marker, r = {
      name: `${se}:draw:shape_with_data`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.shape,
      action: "start",
      markerData: {
        type: "dom",
        instance: e,
        position: {
          coordinate: e.getLngLat(),
          path: [-1]
        }
      },
      featureData: this.featureData
    };
    this.gm.events.fire(`${se}:draw`, r);
  }
  fireMarkerPointerUpdateEvent() {
    if (!this.gm.markerPointer.marker || !this.shape)
      return;
    const e = this.gm.markerPointer.marker, r = {
      name: `${se}:draw:shape_with_data`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.shape,
      action: "update",
      markerData: {
        type: "dom",
        instance: e,
        position: {
          coordinate: e.getLngLat(),
          path: [-1]
        }
      },
      featureData: this.featureData
    };
    this.gm.events.fire(`${se}:draw`, r);
  }
  fireMarkerPointerFinishEvent() {
    if (!this.shape)
      return;
    const e = {
      name: `${se}:draw:shape`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.shape,
      action: "finish"
    };
    this.gm.events.fire(`${se}:draw`, e);
  }
  forwardLineDrawerEvent(e) {
    if (!ep(e) || !this.shape)
      return { next: true };
    if (e.action === "start" || e.action === "update") {
      const r = {
        name: `${se}:draw:shape_with_data`,
        level: "system",
        actionType: "draw",
        mode: this.shape,
        variant: null,
        action: e.action,
        featureData: e.featureData,
        markerData: e.markerData
      };
      this.gm.events.fire(`${se}:draw`, r);
    } else if (e.action === "finish" || e.action === "cancel") {
      const r = {
        name: `${se}:draw:shape`,
        level: "system",
        actionType: "draw",
        mode: this.shape,
        variant: null,
        action: e.action
      };
      this.gm.events.fire(`${se}:draw`, r);
    }
    return { next: true };
  }
  fireStartEvent(e, r = null) {
    if (!this.shape)
      return;
    const s = {
      name: `${se}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "start",
      featureData: e,
      markerData: r
    };
    this.gm.events.fire(`${se}:draw`, s);
  }
  fireUpdateEvent(e, r = null) {
    if (!this.shape)
      return;
    const s = {
      name: `${se}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "update",
      featureData: e,
      markerData: r
    };
    this.gm.events.fire(`${se}:draw`, s);
  }
  fireFinishEvent() {
    if (!this.shape)
      return;
    const e = {
      name: `${se}:draw:shape`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "finish"
    };
    this.gm.events.fire(`${se}:draw`, e);
  }
};
var Kl = class extends yr {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "circle");
    __publicField(this, "shape", "circle");
    __publicField(this, "eventHandlers", {
      mousemove: this.onMouseMove.bind(this),
      click: this.onMouseClick.bind(this)
    });
    __publicField(this, "circleCenterPoint", null);
    __publicField(this, "circleCenterLngLat", null);
  }
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    this.removeTmpFeature(), this.gm.markerPointer.disable(), this.fireFinishEvent();
  }
  getFeatureGeoJson(e) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "Point",
        coordinates: e
      }
    };
  }
  getControlMarkerData() {
    const e = this.gm.markerPointer.marker;
    return e ? {
      type: "dom",
      instance: e,
      position: {
        coordinate: e.getLngLat(),
        path: [-1]
      }
    } : null;
  }
  createFeature() {
    const e = this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(this.circleCenterLngLat || [0, 0]),
      sourceName: K.temporary
    });
    return e && this.circleCenterLngLat && e.setShapeProperty("center", this.circleCenterLngLat), e;
  }
  createMarker() {
    const e = document.createElement("div");
    e.innerHTML = jf;
    const r = e.firstChild;
    return r.style.color = "#278cda", r.style.width = "28px", r.style.height = "28px", r.style.pointerEvents = "none", this.gm.mapAdapter.createDomMarker(
      {
        draggable: false,
        anchor: "center",
        element: r
      },
      [0, 0]
    );
  }
};
var zk = class extends Kl {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "circle_marker");
    __publicField(this, "shape", "circle_marker");
  }
  onStartAction() {
    this.gm.markerPointer.enable({
      customMarker: this.createMarker()
    });
  }
  onEndAction() {
    this.fireMarkerPointerFinishEvent(), super.onEndAction();
  }
  onMouseMove() {
    return this.fireMarkerPointerUpdateEvent(), { next: true };
  }
  onMouseClick(e) {
    var _a6;
    const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e.lngLat.toArray();
    return this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(r)] }), this.flags.featureCreateAllowed && (this.featureData = this.createFeature(), this.circleCenterLngLat = r, this.circleCenterPoint = this.gm.mapAdapter.project(this.circleCenterLngLat), this.updateFeaturePosition(this.circleCenterLngLat), this.saveFeature()), { next: false };
  }
  updateFeaturePosition(e) {
    if (!this.featureData)
      return;
    const r = this.getFeatureGeoJson(e);
    this.featureData.updateGeoJsonGeometry(r.geometry);
  }
};
var qk = () => window.PointerEvent && "maxTouchPoints" in navigator ? navigator.maxTouchPoints > 0 ? !window.matchMedia("(hover: hover)").matches : false : matchMedia("(hover: none)").matches || "ontouchstart" in window ? true : "msMaxTouchPoints" in navigator && typeof navigator.msMaxTouchPoints == "number" && navigator.msMaxTouchPoints > 0;
var ci = (t, e, r = 10) => {
  const s = { ...t };
  return et(t).forEach((u) => {
    const l = t[u];
    typeof l == "function" ? s[u] = Ag(l.bind(e), r, {
      leading: true,
      trailing: false
    }) : te.error("convertToThrottled: item is not a function", t[u]);
  }), s;
};
var Yk = (t, e, r = 10) => {
  const s = { ...t };
  return et(t).forEach((u) => {
    const l = t[u];
    typeof l == "function" ? s[u] = Ig(l.bind(e), r, {
      leading: false,
      trailing: true
    }) : te.error("convertToDebounced: item is not a function", t[u]);
  }), s;
};
var Qh = async (t, e) => {
  const r = "Promise race timeout";
  await Promise.race([
    t,
    new Promise((s, u) => {
      setTimeout(
        () => u(
          new Error(
            `Timeout ${qc / 1e3} seconds: ${e || r}`
          )
        ),
        qc
      );
    })
  ]);
};
var tp = [
  "click",
  "dblclick",
  "mousedown",
  "mouseup",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "contextmenu",
  "touchstart",
  "touchend",
  "touchmove",
  "touchcancel"
];
var Hk = ["load"];
function mI(t) {
  return tp.includes(t);
}
function vI(t) {
  return Hk.includes(t);
}
var Jk = (t) => !!(t && typeof t == "object" && "once" in t && typeof t.once == "function");
var Ke = (t, e = { warning: false }) => {
  if (!t)
    return e.warning && te.warn("Empty event", t), false;
  const r = typeof t == "object" && "lngLat" in t && "point" in t && "type" in t && "originalEvent" in t && typeof t.type == "string" && tp.includes(t.type);
  return !r && e.warning && te.warn("Not a pointer event", t), r;
};
var $k = (t) => t.originalEvent.ctrlKey || t.originalEvent.shiftKey || t.originalEvent.altKey || t.originalEvent.metaKey;
var Vk = (t) => {
  const e = ["symbol", "fill", "line", "circle"];
  return !!t && typeof t == "object" && "type" in t && e.includes(t.type);
};
var Xk = class extends Kl {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "circle");
    __publicField(this, "shape", "circle");
    __publicField(this, "throttledMethods", ci(
      {
        updateFeatureGeoJson: this.updateFeatureGeoJson
      },
      this,
      this.gm.options.settings.throttlingDelay
    ));
  }
  onMouseClick(e) {
    var _a6;
    if (!Ke(e))
      return { next: true };
    const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e.lngLat.toArray();
    if (this.circleCenterPoint && this.circleCenterLngLat)
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [this.getCircleGeoJson(this.circleCenterLngLat, r)]
      }), this.flags.featureCreateAllowed && (this.saveCircleFeature(r), this.circleCenterLngLat = null, this.circleCenterPoint = null, this.fireFinishEvent());
    else if (this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(r)] }), this.flags.featureCreateAllowed) {
      this.circleCenterLngLat = r, this.circleCenterPoint = this.gm.mapAdapter.project(this.circleCenterLngLat), this.featureData = this.createFeature();
      const s = this.getControlMarkerData();
      this.featureData && s && this.fireStartEvent(this.featureData, s);
    }
    return { next: false };
  }
  onMouseMove() {
    if (this.circleCenterLngLat && this.gm.markerPointer.marker) {
      const e = this.gm.markerPointer.marker.getLngLat();
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [this.getCircleGeoJson(this.circleCenterLngLat, e)]
      }), this.flags.featureCreateAllowed && this.throttledMethods.updateFeatureGeoJson(e);
    }
    return this.circleCenterPoint || this.fireMarkerPointerUpdateEvent(), { next: false };
  }
  updateFeatureGeoJson(e) {
    if (this.featureData && this.circleCenterLngLat) {
      const r = this.getCircleGeoJson(this.circleCenterLngLat, e);
      this.featureData.updateGeoJsonGeometry(r.geometry);
      const s = this.getControlMarkerData();
      s && this.fireUpdateEvent(this.featureData, s);
    }
  }
  saveCircleFeature(e) {
    var _a6;
    if (this.circleCenterLngLat && this.featureData) {
      const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e;
      this.updateFeatureGeoJson(r), this.featureData.setShapeProperty("center", this.circleCenterLngLat), this.isFeatureGeoJsonValid() ? this.saveFeature() : this.removeTmpFeature();
    }
  }
  isFeatureGeoJsonValid() {
    return this.featureData ? Vl(this.featureData.getGeoJson()) : false;
  }
  getCircleGeoJson(e, r) {
    const s = this.gm.mapAdapter.getDistance(e, r);
    return {
      ...Xl({ center: e, radius: s }),
      properties: {
        shape: this.shape
      }
    };
  }
};
var Dr = class extends jl {
  constructor() {
    super(...arguments);
    __publicField(this, "actionType", "helper");
  }
};
var np = (t) => !!t && typeof t == "object" && t instanceof Dr && "removeSnapGuides" in t && "updateSnapGuides" in t && t.mode === "snap_guides" && typeof t.removeSnapGuides == "function" && typeof t.updateSnapGuides == "function";
var Wk = (t) => !!t && typeof t == "object" && t instanceof Dr && "getShortestPath" in t && t.mode === "auto_trace" && typeof t.getShortestPath == "function";
var jk = (t) => !!t && typeof t == "object" && t instanceof Dr && "getSharedMarkers" in t && t.mode === "pin" && typeof t.getSharedMarkers == "function";
function Zk(t, e = {}) {
  var r, s, u, l = e.properties, f = (r = e.autoComplete) != null ? r : true, h = (s = e.orderCoords) != null ? s : true, p = (u = e.mutate) != null ? u : false;
  switch (p || (t = To(t)), t.type) {
    case "FeatureCollection":
      var d = [];
      return t.features.forEach(function(v) {
        d.push(
          Ht(ef(v, {}, f, h))
        );
      }), Bl(d, l);
    default:
      return ef(t, l, f, h);
  }
}
function ef(t, e, r, s) {
  e = e || (t.type === "Feature" ? t.properties : {});
  var u = sa(t), l = u.coordinates, f = u.type;
  if (!l.length) throw new Error("line must contain coordinates");
  switch (f) {
    case "LineString":
      return r && (l = tf(l)), fr([l], e);
    case "MultiLineString":
      var h = [], p = 0;
      return l.forEach(function(d) {
        if (r && (d = tf(d)), s) {
          var v = Kk(ir(Nr(d)));
          v > p ? (h.unshift(d), p = v) : h.push(d);
        } else
          h.push(d);
      }), fr(h, e);
    default:
      throw new Error("geometry type " + f + " is not supported");
  }
}
function tf(t) {
  var e = t[0], r = e[0], s = e[1], u = t[t.length - 1], l = u[0], f = u[1];
  return (r !== l || s !== f) && t.push(e), t;
}
function Kk(t) {
  var e = t[0], r = t[1], s = t[2], u = t[3];
  return Math.abs(e - s) * Math.abs(r - u);
}
var Ql = Zk;
var ec = class extends yr {
  constructor(e, r = {
    snappingMarkers: "none",
    targetShape: "line"
  }) {
    super(e);
    __publicField(this, "mode", "line");
    __publicField(this, "snappingKey", "line_drawer");
    __publicField(this, "drawOptions");
    __publicField(this, "shapeLngLats", []);
    __publicField(this, "throttledMethods", ci(
      {
        onMouseMove: this.onMouseMove
      },
      this,
      this.gm.options.settings.throttlingDelay
    ));
    __publicField(this, "eventHandlers", {
      [`${se}:helper`]: this.handleGmHelperEvent.bind(this),
      click: this.onMouseClick.bind(this),
      mousemove: this.throttledMethods.onMouseMove.bind(this)
    });
    __publicField(this, "drawerEventHandlers", {
      firstMarkerClick: null,
      lastMarkerClick: null,
      nMarkerClick: null
    });
    this.drawOptions = r;
  }
  get snapGuidesInstance() {
    const e = this.gm.actionInstances.helper__snap_guides;
    return np(e) ? e : null;
  }
  get autoTraceEnabled() {
    var _a6;
    return ((_a6 = this.gm.options.controls.helper.auto_trace) == null ? void 0 : _a6.active) || false;
  }
  get autoTraceHelperInstance() {
    return this.autoTraceEnabled && Object.values(this.gm.actionInstances).find(Wk) || null;
  }
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    var _a6;
    this.gm.markerPointer.disable(), this.endShape(), (_a6 = this.snapGuidesInstance) == null ? void 0 : _a6.removeSnapGuides(), this.clearDrawerHandlers();
  }
  clearDrawerHandlers() {
    this.drawerEventHandlers.firstMarkerClick = null, this.drawerEventHandlers.lastMarkerClick = null, this.drawerEventHandlers.nMarkerClick = null;
  }
  handleGmHelperEvent(e) {
    return Wl(e) ? (e.mode === "snap_guides" && e.action === "mode_start" && this.updateSnapGuides(), { next: true }) : (te.error("LineDrawer.handleGmHelperEvent: invalid event", e), { next: true });
  }
  updateSnapGuides() {
    var _a6;
    if (this.snapGuidesInstance) {
      const e = (_a6 = this.featureData) == null ? void 0 : _a6.getGeoJson();
      e && e.geometry.coordinates.pop(), this.snapGuidesInstance.updateSnapGuides(
        e || null,
        this.shapeLngLats.at(-1) || null,
        true
      );
    }
  }
  on(e, r) {
    this.drawerEventHandlers[e] = r;
  }
  onMouseClick(e) {
    var _a6;
    if (!Ke(e, { warning: true }))
      return { next: true };
    const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e.lngLat.toArray();
    if (this.featureData) {
      const s = this.getClickedMarkerInfo(e);
      this.handleNextVertex(r, s);
    } else this.isFeatureAllowed(Gk(r)) && this.startShape(r);
    return this.updateSnapGuides(), { next: true };
  }
  handleNextVertex(e, r) {
    var _a6, _b2, _c2, _d3, _e5, _f3;
    if (!this.featureData) {
      te.error("LineDrawer.handleNextVertex: no featureData");
      return;
    }
    const s = this.featureData.markers.size, u = this.getMarkerClickEventData(r.index);
    r.index < s - 1 && this.addPoint(e, r), r.index !== -1 && (r.index === 0 ? (_b2 = (_a6 = this.drawerEventHandlers).firstMarkerClick) == null ? void 0 : _b2.call(_a6, u) : r.index > 0 && r.index === s - 1 && ((_d3 = (_c2 = this.drawerEventHandlers).lastMarkerClick) == null ? void 0 : _d3.call(_c2, u)), r.index >= 0 && ((_f3 = (_e5 = this.drawerEventHandlers).nMarkerClick) == null ? void 0 : _f3.call(_e5, u)));
  }
  getMarkerClickEventData(e) {
    const r = this.getFeatureGeoJson({ withControlMarker: false });
    return {
      markerIndex: e,
      shapeCoordinates: this.getShapeCoordinates({ withControlMarker: false }),
      geoJson: r,
      bounds: $l(r)
    };
  }
  onMouseMove(e) {
    return Ke(e, { warning: true }) ? (this.featureData && this.shapeLngLats.length && this.updateFeatureSource(), { next: true }) : { next: true };
  }
  startShape(e) {
    this.shapeLngLats = [e], this.featureData = this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson({ withControlMarker: true }),
      sourceName: K.temporary
    });
    const r = {
      type: "dom",
      instance: this.createMarker(e),
      position: {
        coordinate: e,
        path: ["geometry", "coordinates", 0]
      }
    };
    this.featureData && (this.featureData.markers.set(r.position.path.join("."), r), this.setSnapping(), this.fireStartEvent(this.featureData, r)), this.gm.mapAdapter.disableMapInteractions(["doubleClickZoom"]);
  }
  endShape() {
    const e = this.getFeatureGeoJson({ withControlMarker: false });
    this.removeSnapping(), this.removeTmpFeature(), this.shapeLngLats = [], this.gm.mapAdapter.enableMapInteractions(["doubleClickZoom"]), this.fireStopEvent(e);
  }
  setSnapping() {
    if (!this.snappingHelper)
      return;
    const e = this.drawOptions.snappingMarkers;
    e === "none" ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, []) : e === "all" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, this.shapeLngLats) : e === "first" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, [this.shapeLngLats[0]]) : e === "last" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, [
      this.shapeLngLats[this.shapeLngLats.length - 1]
    ]) : te.error("LineDrawer.setSnapping: invalid data", e, this.shapeLngLats);
  }
  removeSnapping() {
    this.snappingHelper && this.snappingHelper.clearCustomSnappingCoordinates(this.snappingKey);
  }
  getClickedMarkerInfo(e) {
    if (!this.featureData)
      return { index: -1, path: null };
    let r = 0, s = null;
    try {
      this.featureData.markers.forEach((u, l) => {
        if (u.instance instanceof Gl) {
          const f = u.instance.getElement() || null, h = e.originalEvent.target, p = h instanceof Element ? h : null;
          if (f && f.contains(p))
            throw s = l, new Error("stop");
        }
        r += 1;
      });
    } catch {
      if (s)
        return { index: r, path: s };
    }
    return { index: -1, path: null };
  }
  addPoint(e, r) {
    const s = this.featureData;
    if (!s) {
      te.error("LineDrawer.addPoint: no featureData");
      return;
    }
    const u = this.getAddedLngLats(e, r), l = this.getFeatureGeoJsonWithType({
      withControlMarker: true,
      coordinates: this.shapeLngLats.concat(u)
    });
    this.isFeatureAllowed(l) && (u.forEach((f) => {
      this.shapeLngLats.push(f);
      const h = this.addMarker(f, s);
      this.fireUpdateEvent(s, h);
    }), this.updateFeatureSource());
  }
  isFeatureAllowed(e) {
    return this.gm.getActiveDrawModes().length ? (this.fireBeforeFeatureCreate({ geoJsonFeatures: [e] }), this.flags.featureCreateAllowed) : true;
  }
  getAddedLngLats(e, r) {
    var _a6;
    if (!this.featureData)
      return te.error("LineDrawer.getCurrentLngLats: no featureData"), [];
    const u = this.getMarkerInfoLngLat(r) || e;
    return [...((_a6 = this.getAutoTracePath(u)) == null ? void 0 : _a6.slice(1, -1)) || [], u];
  }
  getAutoTracePath(e) {
    const r = this.shapeLngLats.at(-1);
    return this.autoTraceEnabled && this.autoTraceHelperInstance && r && this.autoTraceHelperInstance.getShortestPath(r, e) || null;
  }
  getMarkerInfoLngLat(e) {
    if (this.featureData && e.path) {
      const r = this.featureData.markers.get(e.path);
      if (r && r.type === "dom")
        return r.instance.getLngLat();
      te.error("LineDrawer.addPoint: no markerData", e);
    }
    return null;
  }
  addMarker(e, r) {
    const s = {
      type: "dom",
      instance: this.createMarker(e),
      position: {
        coordinate: e,
        path: ["geometry", "coordinates", this.shapeLngLats.length]
      }
    };
    return r.markers.set(s.position.path.join("."), {
      type: "dom",
      instance: s.instance,
      position: {
        coordinate: e,
        path: []
      }
    }), s;
  }
  createMarker(e) {
    return this.gm.mapAdapter.createDomMarker(
      {
        element: this.gm.createSvgMarkerElement("control", {
          pointerEvents: "auto",
          cursor: "pointer"
        }),
        anchor: "center"
      },
      e
    );
  }
  updateFeatureSource() {
    if (this.featureData && (this.featureData.updateGeoJsonGeometry(
      this.getFeatureGeoJson({ withControlMarker: true }).geometry
    ), this.gm.markerPointer.marker)) {
      const e = {
        type: "dom",
        instance: this.gm.markerPointer.marker,
        position: {
          coordinate: this.gm.markerPointer.marker.getLngLat(),
          path: ["geometry", "coordinates", this.shapeLngLats.length]
        }
      };
      this.fireUpdateEvent(this.featureData, e);
    }
  }
  getFeatureGeoJson({
    withControlMarker: e,
    coordinates: r = void 0
  }) {
    return {
      type: "Feature",
      properties: {
        shape: "line"
      },
      geometry: {
        type: "LineString",
        coordinates: r || this.getShapeCoordinates({ withControlMarker: e })
      }
    };
  }
  getFeatureGeoJsonWithType({
    withControlMarker: e,
    coordinates: r = void 0
  }) {
    const s = this.getFeatureGeoJson({ withControlMarker: e, coordinates: r });
    return this.drawOptions.targetShape === "polygon" && s.geometry.coordinates.length > 3 ? Ql(s, {
      properties: s.properties
    }) : s;
  }
  getShapeCoordinates({ withControlMarker: e }) {
    const r = [...this.shapeLngLats];
    return e && this.gm.markerPointer.marker && r.push(this.gm.markerPointer.marker.getLngLat()), r;
  }
  fireStartEvent(e, r) {
    const s = {
      name: `${se}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: "line",
      variant: "line_drawer",
      action: "start",
      featureData: e,
      markerData: r
    };
    this.gm.events.fire(`${se}:draw`, s);
  }
  fireUpdateEvent(e, r) {
    const s = {
      name: `${se}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: "line",
      variant: "line_drawer",
      action: "update",
      featureData: e,
      markerData: r
    };
    this.gm.events.fire(`${se}:draw`, s);
  }
  fireStopEvent(e) {
    const r = {
      name: `${se}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: "line",
      action: "finish",
      variant: "line_drawer",
      geoJsonFeature: e,
      markerData: null,
      featureData: null
    };
    this.gm.events.fire(`${se}:draw`, r);
  }
};
var Qk = class extends yr {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "line");
    __publicField(this, "shape", "line");
    __publicField(this, "lineDrawer", new ec(this.gm, { snappingMarkers: "first", targetShape: "line" }));
    __publicField(this, "eventHandlers", {
      [`${se}:draw`]: this.forwardLineDrawerEvent.bind(this),
      mousemove: this.onMouseMove.bind(this)
    });
  }
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on("nMarkerClick", this.lineFinished.bind(this));
  }
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onMouseMove(e) {
    return Ke(e) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: true }) : { next: true };
  }
  lineFinished(e) {
    this.lineDrawer.endShape();
    let r = e.shapeCoordinates;
    return e.markerIndex > 0 && (r = r.slice(0, e.markerIndex + 1)), r.length < 2 ? null : this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(r),
      sourceName: K.main
    });
  }
  getFeatureGeoJson(e) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "LineString",
        coordinates: e
      }
    };
  }
};
var e2 = class extends yr {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "marker");
    __publicField(this, "shape", "marker");
    __publicField(this, "eventHandlers", {
      click: this.onMouseClick.bind(this),
      mousemove: this.onMouseMove.bind(this)
    });
  }
  onStartAction() {
    const e = this.createMarker();
    this.gm.markerPointer.enable({ customMarker: e }), this.fireMarkerPointerStartEvent();
  }
  onEndAction() {
    this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent();
  }
  onMouseClick(e) {
    return Ke(e) && (this.featureData = this.createFeature(e), this.featureData && this.saveFeature()), { next: false };
  }
  onMouseMove(e) {
    return !Ke(e) || !this.gm.markerPointer.marker ? { next: true } : (this.fireMarkerPointerUpdateEvent(), { next: true });
  }
  createFeature(e) {
    var _a6;
    const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e.lngLat.toArray(), s = this.getFeatureGeoJson(r);
    return s && (this.fireBeforeFeatureCreate({ geoJsonFeatures: [s] }), this.flags.featureCreateAllowed) ? this.gm.features.createFeature({
      shapeGeoJson: s,
      sourceName: K.temporary
    }) : null;
  }
  getFeatureGeoJson(e) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "Point",
        coordinates: e
      }
    };
  }
  createMarker(e = K.temporary) {
    var _a6;
    const s = (_a6 = this.gm.options.layerStyles.marker[e]) == null ? void 0 : _a6.find((_) => _.type === "symbol"), u = (s == null ? void 0 : s.paint) && "icon-opacity" in s.paint ? s.paint["icon-opacity"] : void 0, l = (s == null ? void 0 : s.layout) && "icon-size" in s.layout ? s.layout["icon-size"] : void 0, f = 36, d = `${l !== void 0 ? Math.round(f * (l / 0.18)) : f}px`, v = this.gm.createSvgMarkerElement("default", {
      width: d,
      height: d,
      pointerEvents: "none",
      ...u !== void 0 && { opacity: String(u) }
    });
    return this.gm.mapAdapter.createDomMarker(
      {
        draggable: false,
        anchor: "bottom",
        element: v
      },
      [0, 0]
    );
  }
};
function t2(t) {
  var e = {
    MultiPoint: {
      coordinates: [],
      properties: []
    },
    MultiLineString: {
      coordinates: [],
      properties: []
    },
    MultiPolygon: {
      coordinates: [],
      properties: []
    }
  };
  return Xn(t, (r) => {
    var s;
    switch ((s = r.geometry) == null ? void 0 : s.type) {
      case "Point":
        e.MultiPoint.coordinates.push(r.geometry.coordinates), e.MultiPoint.properties.push(r.properties);
        break;
      case "MultiPoint":
        e.MultiPoint.coordinates.push(...r.geometry.coordinates), e.MultiPoint.properties.push(r.properties);
        break;
      case "LineString":
        e.MultiLineString.coordinates.push(r.geometry.coordinates), e.MultiLineString.properties.push(r.properties);
        break;
      case "MultiLineString":
        e.MultiLineString.coordinates.push(
          ...r.geometry.coordinates
        ), e.MultiLineString.properties.push(r.properties);
        break;
      case "Polygon":
        e.MultiPolygon.coordinates.push(r.geometry.coordinates), e.MultiPolygon.properties.push(r.properties);
        break;
      case "MultiPolygon":
        e.MultiPolygon.coordinates.push(...r.geometry.coordinates), e.MultiPolygon.properties.push(r.properties);
        break;
    }
  }), nt(
    Object.keys(e).filter(function(r) {
      return e[r].coordinates.length;
    }).sort().map(function(r) {
      var s = { type: r, coordinates: e[r].coordinates }, u = { collectedProperties: e[r].properties };
      return Mn(s, u);
    })
  );
}
var n2 = t2;
function r2(t, e, r, s, u) {
  rp(t, e, r || 0, s || t.length - 1, u || i2);
}
function rp(t, e, r, s, u) {
  for (; s > r; ) {
    if (s - r > 600) {
      var l = s - r + 1, f = e - r + 1, h = Math.log(l), p = 0.5 * Math.exp(2 * h / 3), d = 0.5 * Math.sqrt(h * p * (l - p) / l) * (f - l / 2 < 0 ? -1 : 1), v = Math.max(r, Math.floor(e - f * p / l + d)), _ = Math.min(s, Math.floor(e + (l - f) * p / l + d));
      rp(t, e, v, _, u);
    }
    var E = t[e], S = r, I = s;
    for (ys(t, r, e), u(t[s], E) > 0 && ys(t, r, s); S < I; ) {
      for (ys(t, S, I), S++, I--; u(t[S], E) < 0; ) S++;
      for (; u(t[I], E) > 0; ) I--;
    }
    u(t[r], E) === 0 ? ys(t, r, I) : (I++, ys(t, I, s)), I <= e && (r = I + 1), e <= I && (s = I - 1);
  }
}
function ys(t, e, r) {
  var s = t[e];
  t[e] = t[r], t[r] = s;
}
function i2(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
var tn = class {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let r = this.data;
    const s = [];
    if (!Ia(e, r)) return s;
    const u = this.toBBox, l = [];
    for (; r; ) {
      for (let f = 0; f < r.children.length; f++) {
        const h = r.children[f], p = r.leaf ? u(h) : h;
        Ia(e, p) && (r.leaf ? s.push(h) : fu(e, p) ? this._all(h, s) : l.push(h));
      }
      r = l.pop();
    }
    return s;
  }
  collides(e) {
    let r = this.data;
    if (!Ia(e, r)) return false;
    const s = [];
    for (; r; ) {
      for (let u = 0; u < r.children.length; u++) {
        const l = r.children[u], f = r.leaf ? this.toBBox(l) : l;
        if (Ia(e, f)) {
          if (r.leaf || fu(e, f)) return true;
          s.push(l);
        }
      }
      r = s.pop();
    }
    return false;
  }
  load(e) {
    if (!(e && e.length)) return this;
    if (e.length < this._minEntries) {
      for (let s = 0; s < e.length; s++)
        this.insert(e[s]);
      return this;
    }
    let r = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = r;
    else if (this.data.height === r.height)
      this._splitRoot(this.data, r);
    else {
      if (this.data.height < r.height) {
        const s = this.data;
        this.data = r, r = s;
      }
      this._insert(r, this.data.height - r.height - 1, true);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = Ci([]), this;
  }
  remove(e, r) {
    if (!e) return this;
    let s = this.data;
    const u = this.toBBox(e), l = [], f = [];
    let h, p, d;
    for (; s || l.length; ) {
      if (s || (s = l.pop(), p = l[l.length - 1], h = f.pop(), d = true), s.leaf) {
        const v = s2(e, s.children, r);
        if (v !== -1)
          return s.children.splice(v, 1), l.push(s), this._condense(l), this;
      }
      !d && !s.leaf && fu(s, u) ? (l.push(s), f.push(h), h = 0, p = s, s = s.children[0]) : p ? (h++, s = p.children[h], d = false) : s = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, r) {
    return e.minX - r.minX;
  }
  compareMinY(e, r) {
    return e.minY - r.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, r) {
    const s = [];
    for (; e; )
      e.leaf ? r.push(...e.children) : s.push(...e.children), e = s.pop();
    return r;
  }
  _build(e, r, s, u) {
    const l = s - r + 1;
    let f = this._maxEntries, h;
    if (l <= f)
      return h = Ci(e.slice(r, s + 1)), Ai(h, this.toBBox), h;
    u || (u = Math.ceil(Math.log(l) / Math.log(f)), f = Math.ceil(l / Math.pow(f, u - 1))), h = Ci([]), h.leaf = false, h.height = u;
    const p = Math.ceil(l / f), d = p * Math.ceil(Math.sqrt(f));
    nf(e, r, s, d, this.compareMinX);
    for (let v = r; v <= s; v += d) {
      const _ = Math.min(v + d - 1, s);
      nf(e, v, _, p, this.compareMinY);
      for (let E = v; E <= _; E += p) {
        const S = Math.min(E + p - 1, _);
        h.children.push(this._build(e, E, S, u - 1));
      }
    }
    return Ai(h, this.toBBox), h;
  }
  _chooseSubtree(e, r, s, u) {
    for (; u.push(r), !(r.leaf || u.length - 1 === s); ) {
      let l = 1 / 0, f = 1 / 0, h;
      for (let p = 0; p < r.children.length; p++) {
        const d = r.children[p], v = hu(d), _ = u2(e, d) - v;
        _ < f ? (f = _, l = v < l ? v : l, h = d) : _ === f && v < l && (l = v, h = d);
      }
      r = h || r.children[0];
    }
    return r;
  }
  _insert(e, r, s) {
    const u = s ? e : this.toBBox(e), l = [], f = this._chooseSubtree(u, this.data, r, l);
    for (f.children.push(e), Ms(f, u); r >= 0 && l[r].children.length > this._maxEntries; )
      this._split(l, r), r--;
    this._adjustParentBBoxes(u, l, r);
  }
  // split overflowed node into two
  _split(e, r) {
    const s = e[r], u = s.children.length, l = this._minEntries;
    this._chooseSplitAxis(s, l, u);
    const f = this._chooseSplitIndex(s, l, u), h = Ci(s.children.splice(f, s.children.length - f));
    h.height = s.height, h.leaf = s.leaf, Ai(s, this.toBBox), Ai(h, this.toBBox), r ? e[r - 1].children.push(h) : this._splitRoot(s, h);
  }
  _splitRoot(e, r) {
    this.data = Ci([e, r]), this.data.height = e.height + 1, this.data.leaf = false, Ai(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, r, s) {
    let u, l = 1 / 0, f = 1 / 0;
    for (let h = r; h <= s - r; h++) {
      const p = Ss(e, 0, h, this.toBBox), d = Ss(e, h, s, this.toBBox), v = l2(p, d), _ = hu(p) + hu(d);
      v < l ? (l = v, u = h, f = _ < f ? _ : f) : v === l && _ < f && (f = _, u = h);
    }
    return u || s - r;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, r, s) {
    const u = e.leaf ? this.compareMinX : a2, l = e.leaf ? this.compareMinY : o2, f = this._allDistMargin(e, r, s, u), h = this._allDistMargin(e, r, s, l);
    f < h && e.children.sort(u);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, r, s, u) {
    e.children.sort(u);
    const l = this.toBBox, f = Ss(e, 0, r, l), h = Ss(e, s - r, s, l);
    let p = Ma(f) + Ma(h);
    for (let d = r; d < s - r; d++) {
      const v = e.children[d];
      Ms(f, e.leaf ? l(v) : v), p += Ma(f);
    }
    for (let d = s - r - 1; d >= r; d--) {
      const v = e.children[d];
      Ms(h, e.leaf ? l(v) : v), p += Ma(h);
    }
    return p;
  }
  _adjustParentBBoxes(e, r, s) {
    for (let u = s; u >= 0; u--)
      Ms(r[u], e);
  }
  _condense(e) {
    for (let r = e.length - 1, s; r >= 0; r--)
      e[r].children.length === 0 ? r > 0 ? (s = e[r - 1].children, s.splice(s.indexOf(e[r]), 1)) : this.clear() : Ai(e[r], this.toBBox);
  }
};
function s2(t, e, r) {
  if (!r) return e.indexOf(t);
  for (let s = 0; s < e.length; s++)
    if (r(t, e[s])) return s;
  return -1;
}
function Ai(t, e) {
  Ss(t, 0, t.children.length, e, t);
}
function Ss(t, e, r, s, u) {
  u || (u = Ci(null)), u.minX = 1 / 0, u.minY = 1 / 0, u.maxX = -1 / 0, u.maxY = -1 / 0;
  for (let l = e; l < r; l++) {
    const f = t.children[l];
    Ms(u, t.leaf ? s(f) : f);
  }
  return u;
}
function Ms(t, e) {
  return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t;
}
function a2(t, e) {
  return t.minX - e.minX;
}
function o2(t, e) {
  return t.minY - e.minY;
}
function hu(t) {
  return (t.maxX - t.minX) * (t.maxY - t.minY);
}
function Ma(t) {
  return t.maxX - t.minX + (t.maxY - t.minY);
}
function u2(t, e) {
  return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY));
}
function l2(t, e) {
  const r = Math.max(t.minX, e.minX), s = Math.max(t.minY, e.minY), u = Math.min(t.maxX, e.maxX), l = Math.min(t.maxY, e.maxY);
  return Math.max(0, u - r) * Math.max(0, l - s);
}
function fu(t, e) {
  return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;
}
function Ia(t, e) {
  return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;
}
function Ci(t) {
  return {
    children: t,
    height: 1,
    leaf: true,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function nf(t, e, r, s, u) {
  const l = [e, r];
  for (; l.length; ) {
    if (r = l.pop(), e = l.pop(), r - e <= s) continue;
    const f = e + Math.ceil((r - e) / s / 2) * s;
    r2(t, f, e, r, u), l.push(e, f, f, r);
  }
}
function c2(t) {
  return vk(
    t,
    (e, r) => e + h2(r),
    0
  );
}
function h2(t) {
  let e = 0, r;
  switch (t.type) {
    case "Polygon":
      return rf(t.coordinates);
    case "MultiPolygon":
      for (r = 0; r < t.coordinates.length; r++)
        e += rf(t.coordinates[r]);
      return e;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function rf(t) {
  let e = 0;
  if (t && t.length > 0) {
    e += Math.abs(sf(t[0]));
    for (let r = 1; r < t.length; r++)
      e -= Math.abs(sf(t[r]));
  }
  return e;
}
var f2 = ot * ot / 2;
var gu = Math.PI / 180;
function sf(t) {
  const e = t.length - 1;
  if (e <= 2) return 0;
  let r = 0, s = 0;
  for (; s < e; ) {
    const u = t[s], l = t[s + 1 === e ? 0 : s + 1], f = t[s + 2 >= e ? (s + 2) % e : s + 2], h = u[0] * gu, p = l[1] * gu, d = f[0] * gu;
    r += (d - h) * Math.sin(p), s++;
  }
  return r * f2;
}
var hr = 11102230246251565e-32;
var dt = 134217729;
var g2 = (3 + 8 * hr) * hr;
function du(t, e, r, s, u) {
  let l, f, h, p, d = e[0], v = s[0], _ = 0, E = 0;
  v > d == v > -d ? (l = d, d = e[++_]) : (l = v, v = s[++E]);
  let S = 0;
  if (_ < t && E < r)
    for (v > d == v > -d ? (f = d + l, h = l - (f - d), d = e[++_]) : (f = v + l, h = l - (f - v), v = s[++E]), l = f, h !== 0 && (u[S++] = h); _ < t && E < r; )
      v > d == v > -d ? (f = l + d, p = f - l, h = l - (f - p) + (d - p), d = e[++_]) : (f = l + v, p = f - l, h = l - (f - p) + (v - p), v = s[++E]), l = f, h !== 0 && (u[S++] = h);
  for (; _ < t; )
    f = l + d, p = f - l, h = l - (f - p) + (d - p), d = e[++_], l = f, h !== 0 && (u[S++] = h);
  for (; E < r; )
    f = l + v, p = f - l, h = l - (f - p) + (v - p), v = s[++E], l = f, h !== 0 && (u[S++] = h);
  return (l !== 0 || S === 0) && (u[S++] = l), S;
}
function d2(t, e) {
  let r = e[0];
  for (let s = 1; s < t; s++) r += e[s];
  return r;
}
function oa(t) {
  return new Float64Array(t);
}
var p2 = (3 + 16 * hr) * hr;
var m2 = (2 + 12 * hr) * hr;
var v2 = (9 + 64 * hr) * hr * hr;
var Li = oa(4);
var af = oa(8);
var of = oa(12);
var uf = oa(16);
var St = oa(4);
function y2(t, e, r, s, u, l, f) {
  let h, p, d, v, _, E, S, I, D, O, T, M, J, X, $, Y, j, x;
  const k = t - u, b = r - u, L = e - l, C = s - l;
  X = k * C, E = dt * k, S = E - (E - k), I = k - S, E = dt * C, D = E - (E - C), O = C - D, $ = I * O - (X - S * D - I * D - S * O), Y = L * b, E = dt * L, S = E - (E - L), I = L - S, E = dt * b, D = E - (E - b), O = b - D, j = I * O - (Y - S * D - I * D - S * O), T = $ - j, _ = $ - T, Li[0] = $ - (T + _) + (_ - j), M = X + T, _ = M - X, J = X - (M - _) + (T - _), T = J - Y, _ = J - T, Li[1] = J - (T + _) + (_ - Y), x = M + T, _ = x - M, Li[2] = M - (x - _) + (T - _), Li[3] = x;
  let G = d2(4, Li), R = m2 * f;
  if (G >= R || -G >= R || (_ = t - k, h = t - (k + _) + (_ - u), _ = r - b, d = r - (b + _) + (_ - u), _ = e - L, p = e - (L + _) + (_ - l), _ = s - C, v = s - (C + _) + (_ - l), h === 0 && p === 0 && d === 0 && v === 0) || (R = v2 * f + g2 * Math.abs(G), G += k * v + C * h - (L * d + b * p), G >= R || -G >= R)) return G;
  X = h * C, E = dt * h, S = E - (E - h), I = h - S, E = dt * C, D = E - (E - C), O = C - D, $ = I * O - (X - S * D - I * D - S * O), Y = p * b, E = dt * p, S = E - (E - p), I = p - S, E = dt * b, D = E - (E - b), O = b - D, j = I * O - (Y - S * D - I * D - S * O), T = $ - j, _ = $ - T, St[0] = $ - (T + _) + (_ - j), M = X + T, _ = M - X, J = X - (M - _) + (T - _), T = J - Y, _ = J - T, St[1] = J - (T + _) + (_ - Y), x = M + T, _ = x - M, St[2] = M - (x - _) + (T - _), St[3] = x;
  const P = du(4, Li, 4, St, af);
  X = k * v, E = dt * k, S = E - (E - k), I = k - S, E = dt * v, D = E - (E - v), O = v - D, $ = I * O - (X - S * D - I * D - S * O), Y = L * d, E = dt * L, S = E - (E - L), I = L - S, E = dt * d, D = E - (E - d), O = d - D, j = I * O - (Y - S * D - I * D - S * O), T = $ - j, _ = $ - T, St[0] = $ - (T + _) + (_ - j), M = X + T, _ = M - X, J = X - (M - _) + (T - _), T = J - Y, _ = J - T, St[1] = J - (T + _) + (_ - Y), x = M + T, _ = x - M, St[2] = M - (x - _) + (T - _), St[3] = x;
  const F = du(P, af, 4, St, of);
  X = h * v, E = dt * h, S = E - (E - h), I = h - S, E = dt * v, D = E - (E - v), O = v - D, $ = I * O - (X - S * D - I * D - S * O), Y = p * d, E = dt * p, S = E - (E - p), I = p - S, E = dt * d, D = E - (E - d), O = d - D, j = I * O - (Y - S * D - I * D - S * O), T = $ - j, _ = $ - T, St[0] = $ - (T + _) + (_ - j), M = X + T, _ = M - X, J = X - (M - _) + (T - _), T = J - Y, _ = J - T, St[1] = J - (T + _) + (_ - Y), x = M + T, _ = x - M, St[2] = M - (x - _) + (T - _), St[3] = x;
  const q = du(F, of, 4, St, uf);
  return uf[q - 1];
}
function _2(t, e, r, s, u, l) {
  const f = (e - l) * (r - u), h = (t - u) * (s - l), p = f - h, d = Math.abs(f + h);
  return Math.abs(p) >= p2 * d ? p : -y2(t, e, r, s, u, l, d);
}
function E2(t, e) {
  var r, s, u = 0, l, f, h, p, d, v, _, E = t[0], S = t[1], I = e.length;
  for (r = 0; r < I; r++) {
    s = 0;
    var D = e[r], O = D.length - 1;
    if (v = D[0], v[0] !== D[O][0] && v[1] !== D[O][1])
      throw new Error("First and last coordinates in a ring must be the same");
    for (f = v[0] - E, h = v[1] - S, s; s < O; s++) {
      if (_ = D[s + 1], p = _[0] - E, d = _[1] - S, h === 0 && d === 0) {
        if (p <= 0 && f >= 0 || f <= 0 && p >= 0)
          return 0;
      } else if (d >= 0 && h <= 0 || d <= 0 && h >= 0) {
        if (l = _2(f, p, h, d, 0, 0), l === 0)
          return 0;
        (l > 0 && d > 0 && h <= 0 || l < 0 && d <= 0 && h > 0) && u++;
      }
      v = _, h = d, f = p;
    }
  }
  return u % 2 !== 0;
}
function ii(t, e, r = {}) {
  if (!t)
    throw new Error("point is required");
  if (!e)
    throw new Error("polygon is required");
  const s = tt(t), u = sa(e), l = u.type, f = e.bbox;
  let h = u.coordinates;
  if (f && x2(s, f) === false)
    return false;
  l === "Polygon" && (h = [h]);
  let p = false;
  for (var d = 0; d < h.length; ++d) {
    const v = E2(s, h[d]);
    if (v === 0) return !r.ignoreBoundary;
    v && (p = true);
  }
  return p;
}
function x2(t, e) {
  return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1];
}
function w2(t, e, r) {
  if (t.geometry.type !== "Polygon")
    throw new Error("The input feature must be a Polygon");
  r === void 0 && (r = 1);
  var s = t.geometry.coordinates, u = [], l = {};
  if (r) {
    for (var f = [], h = 0; h < s.length; h++)
      for (var p = 0; p < s[h].length - 1; p++)
        f.push(O(h, p));
    var d = new tn();
    d.load(f);
  }
  for (var v = 0; v < s.length; v++)
    for (var _ = 0; _ < s[v].length - 1; _++)
      if (r) {
        var E = d.search(O(v, _));
        E.forEach(function(T) {
          var M = T.ring, J = T.edge;
          D(v, _, M, J);
        });
      } else
        for (var S = 0; S < s.length; S++)
          for (var I = 0; I < s[S].length - 1; I++)
            D(v, _, S, I);
  return e || (u = {
    type: "Feature",
    geometry: { type: "MultiPoint", coordinates: u }
  }), u;
  function D(T, M, J, X) {
    var $ = s[T][M], Y = s[T][M + 1], j = s[J][X], x = s[J][X + 1], k = k2($, Y, j, x);
    if (k !== null) {
      var b, L;
      if (Y[0] !== $[0] ? b = (k[0] - $[0]) / (Y[0] - $[0]) : b = (k[1] - $[1]) / (Y[1] - $[1]), x[0] !== j[0] ? L = (k[0] - j[0]) / (x[0] - j[0]) : L = (k[1] - j[1]) / (x[1] - j[1]), !(b >= 1 || b <= 0 || L >= 1 || L <= 0)) {
        var C = k, G = !l[C];
        G && (l[C] = true), e ? u.push(
          e(
            k,
            T,
            M,
            $,
            Y,
            b,
            J,
            X,
            j,
            x,
            L,
            G
          )
        ) : u.push(k);
      }
    }
  }
  function O(T, M) {
    var J = s[T][M], X = s[T][M + 1], $, Y, j, x;
    return J[0] < X[0] ? ($ = J[0], Y = X[0]) : ($ = X[0], Y = J[0]), J[1] < X[1] ? (j = J[1], x = X[1]) : (j = X[1], x = J[1]), {
      minX: $,
      minY: j,
      maxX: Y,
      maxY: x,
      ring: T,
      edge: M
    };
  }
}
function k2(t, e, r, s) {
  if (Is(t, r) || Is(t, s) || Is(e, r) || Is(s, r))
    return null;
  var u = t[0], l = t[1], f = e[0], h = e[1], p = r[0], d = r[1], v = s[0], _ = s[1], E = (u - f) * (d - _) - (l - h) * (p - v);
  if (E === 0) return null;
  var S = ((u * h - l * f) * (p - v) - (u - f) * (p * _ - d * v)) / E, I = ((u * h - l * f) * (d - _) - (l - h) * (p * _ - d * v)) / E;
  return [S, I];
}
function Is(t, e) {
  if (!t || !e || t.length !== e.length) return false;
  for (var r = 0, s = t.length; r < s; r++)
    if (t[r] instanceof Array && e[r] instanceof Array) {
      if (!Is(t[r], e[r])) return false;
    } else if (t[r] !== e[r])
      return false;
  return true;
}
function S2(t) {
  if (t.type != "Feature")
    throw new Error("The input must a geojson object of type Feature");
  if (t.geometry === void 0 || t.geometry == null)
    throw new Error(
      "The input must a geojson object with a non-empty geometry"
    );
  if (t.geometry.type != "Polygon")
    throw new Error("The input must be a geojson Polygon");
  for (var e = t.geometry.coordinates.length, r = [], M = 0; M < e; M++) {
    var s = t.geometry.coordinates[M];
    bs(s[0], s[s.length - 1]) || s.push(s[0]);
    for (var u = 0; u < s.length - 1; u++)
      r.push(s[u]);
  }
  if (!I2(r))
    throw new Error(
      "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
    );
  var l = r.length, f = w2(
    t,
    function(ae, oe, xe, Te, H, bn, Ie, ce, N, Ce, De, ke) {
      return [
        ae,
        oe,
        xe,
        Te,
        H,
        bn,
        Ie,
        ce,
        N,
        Ce,
        De,
        ke
      ];
    }
  ), h = f.length;
  if (h == 0) {
    for (var j = [], M = 0; M < e; M++)
      j.push(
        fr([t.geometry.coordinates[M]], {
          parent: -1,
          winding: M2(t.geometry.coordinates[M])
        })
      );
    var W = nt(j);
    return Z(), ne(), W;
  }
  for (var p = [], d = [], M = 0; M < e; M++) {
    p.push([]);
    for (var u = 0; u < t.geometry.coordinates[M].length - 1; u++)
      p[M].push([
        new lf(
          t.geometry.coordinates[M][Oi(u + 1, t.geometry.coordinates[M].length - 1)],
          1,
          [M, u],
          [M, Oi(u + 1, t.geometry.coordinates[M].length - 1)],
          void 0
        )
      ]), d.push(
        new cf(
          t.geometry.coordinates[M][u],
          [M, Oi(u - 1, t.geometry.coordinates[M].length - 1)],
          [M, u],
          void 0,
          void 0,
          false,
          true
        )
      );
  }
  for (var M = 0; M < h; M++)
    p[f[M][1]][f[M][2]].push(
      new lf(
        f[M][0],
        f[M][5],
        [f[M][1], f[M][2]],
        [f[M][6], f[M][7]],
        void 0
      )
    ), f[M][11] && d.push(
      new cf(
        f[M][0],
        [f[M][1], f[M][2]],
        [f[M][6], f[M][7]],
        void 0,
        void 0,
        true,
        true
      )
    );
  for (var v = d.length, M = 0; M < p.length; M++)
    for (var u = 0; u < p[M].length; u++)
      p[M][u].sort(function(oe, xe) {
        return oe.param < xe.param ? -1 : 1;
      });
  for (var _ = [], M = 0; M < v; M++)
    _.push({
      minX: d[M].coord[0],
      minY: d[M].coord[1],
      maxX: d[M].coord[0],
      maxY: d[M].coord[1],
      index: M
    });
  var E = new tn();
  E.load(_);
  for (var M = 0; M < p.length; M++)
    for (var u = 0; u < p[M].length; u++)
      for (var S = 0; S < p[M][u].length; S++) {
        var I;
        S == p[M][u].length - 1 ? I = p[M][Oi(u + 1, t.geometry.coordinates[M].length - 1)][0].coord : I = p[M][u][S + 1].coord;
        var D = E.search({
          minX: I[0],
          minY: I[1],
          maxX: I[0],
          maxY: I[1]
        })[0];
        p[M][u][S].nxtIsectAlongEdgeIn = D.index;
      }
  for (var M = 0; M < p.length; M++)
    for (var u = 0; u < p[M].length; u++)
      for (var S = 0; S < p[M][u].length; S++) {
        var I = p[M][u][S].coord, D = E.search({
          minX: I[0],
          minY: I[1],
          maxX: I[0],
          maxY: I[1]
        })[0], O = D.index;
        O < l ? d[O].nxtIsectAlongRingAndEdge2 = p[M][u][S].nxtIsectAlongEdgeIn : bs(
          d[O].ringAndEdge1,
          p[M][u][S].ringAndEdgeIn
        ) ? d[O].nxtIsectAlongRingAndEdge1 = p[M][u][S].nxtIsectAlongEdgeIn : d[O].nxtIsectAlongRingAndEdge2 = p[M][u][S].nxtIsectAlongEdgeIn;
      }
  for (var T = [], M = 0, u = 0; u < e; u++) {
    for (var J = M, S = 0; S < t.geometry.coordinates[u].length - 1; S++)
      d[M].coord[0] < d[J].coord[0] && (J = M), M++;
    for (var X = d[J].nxtIsectAlongRingAndEdge2, S = 0; S < d.length; S++)
      if (d[S].nxtIsectAlongRingAndEdge1 == J || d[S].nxtIsectAlongRingAndEdge2 == J) {
        var $ = S;
        break;
      }
    var Y = Ya(
      [
        d[$].coord,
        d[J].coord,
        d[X].coord
      ],
      true
    ) ? 1 : -1;
    T.push({ isect: J, parent: -1, winding: Y });
  }
  T.sort(function(le, ae) {
    return d[le.isect].coord > d[ae.isect].coord ? -1 : 1;
  });
  for (var j = []; T.length > 0; ) {
    var x = T.pop(), k = x.isect, b = x.parent, L = x.winding, C = j.length, G = [d[k].coord], R = k;
    if (d[k].ringAndEdge1Walkable)
      var P = d[k].ringAndEdge1, F = d[k].nxtIsectAlongRingAndEdge1;
    else
      var P = d[k].ringAndEdge2, F = d[k].nxtIsectAlongRingAndEdge2;
    for (; !bs(d[k].coord, d[F].coord); ) {
      G.push(d[F].coord);
      for (var q = void 0, M = 0; M < T.length; M++)
        if (T[M].isect == F) {
          q = M;
          break;
        }
      if (q != null && T.splice(q, 1), bs(P, d[F].ringAndEdge1)) {
        if (P = d[F].ringAndEdge2, d[F].ringAndEdge2Walkable = false, d[F].ringAndEdge1Walkable) {
          var U = { isect: F };
          Ya(
            [
              d[R].coord,
              d[F].coord,
              d[d[F].nxtIsectAlongRingAndEdge2].coord
            ],
            L == 1
          ) ? (U.parent = b, U.winding = -L) : (U.parent = C, U.winding = L), T.push(U);
        }
        R = F, F = d[F].nxtIsectAlongRingAndEdge2;
      } else {
        if (P = d[F].ringAndEdge1, d[F].ringAndEdge1Walkable = false, d[F].ringAndEdge2Walkable) {
          var U = { isect: F };
          Ya(
            [
              d[R].coord,
              d[F].coord,
              d[d[F].nxtIsectAlongRingAndEdge1].coord
            ],
            L == 1
          ) ? (U.parent = b, U.winding = -L) : (U.parent = C, U.winding = L), T.push(U);
        }
        R = F, F = d[F].nxtIsectAlongRingAndEdge1;
      }
    }
    G.push(d[F].coord), j.push(
      fr([G], {
        index: C,
        parent: b,
        winding: L,
        netWinding: void 0
      })
    );
  }
  var W = nt(j);
  Z(), ne();
  function Z() {
    for (var le = [], ae = 0; ae < W.features.length; ae++)
      W.features[ae].properties.parent == -1 && le.push(ae);
    if (le.length > 1)
      for (var ae = 0; ae < le.length; ae++) {
        for (var oe = -1, xe = 1 / 0, Te = 0; Te < W.features.length; Te++)
          le[ae] != Te && ii(
            W.features[le[ae]].geometry.coordinates[0][0],
            W.features[Te],
            { ignoreBoundary: true }
          ) && c2(W.features[Te]) < xe && (oe = Te);
        W.features[le[ae]].properties.parent = oe;
      }
  }
  function ne() {
    for (var le = 0; le < W.features.length; le++)
      if (W.features[le].properties.parent == -1) {
        var ae = W.features[le].properties.winding;
        W.features[le].properties.netWinding = ae, ge(le, ae);
      }
  }
  function ge(le, ae) {
    for (var oe = 0; oe < W.features.length; oe++)
      if (W.features[oe].properties.parent == le) {
        var xe = ae + W.features[oe].properties.winding;
        W.features[oe].properties.netWinding = xe, ge(oe, xe);
      }
  }
  return W;
}
var lf = function(t, e, r, s, u) {
  this.coord = t, this.param = e, this.ringAndEdgeIn = r, this.ringAndEdgeOut = s, this.nxtIsectAlongEdgeIn = u;
};
var cf = function(t, e, r, s, u, l, f) {
  this.coord = t, this.ringAndEdge1 = e, this.ringAndEdge2 = r, this.nxtIsectAlongRingAndEdge1 = s, this.nxtIsectAlongRingAndEdge2 = u, this.ringAndEdge1Walkable = l, this.ringAndEdge2Walkable = f;
};
function Ya(t, e) {
  if (typeof e > "u" && (e = true), t.length != 3)
    throw new Error("This function requires an array of three points [x,y]");
  var r = (t[1][0] - t[0][0]) * (t[2][1] - t[0][1]) - (t[1][1] - t[0][1]) * (t[2][0] - t[0][0]);
  return r >= 0 == e;
}
function M2(t) {
  for (var e = 0, r = 0; r < t.length - 1; r++)
    t[r][0] < t[e][0] && (e = r);
  if (Ya(
    [
      t[Oi(e - 1, t.length - 1)],
      t[e],
      t[Oi(e + 1, t.length - 1)]
    ],
    true
  ))
    var s = 1;
  else
    var s = -1;
  return s;
}
function bs(t, e) {
  if (!t || !e || t.length != e.length) return false;
  for (var r = 0, s = t.length; r < s; r++)
    if (t[r] instanceof Array && e[r] instanceof Array) {
      if (!bs(t[r], e[r])) return false;
    } else if (t[r] != e[r])
      return false;
  return true;
}
function Oi(t, e) {
  return (t % e + e) % e;
}
function I2(t) {
  for (var e = {}, r = 1, s = 0, u = t.length; s < u; ++s) {
    if (Object.prototype.hasOwnProperty.call(e, t[s])) {
      r = 0;
      break;
    }
    e[t[s]] = 1;
  }
  return r;
}
function b2(t) {
  var e = [];
  return Pr(t, function(r) {
    r.geometry.type === "Polygon" && Xn(S2(r), function(s) {
      e.push(fr(s.geometry.coordinates, r.properties));
    });
  }), nt(e);
}
var A2 = b2;
var L2 = class extends yr {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "polygon");
    __publicField(this, "shape", "polygon");
    __publicField(this, "lineDrawer", new ec(this.gm, { snappingMarkers: "first", targetShape: "polygon" }));
    __publicField(this, "eventHandlers", {
      [`${se}:draw`]: this.forwardLineDrawerEvent.bind(this),
      mousemove: this.onMouseMove.bind(this)
    });
  }
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on("firstMarkerClick", this.polygonFinished.bind(this));
  }
  onMouseMove(e) {
    return Ke(e) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: true }) : { next: true };
  }
  polygonFinished(e) {
    if (this.lineDrawer.endShape(), e.shapeCoordinates.length < 3)
      return;
    const r = this.fixShapeGeoJson(Ql(e.geoJson));
    r && this.gm.features.createFeature({
      shapeGeoJson: {
        ...r,
        properties: {
          // we don't need to have collected properties for a new polygon
          // ...geoJsonPolygon.properties,
          shape: this.shape
        }
      },
      sourceName: K.main
    });
  }
  fixShapeGeoJson(e) {
    try {
      return Ik(n2(A2(e))).features[0];
    } catch {
      return null;
    }
  }
};
var T2 = class extends yr {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "rectangle");
    __publicField(this, "shape", "rectangle");
    __publicField(this, "startLngLat", null);
    __publicField(this, "eventHandlers", {
      mousemove: this.onMouseMove.bind(this),
      click: this.onMouseClick.bind(this)
    });
    __publicField(this, "throttledMethods", ci(
      {
        updateFeaturePosition: this.updateFeaturePosition
      },
      this,
      this.gm.options.settings.throttlingDelay
    ));
  }
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    this.removeTmpFeature(), this.startLngLat = null, this.gm.markerPointer.disable(), this.fireFinishEvent();
  }
  onMouseClick(e) {
    var _a6;
    if (!Ke(e, { warning: true }))
      return { next: false };
    const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e.lngLat.toArray();
    if (this.startLngLat) {
      const s = this.getFeatureGeoJson(Ti(this.startLngLat, r));
      this.fireBeforeFeatureCreate({ geoJsonFeatures: [s] }), this.flags.featureCreateAllowed && this.finishShape(r);
    } else {
      const s = this.getFeatureGeoJson(Ti(r, r));
      if (this.fireBeforeFeatureCreate({ geoJsonFeatures: [s] }), this.flags.featureCreateAllowed) {
        const u = this.startShape(r);
        if (u) {
          const l = this.getControlMarkerData(["geometry", "coordinates", 4]);
          this.fireStartEvent(u, l);
        }
      }
    }
    return { next: false };
  }
  onMouseMove(e) {
    var _a6;
    if (!Ke(e, { warning: true }))
      return { next: false };
    if (!this.startLngLat)
      return this.fireMarkerPointerUpdateEvent(), { next: false };
    const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e.lngLat.toArray(), s = Ti(this.startLngLat, r), u = this.getFeatureGeoJson(s);
    return this.fireBeforeFeatureCreate({ geoJsonFeatures: [u] }), this.flags.featureCreateAllowed && this.throttledMethods.updateFeaturePosition(s), { next: false };
  }
  startShape(e) {
    this.startLngLat = e;
    const r = Ti(this.startLngLat, this.startLngLat);
    return this.featureData = this.createFeature(r), this.featureData;
  }
  finishShape(e) {
    if (this.startLngLat) {
      const r = Ti(this.startLngLat, e);
      this.throttledMethods.updateFeaturePosition(r);
    }
    this.featureData && (this.isFeatureGeoJsonValid() ? this.saveFeature() : this.removeTmpFeature()), this.startLngLat = null, this.fireFinishEvent();
  }
  createFeature(e) {
    return this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(e),
      sourceName: K.temporary
    });
  }
  isFeatureGeoJsonValid() {
    return this.featureData ? Vl(this.featureData.getGeoJson()) : false;
  }
  getFeatureGeoJson(e) {
    return {
      ...ju(
        [e[0], e[1]],
        [e[2], e[3]]
      ),
      properties: {
        shape: this.shape
      }
    };
  }
  updateFeaturePosition(e) {
    if (!this.featureData)
      return;
    const r = ju(
      [e[0], e[1]],
      [e[2], e[3]]
    );
    this.featureData.updateGeoJsonGeometry(r.geometry);
    const s = this.getControlMarkerData(["geometry", "coordinates", 4]);
    this.fireUpdateEvent(this.featureData, s);
  }
  getControlMarkerData(e) {
    const r = this.gm.markerPointer.marker;
    return r ? {
      type: "dom",
      instance: r,
      position: {
        coordinate: r.getLngLat(),
        path: e
      }
    } : null;
  }
  fireStartEvent(e, r) {
    const s = {
      name: `${se}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "start",
      featureData: e,
      markerData: r
    };
    this.gm.events.fire(`${se}:draw`, s);
  }
  fireUpdateEvent(e, r) {
    const s = {
      name: `${se}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "update",
      featureData: e,
      markerData: r
    };
    this.gm.events.fire(`${se}:draw`, s);
  }
  fireFinishEvent() {
    const e = {
      name: `${se}:draw:shape`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "finish"
    };
    this.gm.events.fire(`${se}:draw`, e);
  }
};
var C2 = class extends yr {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "text_marker");
    __publicField(this, "shape", "text_marker");
    __publicField(this, "textarea", null);
    __publicField(this, "eventHandlers", {
      click: this.onMouseClick.bind(this),
      mousemove: this.onMouseMove.bind(this)
    });
  }
  onStartAction() {
    this.gm.markerPointer.enable({ invisibleMarker: true });
  }
  onEndAction() {
    this.removeTextarea(), this.removeTmpFeature(), this.featureData = null, this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent();
  }
  onMouseMove(e) {
    return Ke(e, { warning: true }) ? (this.fireMarkerPointerUpdateEvent(), { next: true }) : { next: true };
  }
  onMouseClick(e) {
    var _a6;
    if (!Ke(e, { warning: true }))
      return { next: true };
    if (this.textarea)
      this.endShape(), this.gm.markerPointer.enable({ invisibleMarker: true, lngLat: e.lngLat.toArray() }), this.fireMarkerPointerUpdateEvent();
    else {
      const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e.lngLat.toArray();
      this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(r)] }), this.flags.featureCreateAllowed && (this.featureData = this.createFeature(r), this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent());
    }
    return { next: false };
  }
  createFeature(e) {
    const r = this.gm.mapAdapter.project(e);
    return this.createTextarea(r), this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(e),
      sourceName: K.temporary
    });
  }
  endShape() {
    var _a6;
    const e = ((_a6 = this.textarea) == null ? void 0 : _a6.value) || "";
    this.removeTextarea(), e.trim() ? (this.updateFeatureSource(e), this.saveFeature()) : this.removeTmpFeature();
  }
  createTextarea(e) {
    this.textarea = document.createElement("textarea"), this.textarea.style.position = "absolute", this.textarea.style.left = `${e[0]}px`, this.textarea.style.top = `${e[1]}px`, this.textarea.style.opacity = "0.7", this.gm.mapAdapter.getContainer().appendChild(this.textarea), this.textarea.focus();
  }
  removeTextarea() {
    var _a6;
    (_a6 = this.textarea) == null ? void 0 : _a6.remove(), this.textarea = null;
  }
  getFeatureGeoJson(e) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape,
        text: ""
      },
      geometry: {
        type: "Point",
        coordinates: e
      }
    };
  }
  updateFeatureSource(e) {
    this.featureData && this.featureData._updateAllProperties({ shape: this.shape, text: e });
  }
};
var N2 = class extends Kl {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "ellipse");
    __publicField(this, "shape", "ellipse");
    __publicField(this, "xSemiAxisPoint", null);
    __publicField(this, "xSemiAxisLngLat", null);
    __publicField(this, "throttledMethods", ci(
      {
        updateFeatureGeoJson: this.updateFeatureGeoJson
      },
      this,
      this.gm.options.settings.throttlingDelay
    ));
  }
  onMouseClick(e) {
    var _a6;
    if (!Ke(e))
      return { next: true };
    const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e.lngLat.toArray();
    if (this.circleCenterLngLat && this.xSemiAxisLngLat)
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [
          this.getEllipseGeoJson(this.circleCenterLngLat, this.xSemiAxisLngLat, r)
        ]
      }), this.flags.featureCreateAllowed && (this.saveEllipseFeature(r), this.circleCenterLngLat = null, this.circleCenterPoint = null, this.xSemiAxisPoint = null, this.xSemiAxisLngLat = null, this.fireFinishEvent());
    else if (this.circleCenterLngLat)
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [this.getEllipseGeoJson(this.circleCenterLngLat, r)]
      }), this.flags.featureCreateAllowed && (this.xSemiAxisLngLat = r, this.xSemiAxisPoint = this.gm.mapAdapter.project(this.circleCenterLngLat));
    else if (this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(r)] }), this.flags.featureCreateAllowed) {
      this.circleCenterLngLat = r, this.circleCenterPoint = this.gm.mapAdapter.project(this.circleCenterLngLat), this.featureData = this.createFeature();
      const s = this.getControlMarkerData();
      this.featureData && s && this.fireStartEvent(this.featureData, s);
    }
    return { next: false };
  }
  onMouseMove() {
    if (this.circleCenterLngLat && this.gm.markerPointer.marker) {
      const e = this.gm.markerPointer.marker.getLngLat();
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [
          this.xSemiAxisLngLat ? this.getEllipseGeoJson(this.circleCenterLngLat, this.xSemiAxisLngLat, e) : this.getEllipseGeoJson(this.circleCenterLngLat, e)
        ]
      }), this.flags.featureCreateAllowed && this.throttledMethods.updateFeatureGeoJson(e);
    }
    return this.circleCenterLngLat || this.fireMarkerPointerUpdateEvent(), { next: false };
  }
  updateFeatureGeoJson(e) {
    if (!this.featureData || !this.circleCenterLngLat)
      return;
    const r = this.xSemiAxisLngLat ? this.getEllipseGeoJson(this.circleCenterLngLat, this.xSemiAxisLngLat, e) : this.getEllipseGeoJson(this.circleCenterLngLat, e);
    this.featureData.updateGeoJsonGeometry(r.geometry), this.featureData._updateAllProperties({
      shape: r.properties.shape
    });
    const s = this.getControlMarkerData();
    s && this.fireUpdateEvent(this.featureData, s);
  }
  saveEllipseFeature(e) {
    var _a6;
    if (!(!this.circleCenterLngLat || !this.xSemiAxisLngLat) && this.featureData) {
      const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e;
      this.updateFeatureGeoJson(r);
      const { xSemiAxis: s, ySemiAxis: u, angle: l } = Kh({
        center: this.circleCenterLngLat,
        xSemiAxisLngLat: this.xSemiAxisLngLat,
        rimLngLat: r
      });
      this.featureData.setShapeProperty("center", this.circleCenterLngLat), this.featureData.setShapeProperty("xSemiAxis", s), this.featureData.setShapeProperty("ySemiAxis", u), this.featureData.setShapeProperty("angle", l), this.isFeatureGeoJsonValid() ? this.saveFeature() : this.removeTmpFeature();
    }
  }
  isFeatureGeoJsonValid() {
    return this.featureData ? Vl(this.featureData.getGeoJson()) : false;
  }
  getEllipseGeoJson(e, r, s) {
    const { xSemiAxis: u, ySemiAxis: l, angle: f } = Kh({
      center: e,
      xSemiAxisLngLat: r,
      rimLngLat: s
    });
    return No({ center: e, xSemiAxis: u, ySemiAxis: l, angle: f });
  }
};
var Ku = {
  marker: e2,
  ellipse: N2,
  circle: Xk,
  circle_marker: zk,
  text_marker: C2,
  line: Qk,
  rectangle: T2,
  polygon: L2,
  freehand: null,
  custom_shape: null
};
var P2 = (t, e) => Ku[e] ? new Ku[e](t) : (te.error(`Draw "${e}" is not available`), null);
var es = (t) => Sn(t) && t.actionType === "edit";
var O2 = (t) => Nd.includes(t);
var yI = (t) => hk.includes(t);
var R2 = (t) => Od.includes(t);
var D2 = (t) => Dd.includes(t);
var F2 = (t) => Rd.includes(t);
var G2 = (t) => R2(t) || D2(t) || F2(t);
var B2 = class extends Ao {
  constructor(e, r) {
    super(e);
    __publicField(this, "eventHandlers", {
      [`${se}:draw`]: this.handleDrawEvent.bind(this)
    });
    r.attachEvents(this.eventHandlers);
  }
  handleDrawEvent(e) {
    if (!Zl(e))
      return { next: true };
    const r = `${e.actionType}__${e.mode}`;
    return e.action === "mode_start" ? (this.trackExclusiveModes(e), this.start(r, e), this.trackRelatedModes(e)) : e.action === "mode_end" && (this.trackRelatedModes(e), this.end(r)), { next: true };
  }
  start(e, r) {
    const s = P2(this.gm, r.mode);
    s && (e in this.gm.actionInstances && te.error(`Action instance "${e}" already exists`), this.gm.actionInstances[e] = s, s.startAction());
  }
  end(e) {
    const r = this.gm.actionInstances[e];
    r instanceof yr ? (r.endAction(), delete this.gm.actionInstances[e]) : console.error(`Wrong action instance for draw event "${e}":`, r);
  }
};
var ts = class extends jl {
  constructor() {
    super(...arguments);
    __publicField(this, "actionType", "edit");
    __publicField(this, "featureData", null);
    __publicField(this, "cursorExcludedLayerIds", ["rectangle-line", "polygon-line", "circle-line"]);
    __publicField(this, "layerEventHandlersData", []);
  }
  startAction() {
    this.setEventsForLayers("mouseenter", this.setCursorToPointer.bind(this)), this.setEventsForLayers("mouseleave", this.setCursorToEmpty.bind(this)), super.startAction();
  }
  endAction() {
    this.clearEventsForLayers(), super.endAction();
  }
  setCursorToPointer() {
    this.flags.actionInProgress || this.gm.mapAdapter.setCursor("pointer");
  }
  setCursorToEmpty() {
    this.flags.actionInProgress || this.gm.mapAdapter.setCursor("");
  }
  getFeatureByMouseEvent({
    event: e,
    sourceNames: r
  }) {
    const s = this.gm.features.getFeatureByMouseEvent({
      event: e,
      sourceNames: r
    });
    return !s || s.getShapeProperty("disableEdit") === true ? null : s;
  }
  setEventsForLayers(e, r) {
    this.gm.features.layers.map((u) => u.id).filter(
      (u) => !this.cursorExcludedLayerIds.some((l) => u.includes(l))
    ).forEach((u) => {
      this.gm.mapAdapter.on(e, u, r), this.layerEventHandlersData.push({ eventName: e, layerId: u, callback: r });
    });
  }
  clearEventsForLayers() {
    this.layerEventHandlersData.forEach(({ eventName: e, layerId: r, callback: s }) => {
      this.gm.mapAdapter.off(e, r, s);
    }), this.layerEventHandlersData = [];
  }
  updateFeatureGeoJson({
    featureData: e,
    featureGeoJson: r,
    forceMode: s = void 0
  }) {
    return this.flags.featureUpdateAllowed ? (e.updateGeoJsonGeometry(r.geometry), Wi(e.getGeoJson().properties, r.properties) || e._updateAllProperties(r.properties), this.fireFeatureUpdatedEvent({
      sourceFeatures: [e],
      targetFeatures: [e],
      forceMode: s
    }), true) : false;
  }
  fireBeforeFeatureUpdate({
    features: e,
    geoJsonFeatures: r,
    forceMode: s = void 0
  }) {
    this.flags.featureUpdateAllowed = true;
    const u = {
      name: `${se}:feature:before_update`,
      level: "system",
      actionType: "edit",
      mode: s || this.mode,
      action: "before_update",
      features: e,
      geoJsonFeatures: r
    };
    this.gm.events.fire(`${se}:${this.actionType}`, u);
  }
  fireFeatureUpdatedEvent({
    sourceFeatures: e,
    targetFeatures: r,
    markerData: s = void 0,
    forceMode: u = void 0
  }) {
    const l = {
      name: `${se}:edit:feature_updated`,
      level: "system",
      actionType: "edit",
      action: "feature_updated",
      mode: u || this.mode,
      sourceFeatures: e,
      targetFeatures: r,
      markerData: s || null
    };
    this.gm.events.fire(`${se}:edit`, l);
  }
  fireFeatureEditStartEvent({
    feature: e,
    forceMode: r = void 0
  }) {
    const s = {
      name: `${se}:edit:feature_edit_start`,
      level: "system",
      actionType: "edit",
      action: "feature_edit_start",
      mode: r || this.mode,
      feature: e
    };
    this.gm.events.fire(`${se}:edit`, s);
  }
  fireFeatureEditEndEvent({
    feature: e,
    forceMode: r = void 0
  }) {
    const s = {
      name: `${se}:edit:feature_edit_end`,
      level: "system",
      actionType: "edit",
      action: "feature_edit_end",
      mode: r || this.mode,
      feature: e
    };
    this.gm.events.fire(`${se}:edit`, s);
  }
  fireMarkerPointerUpdateEvent() {
    if (!this.gm.markerPointer.marker)
      return;
    const e = this.gm.markerPointer.marker, r = {
      name: `${se}:draw:shape_with_data`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.getLineDrawerMode(),
      action: "update",
      markerData: {
        type: "dom",
        instance: e,
        position: {
          coordinate: e.getLngLat(),
          path: [-1]
        }
      },
      featureData: null
    };
    this.gm.events.fire(`${se}:draw`, r);
  }
  forwardLineDrawerEvent(e) {
    if (!ep(e) || !["cut", "split"].includes(this.mode))
      return { next: true };
    if (e.action === "start" || e.action === "update") {
      const r = {
        name: `${se}:draw:shape_with_data`,
        level: "system",
        actionType: "draw",
        mode: this.getLineDrawerMode(),
        variant: null,
        action: e.action,
        featureData: e.featureData,
        markerData: e.markerData
      };
      this.gm.events.fire(`${se}:draw`, r);
    } else if (e.action === "finish" || e.action === "cancel") {
      const r = {
        name: `${se}:draw:shape`,
        level: "system",
        actionType: "draw",
        mode: this.getLineDrawerMode(),
        variant: null,
        action: e.action
      };
      this.gm.events.fire(`${se}:draw`, r);
    }
    return { next: true };
  }
  fireFeatureRemovedEvent(e) {
    if (Cr(e.shape, or)) {
      const r = {
        name: `${se}:edit:feature_removed`,
        level: "system",
        actionType: "edit",
        mode: e.shape,
        action: "feature_removed",
        featureData: e
      };
      this.gm.events.fire(`${se}:edit`, r);
    }
  }
  getLineDrawerMode() {
    return this.mode === "cut" ? "polygon" : (this.mode === "split", "line");
  }
};
function U2(t, e = {}) {
  const r = ir(t), s = (r[0] + r[2]) / 2, u = (r[1] + r[3]) / 2;
  return En([s, u], e.properties, e);
}
var Ha = { exports: {} };
var z2 = Ha.exports;
var hf;
function q2() {
  return hf || (hf = 1, (function(t, e) {
    (function(r, s) {
      t.exports = s();
    })(z2, (function() {
      function r(o, n) {
        (n == null || n > o.length) && (n = o.length);
        for (var i = 0, a = Array(n); i < n; i++) a[i] = o[i];
        return a;
      }
      function s(o, n, i) {
        return n = v(n), (function(a, c) {
          if (c && (typeof c == "object" || typeof c == "function")) return c;
          if (c !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
          return (function(g) {
            if (g === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return g;
          })(a);
        })(o, E() ? Reflect.construct(n, i || [], v(o).constructor) : n.apply(o, i));
      }
      function u(o, n) {
        if (!(o instanceof n)) throw new TypeError("Cannot call a class as a function");
      }
      function l(o, n, i) {
        if (E()) return Reflect.construct.apply(null, arguments);
        var a = [null];
        a.push.apply(a, n);
        var c = new (o.bind.apply(o, a))();
        return i && S(c, i.prototype), c;
      }
      function f(o, n) {
        for (var i = 0; i < n.length; i++) {
          var a = n[i];
          a.enumerable = a.enumerable || false, a.configurable = true, "value" in a && (a.writable = true), Object.defineProperty(o, O(a.key), a);
        }
      }
      function h(o, n, i) {
        return n && f(o.prototype, n), i && f(o, i), Object.defineProperty(o, "prototype", { writable: false }), o;
      }
      function p(o, n) {
        var i = typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
        if (!i) {
          if (Array.isArray(o) || (i = T(o)) || n) {
            i && (o = i);
            var a = 0, c = function() {
            };
            return { s: c, n: function() {
              return a >= o.length ? { done: true } : { done: false, value: o[a++] };
            }, e: function(w) {
              throw w;
            }, f: c };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var g, m = true, y = false;
        return { s: function() {
          i = i.call(o);
        }, n: function() {
          var w = i.next();
          return m = w.done, w;
        }, e: function(w) {
          y = true, g = w;
        }, f: function() {
          try {
            m || i.return == null || i.return();
          } finally {
            if (y) throw g;
          }
        } };
      }
      function d() {
        return d = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(o, n, i) {
          var a = (function(g, m) {
            for (; !{}.hasOwnProperty.call(g, m) && (g = v(g)) !== null; ) ;
            return g;
          })(o, n);
          if (a) {
            var c = Object.getOwnPropertyDescriptor(a, n);
            return c.get ? c.get.call(arguments.length < 3 ? o : i) : c.value;
          }
        }, d.apply(null, arguments);
      }
      function v(o) {
        return v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
          return n.__proto__ || Object.getPrototypeOf(n);
        }, v(o);
      }
      function _(o, n) {
        if (typeof n != "function" && n !== null) throw new TypeError("Super expression must either be null or a function");
        o.prototype = Object.create(n && n.prototype, { constructor: { value: o, writable: true, configurable: true } }), Object.defineProperty(o, "prototype", { writable: false }), n && S(o, n);
      }
      function E() {
        try {
          var o = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
          })));
        } catch {
        }
        return (E = function() {
          return !!o;
        })();
      }
      function S(o, n) {
        return S = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, a) {
          return i.__proto__ = a, i;
        }, S(o, n);
      }
      function I(o, n, i, a) {
        var c = d(v(1 & a ? o.prototype : o), n, i);
        return 2 & a && typeof c == "function" ? function(g) {
          return c.apply(i, g);
        } : c;
      }
      function D(o) {
        return (function(n) {
          if (Array.isArray(n)) return r(n);
        })(o) || (function(n) {
          if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null) return Array.from(n);
        })(o) || T(o) || (function() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        })();
      }
      function O(o) {
        var n = (function(i, a) {
          if (typeof i != "object" || !i) return i;
          var c = i[Symbol.toPrimitive];
          if (c !== void 0) {
            var g = c.call(i, a);
            if (typeof g != "object") return g;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(i);
        })(o, "string");
        return typeof n == "symbol" ? n : n + "";
      }
      function T(o, n) {
        if (o) {
          if (typeof o == "string") return r(o, n);
          var i = {}.toString.call(o).slice(8, -1);
          return i === "Object" && o.constructor && (i = o.constructor.name), i === "Map" || i === "Set" ? Array.from(o) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? r(o, n) : void 0;
        }
      }
      function M(o) {
        var n = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
        return M = function(i) {
          if (i === null || !(function(c) {
            try {
              return Function.toString.call(c).indexOf("[native code]") !== -1;
            } catch {
              return typeof c == "function";
            }
          })(i)) return i;
          if (typeof i != "function") throw new TypeError("Super expression must either be null or a function");
          if (n !== void 0) {
            if (n.has(i)) return n.get(i);
            n.set(i, a);
          }
          function a() {
            return l(i, arguments, v(this).constructor);
          }
          return a.prototype = Object.create(i.prototype, { constructor: { value: a, enumerable: false, writable: true, configurable: true } }), S(a, i);
        }, M(o);
      }
      var J = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "getEndCapStyle", value: function() {
          return this._endCapStyle;
        } }, { key: "isSingleSided", value: function() {
          return this._isSingleSided;
        } }, { key: "setQuadrantSegments", value: function(n) {
          this._quadrantSegments = n, this._quadrantSegments === 0 && (this._joinStyle = o.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = o.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), n <= 0 && (this._quadrantSegments = 1), this._joinStyle !== o.JOIN_ROUND && (this._quadrantSegments = o.DEFAULT_QUADRANT_SEGMENTS);
        } }, { key: "getJoinStyle", value: function() {
          return this._joinStyle;
        } }, { key: "setJoinStyle", value: function(n) {
          this._joinStyle = n;
        } }, { key: "setSimplifyFactor", value: function(n) {
          this._simplifyFactor = n < 0 ? 0 : n;
        } }, { key: "getSimplifyFactor", value: function() {
          return this._simplifyFactor;
        } }, { key: "getQuadrantSegments", value: function() {
          return this._quadrantSegments;
        } }, { key: "setEndCapStyle", value: function(n) {
          this._endCapStyle = n;
        } }, { key: "getMitreLimit", value: function() {
          return this._mitreLimit;
        } }, { key: "setMitreLimit", value: function(n) {
          this._mitreLimit = n;
        } }, { key: "setSingleSided", value: function(n) {
          this._isSingleSided = n;
        } }], [{ key: "constructor_", value: function() {
          if (this._quadrantSegments = o.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = o.CAP_ROUND, this._joinStyle = o.JOIN_ROUND, this._mitreLimit = o.DEFAULT_MITRE_LIMIT, this._isSingleSided = false, this._simplifyFactor = o.DEFAULT_SIMPLIFY_FACTOR, arguments.length !== 0) {
            if (arguments.length === 1) {
              var n = arguments[0];
              this.setQuadrantSegments(n);
            } else if (arguments.length === 2) {
              var i = arguments[0], a = arguments[1];
              this.setQuadrantSegments(i), this.setEndCapStyle(a);
            } else if (arguments.length === 4) {
              var c = arguments[0], g = arguments[1], m = arguments[2], y = arguments[3];
              this.setQuadrantSegments(c), this.setEndCapStyle(g), this.setJoinStyle(m), this.setMitreLimit(y);
            }
          }
        } }, { key: "bufferDistanceError", value: function(n) {
          var i = Math.PI / 2 / n;
          return 1 - Math.cos(i / 2);
        } }]);
      })();
      J.CAP_ROUND = 1, J.CAP_FLAT = 2, J.CAP_SQUARE = 3, J.JOIN_ROUND = 1, J.JOIN_MITRE = 2, J.JOIN_BEVEL = 3, J.DEFAULT_QUADRANT_SEGMENTS = 8, J.DEFAULT_MITRE_LIMIT = 5, J.DEFAULT_SIMPLIFY_FACTOR = 0.01;
      var X = (function(o) {
        function n(i) {
          var a;
          return u(this, n), (a = s(this, n, [i])).name = Object.keys({ Exception: n })[0], a;
        }
        return _(n, o), h(n, [{ key: "toString", value: function() {
          return this.message;
        } }]);
      })(M(Error)), $ = (function(o) {
        function n(i) {
          var a;
          return u(this, n), (a = s(this, n, [i])).name = Object.keys({ IllegalArgumentException: n })[0], a;
        }
        return _(n, o), h(n);
      })(X), Y = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "filter", value: function(o) {
        } }]);
      })();
      function j() {
      }
      function x() {
      }
      function k() {
      }
      var b, L, C, G, R, P, F, q, U = (function() {
        return h((function o() {
          u(this, o);
        }), null, [{ key: "equalsWithTolerance", value: function(o, n, i) {
          return Math.abs(o - n) <= i;
        } }]);
      })(), W = (function() {
        return h((function o(n, i) {
          u(this, o), this.low = i || 0, this.high = n || 0;
        }), null, [{ key: "toBinaryString", value: function(o) {
          var n, i = "";
          for (n = 2147483648; n > 0; n >>>= 1) i += (o.high & n) === n ? "1" : "0";
          for (n = 2147483648; n > 0; n >>>= 1) i += (o.low & n) === n ? "1" : "0";
          return i;
        } }]);
      })();
      function Z() {
      }
      function ne() {
      }
      Z.NaN = NaN, Z.isNaN = function(o) {
        return Number.isNaN(o);
      }, Z.isInfinite = function(o) {
        return !Number.isFinite(o);
      }, Z.MAX_VALUE = Number.MAX_VALUE, Z.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, Z.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, typeof Float64Array == "function" && typeof Int32Array == "function" ? (P = 2146435072, F = new Float64Array(1), q = new Int32Array(F.buffer), Z.doubleToLongBits = function(o) {
        F[0] = o;
        var n = 0 | q[0], i = 0 | q[1];
        return (i & P) === P && 1048575 & i && n !== 0 && (n = 0, i = 2146959360), new W(i, n);
      }, Z.longBitsToDouble = function(o) {
        return q[0] = o.low, q[1] = o.high, F[0];
      }) : (b = 1023, L = Math.log2, C = Math.floor, G = Math.pow, R = (function() {
        for (var o = 53; o > 0; o--) {
          var n = G(2, o) - 1;
          if (C(L(n)) + 1 === o) return n;
        }
        return 0;
      })(), Z.doubleToLongBits = function(o) {
        var n, i, a, c, g, m, y, w, A;
        if (o < 0 || 1 / o === Number.NEGATIVE_INFINITY ? (m = 1 << 31, o = -o) : m = 0, o === 0) return new W(w = m, A = 0);
        if (o === 1 / 0) return new W(w = 2146435072 | m, A = 0);
        if (o != o) return new W(w = 2146959360, A = 0);
        if (c = 0, A = 0, (n = C(o)) > 1) if (n <= R) (c = C(L(n))) <= 20 ? (A = 0, w = n << 20 - c & 1048575) : (A = n % (i = G(2, a = c - 20)) << 32 - a, w = n / i & 1048575);
        else for (a = n, A = 0; (a = C(i = a / 2)) !== 0; ) c++, A >>>= 1, A |= (1 & w) << 31, w >>>= 1, i !== a && (w |= 524288);
        if (y = c + b, g = n === 0, n = o - n, c < 52 && n !== 0) for (a = 0; ; ) {
          if ((i = 2 * n) >= 1 ? (n = i - 1, g ? (y--, g = false) : (a <<= 1, a |= 1, c++)) : (n = i, g ? --y == 0 && (c++, g = false) : (a <<= 1, c++)), c === 20) w |= a, a = 0;
          else if (c === 52) {
            A |= a;
            break;
          }
          if (i === 1) {
            c < 20 ? w |= a << 20 - c : c < 52 && (A |= a << 52 - c);
            break;
          }
        }
        return w |= y << 20, new W(w |= m, A);
      }, Z.longBitsToDouble = function(o) {
        var n, i, a, c, g = o.high, m = o.low, y = g & 1 << 31 ? -1 : 1;
        for (a = ((2146435072 & g) >> 20) - b, c = 0, i = 1 << 19, n = 1; n <= 20; n++) g & i && (c += G(2, -n)), i >>>= 1;
        for (i = 1 << 31, n = 21; n <= 52; n++) m & i && (c += G(2, -n)), i >>>= 1;
        if (a === -1023) {
          if (c === 0) return 0 * y;
          a = -1022;
        } else {
          if (a === 1024) return c === 0 ? y / 0 : NaN;
          c += 1;
        }
        return y * c * G(2, a);
      });
      var ge = (function(o) {
        function n(i) {
          var a;
          return u(this, n), (a = s(this, n, [i])).name = Object.keys({ RuntimeException: n })[0], a;
        }
        return _(n, o), h(n);
      })(X), le = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, null, [{ key: "constructor_", value: function() {
          if (arguments.length === 0) ge.constructor_.call(this);
          else if (arguments.length === 1) {
            var i = arguments[0];
            ge.constructor_.call(this, i);
          }
        } }]);
      })(ge), ae = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "shouldNeverReachHere", value: function() {
          if (arguments.length === 0) o.shouldNeverReachHere(null);
          else if (arguments.length === 1) {
            var n = arguments[0];
            throw new le("Should never reach here" + (n !== null ? ": " + n : ""));
          }
        } }, { key: "isTrue", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            o.isTrue(n, null);
          } else if (arguments.length === 2) {
            var i = arguments[1];
            if (!arguments[0]) throw i === null ? new le() : new le(i);
          }
        } }, { key: "equals", value: function() {
          if (arguments.length === 2) {
            var n = arguments[0], i = arguments[1];
            o.equals(n, i, null);
          } else if (arguments.length === 3) {
            var a = arguments[0], c = arguments[1], g = arguments[2];
            if (!c.equals(a)) throw new le("Expected " + a + " but encountered " + c + (g !== null ? ": " + g : ""));
          }
        } }]);
      })(), oe = new ArrayBuffer(8), xe = new Float64Array(oe), Te = new Int32Array(oe), H = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "getM", value: function() {
          return Z.NaN;
        } }, { key: "setOrdinate", value: function(n, i) {
          switch (n) {
            case o.X:
              this.x = i;
              break;
            case o.Y:
              this.y = i;
              break;
            case o.Z:
              this.setZ(i);
              break;
            default:
              throw new $("Invalid ordinate index: " + n);
          }
        } }, { key: "equals2D", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            return this.x === n.x && this.y === n.y;
          }
          if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            return !!U.equalsWithTolerance(this.x, i.x, a) && !!U.equalsWithTolerance(this.y, i.y, a);
          }
        } }, { key: "setM", value: function(n) {
          throw new $("Invalid ordinate index: " + o.M);
        } }, { key: "getZ", value: function() {
          return this.z;
        } }, { key: "getOrdinate", value: function(n) {
          switch (n) {
            case o.X:
              return this.x;
            case o.Y:
              return this.y;
            case o.Z:
              return this.getZ();
          }
          throw new $("Invalid ordinate index: " + n);
        } }, { key: "equals3D", value: function(n) {
          return this.x === n.x && this.y === n.y && (this.getZ() === n.getZ() || Z.isNaN(this.getZ()) && Z.isNaN(n.getZ()));
        } }, { key: "equals", value: function(n) {
          return n instanceof o && this.equals2D(n);
        } }, { key: "equalInZ", value: function(n, i) {
          return U.equalsWithTolerance(this.getZ(), n.getZ(), i);
        } }, { key: "setX", value: function(n) {
          this.x = n;
        } }, { key: "compareTo", value: function(n) {
          var i = n;
          return this.x < i.x ? -1 : this.x > i.x ? 1 : this.y < i.y ? -1 : this.y > i.y ? 1 : 0;
        } }, { key: "getX", value: function() {
          return this.x;
        } }, { key: "setZ", value: function(n) {
          this.z = n;
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (n) {
            if (n instanceof CloneNotSupportedException) return ae.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
            throw n;
          }
        } }, { key: "copy", value: function() {
          return new o(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")";
        } }, { key: "distance3D", value: function(n) {
          var i = this.x - n.x, a = this.y - n.y, c = this.getZ() - n.getZ();
          return Math.sqrt(i * i + a * a + c * c);
        } }, { key: "getY", value: function() {
          return this.y;
        } }, { key: "setY", value: function(n) {
          this.y = n;
        } }, { key: "distance", value: function(n) {
          var i = this.x - n.x, a = this.y - n.y;
          return Math.sqrt(i * i + a * a);
        } }, { key: "hashCode", value: function() {
          var n = 17;
          return n = 37 * (n = 37 * n + o.hashCode(this.x)) + o.hashCode(this.y);
        } }, { key: "setCoordinate", value: function(n) {
          this.x = n.x, this.y = n.y, this.z = n.getZ();
        } }, { key: "interfaces_", get: function() {
          return [j, x, k];
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.z = null, arguments.length === 0) o.constructor_.call(this, 0, 0);
          else if (arguments.length === 1) {
            var n = arguments[0];
            o.constructor_.call(this, n.x, n.y, n.getZ());
          } else if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            o.constructor_.call(this, i, a, o.NULL_ORDINATE);
          } else if (arguments.length === 3) {
            var c = arguments[0], g = arguments[1], m = arguments[2];
            this.x = c, this.y = g, this.z = m;
          }
        } }, { key: "hashCode", value: function(n) {
          return xe[0] = n, Te[0] ^ Te[1];
        } }]);
      })(), bn = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "compare", value: function(n, i) {
          var a = o.compare(n.x, i.x);
          if (a !== 0) return a;
          var c = o.compare(n.y, i.y);
          return c !== 0 ? c : this._dimensionsToTest <= 2 ? 0 : o.compare(n.getZ(), i.getZ());
        } }, { key: "interfaces_", get: function() {
          return [ne];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimensionsToTest = 2, arguments.length === 0) o.constructor_.call(this, 2);
          else if (arguments.length === 1) {
            var n = arguments[0];
            if (n !== 2 && n !== 3) throw new $("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = n;
          }
        } }, { key: "compare", value: function(n, i) {
          return n < i ? -1 : n > i ? 1 : Z.isNaN(n) ? Z.isNaN(i) ? 0 : -1 : Z.isNaN(i) ? 1 : 0;
        } }]);
      })();
      H.DimensionalComparator = bn, H.NULL_ORDINATE = Z.NaN, H.X = 0, H.Y = 1, H.Z = 2, H.M = 3;
      var Ie = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "getArea", value: function() {
          return this.getWidth() * this.getHeight();
        } }, { key: "equals", value: function(n) {
          if (!(n instanceof o)) return false;
          var i = n;
          return this.isNull() ? i.isNull() : this._maxx === i.getMaxX() && this._maxy === i.getMaxY() && this._minx === i.getMinX() && this._miny === i.getMinY();
        } }, { key: "intersection", value: function(n) {
          if (this.isNull() || n.isNull() || !this.intersects(n)) return new o();
          var i = this._minx > n._minx ? this._minx : n._minx, a = this._miny > n._miny ? this._miny : n._miny;
          return new o(i, this._maxx < n._maxx ? this._maxx : n._maxx, a, this._maxy < n._maxy ? this._maxy : n._maxy);
        } }, { key: "isNull", value: function() {
          return this._maxx < this._minx;
        } }, { key: "getMaxX", value: function() {
          return this._maxx;
        } }, { key: "covers", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof H) {
              var n = arguments[0];
              return this.covers(n.x, n.y);
            }
            if (arguments[0] instanceof o) {
              var i = arguments[0];
              return !this.isNull() && !i.isNull() && i.getMinX() >= this._minx && i.getMaxX() <= this._maxx && i.getMinY() >= this._miny && i.getMaxY() <= this._maxy;
            }
          } else if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            return !this.isNull() && a >= this._minx && a <= this._maxx && c >= this._miny && c <= this._maxy;
          }
        } }, { key: "intersects", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof o) {
              var n = arguments[0];
              return !this.isNull() && !n.isNull() && !(n._minx > this._maxx || n._maxx < this._minx || n._miny > this._maxy || n._maxy < this._miny);
            }
            if (arguments[0] instanceof H) {
              var i = arguments[0];
              return this.intersects(i.x, i.y);
            }
          } else if (arguments.length === 2) {
            if (arguments[0] instanceof H && arguments[1] instanceof H) {
              var a = arguments[0], c = arguments[1];
              return !this.isNull() && !((a.x < c.x ? a.x : c.x) > this._maxx) && !((a.x > c.x ? a.x : c.x) < this._minx) && !((a.y < c.y ? a.y : c.y) > this._maxy) && !((a.y > c.y ? a.y : c.y) < this._miny);
            }
            if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
              var g = arguments[0], m = arguments[1];
              return !this.isNull() && !(g > this._maxx || g < this._minx || m > this._maxy || m < this._miny);
            }
          }
        } }, { key: "getMinY", value: function() {
          return this._miny;
        } }, { key: "getDiameter", value: function() {
          if (this.isNull()) return 0;
          var n = this.getWidth(), i = this.getHeight();
          return Math.sqrt(n * n + i * i);
        } }, { key: "getMinX", value: function() {
          return this._minx;
        } }, { key: "expandToInclude", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof H) {
              var n = arguments[0];
              this.expandToInclude(n.x, n.y);
            } else if (arguments[0] instanceof o) {
              var i = arguments[0];
              if (i.isNull()) return null;
              this.isNull() ? (this._minx = i.getMinX(), this._maxx = i.getMaxX(), this._miny = i.getMinY(), this._maxy = i.getMaxY()) : (i._minx < this._minx && (this._minx = i._minx), i._maxx > this._maxx && (this._maxx = i._maxx), i._miny < this._miny && (this._miny = i._miny), i._maxy > this._maxy && (this._maxy = i._maxy));
            }
          } else if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            this.isNull() ? (this._minx = a, this._maxx = a, this._miny = c, this._maxy = c) : (a < this._minx && (this._minx = a), a > this._maxx && (this._maxx = a), c < this._miny && (this._miny = c), c > this._maxy && (this._maxy = c));
          }
        } }, { key: "minExtent", value: function() {
          if (this.isNull()) return 0;
          var n = this.getWidth(), i = this.getHeight();
          return n < i ? n : i;
        } }, { key: "getWidth", value: function() {
          return this.isNull() ? 0 : this._maxx - this._minx;
        } }, { key: "compareTo", value: function(n) {
          var i = n;
          return this.isNull() ? i.isNull() ? 0 : -1 : i.isNull() ? 1 : this._minx < i._minx ? -1 : this._minx > i._minx ? 1 : this._miny < i._miny ? -1 : this._miny > i._miny ? 1 : this._maxx < i._maxx ? -1 : this._maxx > i._maxx ? 1 : this._maxy < i._maxy ? -1 : this._maxy > i._maxy ? 1 : 0;
        } }, { key: "translate", value: function(n, i) {
          if (this.isNull()) return null;
          this.init(this.getMinX() + n, this.getMaxX() + n, this.getMinY() + i, this.getMaxY() + i);
        } }, { key: "copy", value: function() {
          return new o(this);
        } }, { key: "toString", value: function() {
          return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
        } }, { key: "setToNull", value: function() {
          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
        } }, { key: "disjoint", value: function(n) {
          return !(!this.isNull() && !n.isNull()) || n._minx > this._maxx || n._maxx < this._minx || n._miny > this._maxy || n._maxy < this._miny;
        } }, { key: "getHeight", value: function() {
          return this.isNull() ? 0 : this._maxy - this._miny;
        } }, { key: "maxExtent", value: function() {
          if (this.isNull()) return 0;
          var n = this.getWidth(), i = this.getHeight();
          return n > i ? n : i;
        } }, { key: "expandBy", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            this.expandBy(n, n);
          } else if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            if (this.isNull()) return null;
            this._minx -= i, this._maxx += i, this._miny -= a, this._maxy += a, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
          }
        } }, { key: "contains", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof o) {
              var n = arguments[0];
              return this.covers(n);
            }
            if (arguments[0] instanceof H) {
              var i = arguments[0];
              return this.covers(i);
            }
          } else if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            return this.covers(a, c);
          }
        } }, { key: "centre", value: function() {
          return this.isNull() ? null : new H((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
        } }, { key: "init", value: function() {
          if (arguments.length === 0) this.setToNull();
          else if (arguments.length === 1) {
            if (arguments[0] instanceof H) {
              var n = arguments[0];
              this.init(n.x, n.x, n.y, n.y);
            } else if (arguments[0] instanceof o) {
              var i = arguments[0];
              this._minx = i._minx, this._maxx = i._maxx, this._miny = i._miny, this._maxy = i._maxy;
            }
          } else if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            this.init(a.x, c.x, a.y, c.y);
          } else if (arguments.length === 4) {
            var g = arguments[0], m = arguments[1], y = arguments[2], w = arguments[3];
            g < m ? (this._minx = g, this._maxx = m) : (this._minx = m, this._maxx = g), y < w ? (this._miny = y, this._maxy = w) : (this._miny = w, this._maxy = y);
          }
        } }, { key: "getMaxY", value: function() {
          return this._maxy;
        } }, { key: "distance", value: function(n) {
          if (this.intersects(n)) return 0;
          var i = 0;
          this._maxx < n._minx ? i = n._minx - this._maxx : this._minx > n._maxx && (i = this._minx - n._maxx);
          var a = 0;
          return this._maxy < n._miny ? a = n._miny - this._maxy : this._miny > n._maxy && (a = this._miny - n._maxy), i === 0 ? a : a === 0 ? i : Math.sqrt(i * i + a * a);
        } }, { key: "hashCode", value: function() {
          var n = 17;
          return n = 37 * (n = 37 * (n = 37 * (n = 37 * n + H.hashCode(this._minx)) + H.hashCode(this._maxx)) + H.hashCode(this._miny)) + H.hashCode(this._maxy);
        } }, { key: "interfaces_", get: function() {
          return [j, k];
        } }], [{ key: "constructor_", value: function() {
          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0) this.init();
          else if (arguments.length === 1) {
            if (arguments[0] instanceof H) {
              var n = arguments[0];
              this.init(n.x, n.x, n.y, n.y);
            } else if (arguments[0] instanceof o) {
              var i = arguments[0];
              this.init(i);
            }
          } else if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            this.init(a.x, c.x, a.y, c.y);
          } else if (arguments.length === 4) {
            var g = arguments[0], m = arguments[1], y = arguments[2], w = arguments[3];
            this.init(g, m, y, w);
          }
        } }, { key: "intersects", value: function() {
          if (arguments.length === 3) {
            var n = arguments[0], i = arguments[1], a = arguments[2];
            return a.x >= (n.x < i.x ? n.x : i.x) && a.x <= (n.x > i.x ? n.x : i.x) && a.y >= (n.y < i.y ? n.y : i.y) && a.y <= (n.y > i.y ? n.y : i.y);
          }
          if (arguments.length === 4) {
            var c = arguments[0], g = arguments[1], m = arguments[2], y = arguments[3], w = Math.min(m.x, y.x), A = Math.max(m.x, y.x), z = Math.min(c.x, g.x), V = Math.max(c.x, g.x);
            return !(z > A) && !(V < w) && (w = Math.min(m.y, y.y), A = Math.max(m.y, y.y), z = Math.min(c.y, g.y), V = Math.max(c.y, g.y), !(z > A) && !(V < w));
          }
        } }]);
      })(), ce = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "isGeometryCollection", value: function() {
          return this.getTypeCode() === o.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getFactory", value: function() {
          return this._factory;
        } }, { key: "getGeometryN", value: function(n) {
          return this;
        } }, { key: "getArea", value: function() {
          return 0;
        } }, { key: "isRectangle", value: function() {
          return false;
        } }, { key: "equalsExact", value: function(n) {
          return this === n || this.equalsExact(n, 0);
        } }, { key: "geometryChanged", value: function() {
          this.apply(o.geometryChangedFilter);
        } }, { key: "geometryChangedAction", value: function() {
          this._envelope = null;
        } }, { key: "equalsNorm", value: function(n) {
          return n !== null && this.norm().equalsExact(n.norm());
        } }, { key: "getLength", value: function() {
          return 0;
        } }, { key: "getNumGeometries", value: function() {
          return 1;
        } }, { key: "compareTo", value: function() {
          var n;
          if (arguments.length === 1) {
            var i = arguments[0];
            return n = i, this.getTypeCode() !== n.getTypeCode() ? this.getTypeCode() - n.getTypeCode() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(i);
          }
          if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            return n = a, this.getTypeCode() !== n.getTypeCode() ? this.getTypeCode() - n.getTypeCode() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(a, c);
          }
        } }, { key: "getUserData", value: function() {
          return this._userData;
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "getEnvelope", value: function() {
          return this.getFactory().toGeometry(this.getEnvelopeInternal());
        } }, { key: "checkNotGeometryCollection", value: function(n) {
          if (n.getTypeCode() === o.TYPECODE_GEOMETRYCOLLECTION) throw new $("This method does not support GeometryCollection arguments");
        } }, { key: "equal", value: function(n, i, a) {
          return a === 0 ? n.equals(i) : n.distance(i) <= a;
        } }, { key: "norm", value: function() {
          var n = this.copy();
          return n.normalize(), n;
        } }, { key: "reverse", value: function() {
          var n = this.reverseInternal();
          return this.envelope != null && (n.envelope = this.envelope.copy()), n.setSRID(this.getSRID()), n;
        } }, { key: "copy", value: function() {
          var n = this.copyInternal();
          return n.envelope = this._envelope == null ? null : this._envelope.copy(), n._SRID = this._SRID, n._userData = this._userData, n;
        } }, { key: "getPrecisionModel", value: function() {
          return this._factory.getPrecisionModel();
        } }, { key: "getEnvelopeInternal", value: function() {
          return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new Ie(this._envelope);
        } }, { key: "setSRID", value: function(n) {
          this._SRID = n;
        } }, { key: "setUserData", value: function(n) {
          this._userData = n;
        } }, { key: "compare", value: function(n, i) {
          for (var a = n.iterator(), c = i.iterator(); a.hasNext() && c.hasNext(); ) {
            var g = a.next(), m = c.next(), y = g.compareTo(m);
            if (y !== 0) return y;
          }
          return a.hasNext() ? 1 : c.hasNext() ? -1 : 0;
        } }, { key: "hashCode", value: function() {
          return this.getEnvelopeInternal().hashCode();
        } }, { key: "isEquivalentClass", value: function(n) {
          return this.getClass() === n.getClass();
        } }, { key: "isGeometryCollectionOrDerived", value: function() {
          return this.getTypeCode() === o.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === o.TYPECODE_MULTIPOINT || this.getTypeCode() === o.TYPECODE_MULTILINESTRING || this.getTypeCode() === o.TYPECODE_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [x, j, k];
        } }, { key: "getClass", value: function() {
          return o;
        } }], [{ key: "hasNonEmptyElements", value: function(n) {
          for (var i = 0; i < n.length; i++) if (!n[i].isEmpty()) return true;
          return false;
        } }, { key: "hasNullElements", value: function(n) {
          for (var i = 0; i < n.length; i++) if (n[i] === null) return true;
          return false;
        } }]);
      })();
      ce.constructor_ = function(o) {
        o && (this._envelope = null, this._userData = null, this._factory = o, this._SRID = o.getSRID());
      }, ce.TYPECODE_POINT = 0, ce.TYPECODE_MULTIPOINT = 1, ce.TYPECODE_LINESTRING = 2, ce.TYPECODE_LINEARRING = 3, ce.TYPECODE_MULTILINESTRING = 4, ce.TYPECODE_POLYGON = 5, ce.TYPECODE_MULTIPOLYGON = 6, ce.TYPECODE_GEOMETRYCOLLECTION = 7, ce.TYPENAME_POINT = "Point", ce.TYPENAME_MULTIPOINT = "MultiPoint", ce.TYPENAME_LINESTRING = "LineString", ce.TYPENAME_LINEARRING = "LinearRing", ce.TYPENAME_MULTILINESTRING = "MultiLineString", ce.TYPENAME_POLYGON = "Polygon", ce.TYPENAME_MULTIPOLYGON = "MultiPolygon", ce.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", ce.geometryChangedFilter = { get interfaces_() {
        return [Y];
      }, filter: function(o) {
        o.geometryChangedAction();
      } };
      var N = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "toLocationSymbol", value: function(n) {
          switch (n) {
            case o.EXTERIOR:
              return "e";
            case o.BOUNDARY:
              return "b";
            case o.INTERIOR:
              return "i";
            case o.NONE:
              return "-";
          }
          throw new $("Unknown location value: " + n);
        } }]);
      })();
      N.INTERIOR = 0, N.BOUNDARY = 1, N.EXTERIOR = 2, N.NONE = -1;
      var Ce = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "add", value: function() {
        } }, { key: "addAll", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }, { key: "iterator", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "toArray", value: function() {
        } }, { key: "remove", value: function() {
        } }]);
      })(), De = (function(o) {
        function n(i) {
          var a;
          return u(this, n), (a = s(this, n, [i])).name = Object.keys({ NoSuchElementException: n })[0], a;
        }
        return _(n, o), h(n);
      })(X), ke = (function(o) {
        function n(i) {
          var a;
          return u(this, n), (a = s(this, n, [i])).name = Object.keys({ UnsupportedOperationException: n })[0], a;
        }
        return _(n, o), h(n);
      })(X), hi = (function(o) {
        function n() {
          return u(this, n), s(this, n, arguments);
        }
        return _(n, o), h(n, [{ key: "contains", value: function() {
        } }]);
      })(Ce), Gr = (function(o) {
        function n(i) {
          var a;
          return u(this, n), (a = s(this, n)).map = /* @__PURE__ */ new Map(), i instanceof Ce && a.addAll(i), a;
        }
        return _(n, o), h(n, [{ key: "contains", value: function(i) {
          var a = i.hashCode ? i.hashCode() : i;
          return !!this.map.has(a);
        } }, { key: "add", value: function(i) {
          var a = i.hashCode ? i.hashCode() : i;
          return !this.map.has(a) && !!this.map.set(a, i);
        } }, { key: "addAll", value: function(i) {
          var a, c = p(i);
          try {
            for (c.s(); !(a = c.n()).done; ) {
              var g = a.value;
              this.add(g);
            }
          } catch (m) {
            c.e(m);
          } finally {
            c.f();
          }
          return true;
        } }, { key: "remove", value: function() {
          throw new ke();
        } }, { key: "size", value: function() {
          return this.map.size;
        } }, { key: "isEmpty", value: function() {
          return this.map.size === 0;
        } }, { key: "toArray", value: function() {
          return Array.from(this.map.values());
        } }, { key: "iterator", value: function() {
          return new _r4(this.map);
        } }, { key: Symbol.iterator, value: function() {
          return this.map;
        } }]);
      })(hi), _r4 = (function() {
        return h((function o(n) {
          u(this, o), this.iterator = n.values();
          var i = this.iterator.next(), a = i.done, c = i.value;
          this.done = a, this.value = c;
        }), [{ key: "next", value: function() {
          if (this.done) throw new De();
          var o = this.value, n = this.iterator.next(), i = n.done, a = n.value;
          return this.done = i, this.value = a, o;
        } }, { key: "hasNext", value: function() {
          return !this.done;
        } }, { key: "remove", value: function() {
          throw new ke();
        } }]);
      })(), re = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "opposite", value: function(n) {
          return n === o.LEFT ? o.RIGHT : n === o.RIGHT ? o.LEFT : n;
        } }]);
      })();
      re.ON = 0, re.LEFT = 1, re.RIGHT = 2;
      var Br = (function(o) {
        function n(i) {
          var a;
          return u(this, n), (a = s(this, n, [i])).name = Object.keys({ EmptyStackException: n })[0], a;
        }
        return _(n, o), h(n);
      })(X), rs = (function(o) {
        function n(i) {
          var a;
          return u(this, n), (a = s(this, n, [i])).name = Object.keys({ IndexOutOfBoundsException: n })[0], a;
        }
        return _(n, o), h(n);
      })(X), An = (function(o) {
        function n() {
          return u(this, n), s(this, n, arguments);
        }
        return _(n, o), h(n, [{ key: "get", value: function() {
        } }, { key: "set", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }]);
      })(Ce), Po = (function(o) {
        function n() {
          var i;
          return u(this, n), (i = s(this, n)).array = [], i;
        }
        return _(n, o), h(n, [{ key: "add", value: function(i) {
          return this.array.push(i), true;
        } }, { key: "get", value: function(i) {
          if (i < 0 || i >= this.size()) throw new rs();
          return this.array[i];
        } }, { key: "push", value: function(i) {
          return this.array.push(i), i;
        } }, { key: "pop", value: function() {
          if (this.array.length === 0) throw new Br();
          return this.array.pop();
        } }, { key: "peek", value: function() {
          if (this.array.length === 0) throw new Br();
          return this.array[this.array.length - 1];
        } }, { key: "empty", value: function() {
          return this.array.length === 0;
        } }, { key: "isEmpty", value: function() {
          return this.empty();
        } }, { key: "search", value: function(i) {
          return this.array.indexOf(i);
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }]);
      })(An);
      function Ee(o, n) {
        return o.interfaces_ && o.interfaces_.indexOf(n) > -1;
      }
      var cn = (function() {
        return h((function o(n) {
          u(this, o), this.str = n;
        }), [{ key: "append", value: function(o) {
          this.str += o;
        } }, { key: "setCharAt", value: function(o, n) {
          this.str = this.str.substr(0, o) + n + this.str.substr(o + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]);
      })(), hn = (function() {
        function o(n) {
          u(this, o), this.value = n;
        }
        return h(o, [{ key: "intValue", value: function() {
          return this.value;
        } }, { key: "compareTo", value: function(n) {
          return this.value < n ? -1 : this.value > n ? 1 : 0;
        } }], [{ key: "compare", value: function(n, i) {
          return n < i ? -1 : n > i ? 1 : 0;
        } }, { key: "isNan", value: function(n) {
          return Number.isNaN(n);
        } }, { key: "valueOf", value: function(n) {
          return new o(n);
        } }]);
      })(), Ct = (function() {
        return h((function o() {
          u(this, o);
        }), null, [{ key: "isWhitespace", value: function(o) {
          return o <= 32 && o >= 0 || o === 127;
        } }, { key: "toUpperCase", value: function(o) {
          return o.toUpperCase();
        } }]);
      })(), ve = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "le", value: function(n) {
          return this._hi < n._hi || this._hi === n._hi && this._lo <= n._lo;
        } }, { key: "extractSignificantDigits", value: function(n, i) {
          var a = this.abs(), c = o.magnitude(a._hi), g = o.TEN.pow(c);
          (a = a.divide(g)).gt(o.TEN) ? (a = a.divide(o.TEN), c += 1) : a.lt(o.ONE) && (a = a.multiply(o.TEN), c -= 1);
          for (var m = c + 1, y = new cn(), w = o.MAX_PRINT_DIGITS - 1, A = 0; A <= w; A++) {
            n && A === m && y.append(".");
            var z = Math.trunc(a._hi);
            if (z < 0) break;
            var V = false, ee = 0;
            z > 9 ? (V = true, ee = "9") : ee = "0" + z, y.append(ee), a = a.subtract(o.valueOf(z)).multiply(o.TEN), V && a.selfAdd(o.TEN);
            var ue = true, fe = o.magnitude(a._hi);
            if (fe < 0 && Math.abs(fe) >= w - A && (ue = false), !ue) break;
          }
          return i[0] = c, y.toString();
        } }, { key: "sqr", value: function() {
          return this.multiply(this);
        } }, { key: "doubleValue", value: function() {
          return this._hi + this._lo;
        } }, { key: "subtract", value: function() {
          if (arguments[0] instanceof o) {
            var n = arguments[0];
            return this.add(n.negate());
          }
          if (typeof arguments[0] == "number") {
            var i = arguments[0];
            return this.add(-i);
          }
        } }, { key: "equals", value: function() {
          if (arguments.length === 1 && arguments[0] instanceof o) {
            var n = arguments[0];
            return this._hi === n._hi && this._lo === n._lo;
          }
        } }, { key: "isZero", value: function() {
          return this._hi === 0 && this._lo === 0;
        } }, { key: "selfSubtract", value: function() {
          if (arguments[0] instanceof o) {
            var n = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-n._hi, -n._lo);
          }
          if (typeof arguments[0] == "number") {
            var i = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-i, 0);
          }
        } }, { key: "getSpecialNumberString", value: function() {
          return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
        } }, { key: "min", value: function(n) {
          return this.le(n) ? this : n;
        } }, { key: "selfDivide", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof o) {
              var n = arguments[0];
              return this.selfDivide(n._hi, n._lo);
            }
            if (typeof arguments[0] == "number") {
              var i = arguments[0];
              return this.selfDivide(i, 0);
            }
          } else if (arguments.length === 2) {
            var a, c, g, m, y = arguments[0], w = arguments[1], A = null, z = null, V = null, ee = null;
            return g = this._hi / y, ee = (A = (V = o.SPLIT * g) - (A = V - g)) * (z = (ee = o.SPLIT * y) - (z = ee - y)) - (m = g * y) + A * (c = y - z) + (a = g - A) * z + a * c, ee = g + (V = (this._hi - m - ee + this._lo - g * w) / y), this._hi = ee, this._lo = g - ee + V, this;
          }
        } }, { key: "dump", value: function() {
          return "DD<" + this._hi + ", " + this._lo + ">";
        } }, { key: "divide", value: function() {
          if (arguments[0] instanceof o) {
            var n, i, a, c, g = arguments[0], m = null, y = null, w = null, A = null;
            return n = (a = this._hi / g._hi) - (m = (w = o.SPLIT * a) - (m = w - a)), A = m * (y = (A = o.SPLIT * g._hi) - (y = A - g._hi)) - (c = a * g._hi) + m * (i = g._hi - y) + n * y + n * i, new o(A = a + (w = (this._hi - c - A + this._lo - a * g._lo) / g._hi), a - A + w);
          }
          if (typeof arguments[0] == "number") {
            var z = arguments[0];
            return Z.isNaN(z) ? o.createNaN() : o.copy(this).selfDivide(z, 0);
          }
        } }, { key: "ge", value: function(n) {
          return this._hi > n._hi || this._hi === n._hi && this._lo >= n._lo;
        } }, { key: "pow", value: function(n) {
          if (n === 0) return o.valueOf(1);
          var i = new o(this), a = o.valueOf(1), c = Math.abs(n);
          if (c > 1) for (; c > 0; ) c % 2 == 1 && a.selfMultiply(i), (c /= 2) > 0 && (i = i.sqr());
          else a = i;
          return n < 0 ? a.reciprocal() : a;
        } }, { key: "ceil", value: function() {
          if (this.isNaN()) return o.NaN;
          var n = Math.ceil(this._hi), i = 0;
          return n === this._hi && (i = Math.ceil(this._lo)), new o(n, i);
        } }, { key: "compareTo", value: function(n) {
          var i = n;
          return this._hi < i._hi ? -1 : this._hi > i._hi ? 1 : this._lo < i._lo ? -1 : this._lo > i._lo ? 1 : 0;
        } }, { key: "rint", value: function() {
          return this.isNaN() ? this : this.add(0.5).floor();
        } }, { key: "setValue", value: function() {
          if (arguments[0] instanceof o) {
            var n = arguments[0];
            return this.init(n), this;
          }
          if (typeof arguments[0] == "number") {
            var i = arguments[0];
            return this.init(i), this;
          }
        } }, { key: "max", value: function(n) {
          return this.ge(n) ? this : n;
        } }, { key: "sqrt", value: function() {
          if (this.isZero()) return o.valueOf(0);
          if (this.isNegative()) return o.NaN;
          var n = 1 / Math.sqrt(this._hi), i = this._hi * n, a = o.valueOf(i), c = this.subtract(a.sqr())._hi * (0.5 * n);
          return a.add(c);
        } }, { key: "selfAdd", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof o) {
              var n = arguments[0];
              return this.selfAdd(n._hi, n._lo);
            }
            if (typeof arguments[0] == "number") {
              var i, a, c, g, m, y = arguments[0], w = null;
              return w = (c = this._hi + y) - (g = c - this._hi), a = (m = (w = y - g + (this._hi - w)) + this._lo) + (c - (i = c + m)), this._hi = i + a, this._lo = a + (i - this._hi), this;
            }
          } else if (arguments.length === 2) {
            var A, z, V, ee, ue = arguments[0], fe = arguments[1], me = null, Ae = null, be = null;
            V = this._hi + ue, z = this._lo + fe, Ae = V - (be = V - this._hi), me = z - (ee = z - this._lo);
            var Ge = (A = V + (be = (Ae = ue - be + (this._hi - Ae)) + z)) + (be = (me = fe - ee + (this._lo - me)) + (be + (V - A))), ht = be + (A - Ge);
            return this._hi = Ge, this._lo = ht, this;
          }
        } }, { key: "selfMultiply", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof o) {
              var n = arguments[0];
              return this.selfMultiply(n._hi, n._lo);
            }
            if (typeof arguments[0] == "number") {
              var i = arguments[0];
              return this.selfMultiply(i, 0);
            }
          } else if (arguments.length === 2) {
            var a, c, g = arguments[0], m = arguments[1], y = null, w = null, A = null, z = null;
            y = (A = o.SPLIT * this._hi) - this._hi, z = o.SPLIT * g, y = A - y, a = this._hi - y, w = z - g;
            var V = (A = this._hi * g) + (z = y * (w = z - w) - A + y * (c = g - w) + a * w + a * c + (this._hi * m + this._lo * g)), ee = z + (y = A - V);
            return this._hi = V, this._lo = ee, this;
          }
        } }, { key: "selfSqr", value: function() {
          return this.selfMultiply(this);
        } }, { key: "floor", value: function() {
          if (this.isNaN()) return o.NaN;
          var n = Math.floor(this._hi), i = 0;
          return n === this._hi && (i = Math.floor(this._lo)), new o(n, i);
        } }, { key: "negate", value: function() {
          return this.isNaN() ? this : new o(-this._hi, -this._lo);
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (n) {
            if (n instanceof CloneNotSupportedException) return null;
            throw n;
          }
        } }, { key: "multiply", value: function() {
          if (arguments[0] instanceof o) {
            var n = arguments[0];
            return n.isNaN() ? o.createNaN() : o.copy(this).selfMultiply(n);
          }
          if (typeof arguments[0] == "number") {
            var i = arguments[0];
            return Z.isNaN(i) ? o.createNaN() : o.copy(this).selfMultiply(i, 0);
          }
        } }, { key: "isNaN", value: function() {
          return Z.isNaN(this._hi);
        } }, { key: "intValue", value: function() {
          return Math.trunc(this._hi);
        } }, { key: "toString", value: function() {
          var n = o.magnitude(this._hi);
          return n >= -3 && n <= 20 ? this.toStandardNotation() : this.toSciNotation();
        } }, { key: "toStandardNotation", value: function() {
          var n = this.getSpecialNumberString();
          if (n !== null) return n;
          var i = new Array(1).fill(null), a = this.extractSignificantDigits(true, i), c = i[0] + 1, g = a;
          if (a.charAt(0) === ".") g = "0" + a;
          else if (c < 0) g = "0." + o.stringOfChar("0", -c) + a;
          else if (a.indexOf(".") === -1) {
            var m = c - a.length;
            g = a + o.stringOfChar("0", m) + ".0";
          }
          return this.isNegative() ? "-" + g : g;
        } }, { key: "reciprocal", value: function() {
          var n, i, a, c, g = null, m = null, y = null, w = null;
          n = (a = 1 / this._hi) - (g = (y = o.SPLIT * a) - (g = y - a)), m = (w = o.SPLIT * this._hi) - this._hi;
          var A = a + (y = (1 - (c = a * this._hi) - (w = g * (m = w - m) - c + g * (i = this._hi - m) + n * m + n * i) - a * this._lo) / this._hi);
          return new o(A, a - A + y);
        } }, { key: "toSciNotation", value: function() {
          if (this.isZero()) return o.SCI_NOT_ZERO;
          var n = this.getSpecialNumberString();
          if (n !== null) return n;
          var i = new Array(1).fill(null), a = this.extractSignificantDigits(false, i), c = o.SCI_NOT_EXPONENT_CHAR + i[0];
          if (a.charAt(0) === "0") throw new IllegalStateException("Found leading zero: " + a);
          var g = "";
          a.length > 1 && (g = a.substring(1));
          var m = a.charAt(0) + "." + g;
          return this.isNegative() ? "-" + m + c : m + c;
        } }, { key: "abs", value: function() {
          return this.isNaN() ? o.NaN : this.isNegative() ? this.negate() : new o(this);
        } }, { key: "isPositive", value: function() {
          return this._hi > 0 || this._hi === 0 && this._lo > 0;
        } }, { key: "lt", value: function(n) {
          return this._hi < n._hi || this._hi === n._hi && this._lo < n._lo;
        } }, { key: "add", value: function() {
          if (arguments[0] instanceof o) {
            var n = arguments[0];
            return o.copy(this).selfAdd(n);
          }
          if (typeof arguments[0] == "number") {
            var i = arguments[0];
            return o.copy(this).selfAdd(i);
          }
        } }, { key: "init", value: function() {
          if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
              var n = arguments[0];
              this._hi = n, this._lo = 0;
            } else if (arguments[0] instanceof o) {
              var i = arguments[0];
              this._hi = i._hi, this._lo = i._lo;
            }
          } else if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            this._hi = a, this._lo = c;
          }
        } }, { key: "gt", value: function(n) {
          return this._hi > n._hi || this._hi === n._hi && this._lo > n._lo;
        } }, { key: "isNegative", value: function() {
          return this._hi < 0 || this._hi === 0 && this._lo < 0;
        } }, { key: "trunc", value: function() {
          return this.isNaN() ? o.NaN : this.isPositive() ? this.floor() : this.ceil();
        } }, { key: "signum", value: function() {
          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [k, j, x];
        } }], [{ key: "constructor_", value: function() {
          if (this._hi = 0, this._lo = 0, arguments.length === 0) this.init(0);
          else if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
              var n = arguments[0];
              this.init(n);
            } else if (arguments[0] instanceof o) {
              var i = arguments[0];
              this.init(i);
            } else if (typeof arguments[0] == "string") {
              var a = arguments[0];
              o.constructor_.call(this, o.parse(a));
            }
          } else if (arguments.length === 2) {
            var c = arguments[0], g = arguments[1];
            this.init(c, g);
          }
        } }, { key: "determinant", value: function() {
          if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var n = arguments[0], i = arguments[1], a = arguments[2], c = arguments[3];
            return o.determinant(o.valueOf(n), o.valueOf(i), o.valueOf(a), o.valueOf(c));
          }
          if (arguments[3] instanceof o && arguments[2] instanceof o && arguments[0] instanceof o && arguments[1] instanceof o) {
            var g = arguments[1], m = arguments[2], y = arguments[3];
            return arguments[0].multiply(y).selfSubtract(g.multiply(m));
          }
        } }, { key: "sqr", value: function(n) {
          return o.valueOf(n).selfMultiply(n);
        } }, { key: "valueOf", value: function() {
          if (typeof arguments[0] == "string") {
            var n = arguments[0];
            return o.parse(n);
          }
          if (typeof arguments[0] == "number") return new o(arguments[0]);
        } }, { key: "sqrt", value: function(n) {
          return o.valueOf(n).sqrt();
        } }, { key: "parse", value: function(n) {
          for (var i = 0, a = n.length; Ct.isWhitespace(n.charAt(i)); ) i++;
          var c = false;
          if (i < a) {
            var g = n.charAt(i);
            g !== "-" && g !== "+" || (i++, g === "-" && (c = true));
          }
          for (var m = new o(), y = 0, w = 0, A = 0, z = false; !(i >= a); ) {
            var V = n.charAt(i);
            if (i++, Ct.isDigit(V)) {
              var ee = V - "0";
              m.selfMultiply(o.TEN), m.selfAdd(ee), y++;
            } else {
              if (V !== ".") {
                if (V === "e" || V === "E") {
                  var ue = n.substring(i);
                  try {
                    A = hn.parseInt(ue);
                  } catch (Ge) {
                    throw Ge instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + ue + " in string " + n) : Ge;
                  }
                  break;
                }
                throw new NumberFormatException("Unexpected character '" + V + "' at position " + i + " in string " + n);
              }
              w = y, z = true;
            }
          }
          var fe = m;
          z || (w = y);
          var me = y - w - A;
          if (me === 0) fe = m;
          else if (me > 0) {
            var Ae = o.TEN.pow(me);
            fe = m.divide(Ae);
          } else if (me < 0) {
            var be = o.TEN.pow(-me);
            fe = m.multiply(be);
          }
          return c ? fe.negate() : fe;
        } }, { key: "createNaN", value: function() {
          return new o(Z.NaN, Z.NaN);
        } }, { key: "copy", value: function(n) {
          return new o(n);
        } }, { key: "magnitude", value: function(n) {
          var i = Math.abs(n), a = Math.log(i) / Math.log(10), c = Math.trunc(Math.floor(a));
          return 10 * Math.pow(10, c) <= i && (c += 1), c;
        } }, { key: "stringOfChar", value: function(n, i) {
          for (var a = new cn(), c = 0; c < i; c++) a.append(n);
          return a.toString();
        } }]);
      })();
      ve.PI = new ve(3.141592653589793, 12246467991473532e-32), ve.TWO_PI = new ve(6.283185307179586, 24492935982947064e-32), ve.PI_2 = new ve(1.5707963267948966, 6123233995736766e-32), ve.E = new ve(2.718281828459045, 14456468917292502e-32), ve.NaN = new ve(Z.NaN, Z.NaN), ve.EPS = 123259516440783e-46, ve.SPLIT = 134217729, ve.MAX_PRINT_DIGITS = 32, ve.TEN = ve.valueOf(10), ve.ONE = ve.valueOf(1), ve.SCI_NOT_EXPONENT_CHAR = "E", ve.SCI_NOT_ZERO = "0.0E0";
      var fi = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "orientationIndex", value: function(n, i, a) {
          var c = o.orientationIndexFilter(n, i, a);
          if (c <= 1) return c;
          var g = ve.valueOf(i.x).selfAdd(-n.x), m = ve.valueOf(i.y).selfAdd(-n.y), y = ve.valueOf(a.x).selfAdd(-i.x), w = ve.valueOf(a.y).selfAdd(-i.y);
          return g.selfMultiply(w).selfSubtract(m.selfMultiply(y)).signum();
        } }, { key: "signOfDet2x2", value: function() {
          if (arguments[3] instanceof ve && arguments[2] instanceof ve && arguments[0] instanceof ve && arguments[1] instanceof ve) {
            var n = arguments[1], i = arguments[2], a = arguments[3];
            return arguments[0].multiply(a).selfSubtract(n.multiply(i)).signum();
          }
          if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var c = arguments[0], g = arguments[1], m = arguments[2], y = arguments[3], w = ve.valueOf(c), A = ve.valueOf(g), z = ve.valueOf(m), V = ve.valueOf(y);
            return w.multiply(V).selfSubtract(A.multiply(z)).signum();
          }
        } }, { key: "intersection", value: function(n, i, a, c) {
          var g = new ve(n.y).selfSubtract(i.y), m = new ve(i.x).selfSubtract(n.x), y = new ve(n.x).selfMultiply(i.y).selfSubtract(new ve(i.x).selfMultiply(n.y)), w = new ve(a.y).selfSubtract(c.y), A = new ve(c.x).selfSubtract(a.x), z = new ve(a.x).selfMultiply(c.y).selfSubtract(new ve(c.x).selfMultiply(a.y)), V = m.multiply(z).selfSubtract(A.multiply(y)), ee = w.multiply(y).selfSubtract(g.multiply(z)), ue = g.multiply(A).selfSubtract(w.multiply(m)), fe = V.selfDivide(ue).doubleValue(), me = ee.selfDivide(ue).doubleValue();
          return Z.isNaN(fe) || Z.isInfinite(fe) || Z.isNaN(me) || Z.isInfinite(me) ? null : new H(fe, me);
        } }, { key: "orientationIndexFilter", value: function(n, i, a) {
          var c = null, g = (n.x - a.x) * (i.y - a.y), m = (n.y - a.y) * (i.x - a.x), y = g - m;
          if (g > 0) {
            if (m <= 0) return o.signum(y);
            c = g + m;
          } else {
            if (!(g < 0) || m >= 0) return o.signum(y);
            c = -g - m;
          }
          var w = o.DP_SAFE_EPSILON * c;
          return y >= w || -y >= w ? o.signum(y) : 2;
        } }, { key: "signum", value: function(n) {
          return n > 0 ? 1 : n < 0 ? -1 : 0;
        } }]);
      })();
      fi.DP_SAFE_EPSILON = 1e-15;
      var Me = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "getM", value: function(o) {
          if (this.hasM()) {
            var n = this.getDimension() - this.getMeasures();
            return this.getOrdinate(o, n);
          }
          return Z.NaN;
        } }, { key: "setOrdinate", value: function(o, n, i) {
        } }, { key: "getZ", value: function(o) {
          return this.hasZ() ? this.getOrdinate(o, 2) : Z.NaN;
        } }, { key: "size", value: function() {
        } }, { key: "getOrdinate", value: function(o, n) {
        } }, { key: "getCoordinate", value: function() {
        } }, { key: "getCoordinateCopy", value: function(o) {
        } }, { key: "createCoordinate", value: function() {
        } }, { key: "getDimension", value: function() {
        } }, { key: "hasM", value: function() {
          return this.getMeasures() > 0;
        } }, { key: "getX", value: function(o) {
        } }, { key: "hasZ", value: function() {
          return this.getDimension() - this.getMeasures() > 2;
        } }, { key: "getMeasures", value: function() {
          return 0;
        } }, { key: "expandEnvelope", value: function(o) {
        } }, { key: "copy", value: function() {
        } }, { key: "getY", value: function(o) {
        } }, { key: "toCoordinateArray", value: function() {
        } }, { key: "interfaces_", get: function() {
          return [x];
        } }]);
      })();
      Me.X = 0, Me.Y = 1, Me.Z = 2, Me.M = 3;
      var ye = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "index", value: function(n, i, a) {
          return fi.orientationIndex(n, i, a);
        } }, { key: "isCCW", value: function() {
          if (arguments[0] instanceof Array) {
            var n = arguments[0], i = n.length - 1;
            if (i < 3) throw new $("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var a = n[0], c = 0, g = 1; g <= i; g++) {
              var m = n[g];
              m.y > a.y && (a = m, c = g);
            }
            var y = c;
            do
              (y -= 1) < 0 && (y = i);
            while (n[y].equals2D(a) && y !== c);
            var w = c;
            do
              w = (w + 1) % i;
            while (n[w].equals2D(a) && w !== c);
            var A = n[y], z = n[w];
            if (A.equals2D(a) || z.equals2D(a) || A.equals2D(z)) return false;
            var V = o.index(A, a, z);
            return V === 0 ? A.x > z.x : V > 0;
          }
          if (Ee(arguments[0], Me)) {
            var ee = arguments[0], ue = ee.size() - 1;
            if (ue < 3) throw new $("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var fe = ee.getCoordinate(0), me = 0, Ae = 1; Ae <= ue; Ae++) {
              var be = ee.getCoordinate(Ae);
              be.y > fe.y && (fe = be, me = Ae);
            }
            var Ge = null, ht = me;
            do
              (ht -= 1) < 0 && (ht = ue), Ge = ee.getCoordinate(ht);
            while (Ge.equals2D(fe) && ht !== me);
            var gt = null, Jr = me;
            do
              Jr = (Jr + 1) % ue, gt = ee.getCoordinate(Jr);
            while (gt.equals2D(fe) && Jr !== me);
            if (Ge.equals2D(fe) || gt.equals2D(fe) || Ge.equals2D(gt)) return false;
            var hs = o.index(Ge, fe, gt);
            return hs === 0 ? Ge.x > gt.x : hs > 0;
          }
        } }]);
      })();
      ye.CLOCKWISE = -1, ye.RIGHT = ye.CLOCKWISE, ye.COUNTERCLOCKWISE = 1, ye.LEFT = ye.COUNTERCLOCKWISE, ye.COLLINEAR = 0, ye.STRAIGHT = ye.COLLINEAR;
      var la = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "getCoordinate", value: function() {
          return this._minCoord;
        } }, { key: "getRightmostSide", value: function(o, n) {
          var i = this.getRightmostSideOfSegment(o, n);
          return i < 0 && (i = this.getRightmostSideOfSegment(o, n - 1)), i < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(o)), i;
        } }, { key: "findRightmostEdgeAtVertex", value: function() {
          var o = this._minDe.getEdge().getCoordinates();
          ae.isTrue(this._minIndex > 0 && this._minIndex < o.length, "rightmost point expected to be interior vertex of edge");
          var n = o[this._minIndex - 1], i = o[this._minIndex + 1], a = ye.index(this._minCoord, i, n), c = false;
          (n.y < this._minCoord.y && i.y < this._minCoord.y && a === ye.COUNTERCLOCKWISE || n.y > this._minCoord.y && i.y > this._minCoord.y && a === ye.CLOCKWISE) && (c = true), c && (this._minIndex = this._minIndex - 1);
        } }, { key: "getRightmostSideOfSegment", value: function(o, n) {
          var i = o.getEdge().getCoordinates();
          if (n < 0 || n + 1 >= i.length || i[n].y === i[n + 1].y) return -1;
          var a = re.LEFT;
          return i[n].y < i[n + 1].y && (a = re.RIGHT), a;
        } }, { key: "getEdge", value: function() {
          return this._orientedDe;
        } }, { key: "checkForRightmostCoordinate", value: function(o) {
          for (var n = o.getEdge().getCoordinates(), i = 0; i < n.length - 1; i++) (this._minCoord === null || n[i].x > this._minCoord.x) && (this._minDe = o, this._minIndex = i, this._minCoord = n[i]);
        } }, { key: "findRightmostEdgeAtNode", value: function() {
          var o = this._minDe.getNode().getEdges();
          this._minDe = o.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
        } }, { key: "findEdge", value: function(o) {
          for (var n = o.iterator(); n.hasNext(); ) {
            var i = n.next();
            i.isForward() && this.checkForRightmostCoordinate(i);
          }
          ae.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === re.LEFT && (this._orientedDe = this._minDe.getSym());
        } }], [{ key: "constructor_", value: function() {
          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
        } }]);
      })(), Nt = (function(o) {
        function n(i, a) {
          var c;
          return u(this, n), (c = s(this, n, [a ? i + " [ " + a + " ]" : i])).pt = a ? new H(a) : void 0, c.name = Object.keys({ TopologyException: n })[0], c;
        }
        return _(n, o), h(n, [{ key: "getCoordinate", value: function() {
          return this.pt;
        } }]);
      })(ge), gi = (function() {
        return h((function o() {
          u(this, o), this.array = [];
        }), [{ key: "addLast", value: function(o) {
          this.array.push(o);
        } }, { key: "removeFirst", value: function() {
          return this.array.shift();
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }]);
      })(), pe = (function(o) {
        function n(i) {
          var a;
          return u(this, n), (a = s(this, n)).array = [], i instanceof Ce && a.addAll(i), a;
        }
        return _(n, o), h(n, [{ key: "interfaces_", get: function() {
          return [An, Ce];
        } }, { key: "ensureCapacity", value: function() {
        } }, { key: "add", value: function(i) {
          return arguments.length === 1 ? this.array.push(i) : this.array.splice(arguments[0], 0, arguments[1]), true;
        } }, { key: "clear", value: function() {
          this.array = [];
        } }, { key: "addAll", value: function(i) {
          var a, c = p(i);
          try {
            for (c.s(); !(a = c.n()).done; ) {
              var g = a.value;
              this.array.push(g);
            }
          } catch (m) {
            c.e(m);
          } finally {
            c.f();
          }
        } }, { key: "set", value: function(i, a) {
          var c = this.array[i];
          return this.array[i] = a, c;
        } }, { key: "iterator", value: function() {
          return new Er(this);
        } }, { key: "get", value: function(i) {
          if (i < 0 || i >= this.size()) throw new rs();
          return this.array[i];
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }, { key: "sort", value: function(i) {
          i ? this.array.sort((function(a, c) {
            return i.compare(a, c);
          })) : this.array.sort();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "remove", value: function(i) {
          for (var a = 0, c = this.array.length; a < c; a++) if (this.array[a] === i) return !!this.array.splice(a, 1);
          return false;
        } }, { key: Symbol.iterator, value: function() {
          return this.array.values();
        } }]);
      })(An), Er = (function() {
        return h((function o(n) {
          u(this, o), this.arrayList = n, this.position = 0;
        }), [{ key: "next", value: function() {
          if (this.position === this.arrayList.size()) throw new De();
          return this.arrayList.get(this.position++);
        } }, { key: "hasNext", value: function() {
          return this.position < this.arrayList.size();
        } }, { key: "set", value: function(o) {
          return this.arrayList.set(this.position - 1, o);
        } }, { key: "remove", value: function() {
          this.arrayList.remove(this.arrayList.get(this.position));
        } }]);
      })(), is = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "clearVisitedEdges", value: function() {
          for (var o = this._dirEdgeList.iterator(); o.hasNext(); )
            o.next().setVisited(false);
        } }, { key: "getRightmostCoordinate", value: function() {
          return this._rightMostCoord;
        } }, { key: "computeNodeDepth", value: function(o) {
          for (var n = null, i = o.getEdges().iterator(); i.hasNext(); ) {
            var a = i.next();
            if (a.isVisited() || a.getSym().isVisited()) {
              n = a;
              break;
            }
          }
          if (n === null) throw new Nt("unable to find edge to compute depths at " + o.getCoordinate());
          o.getEdges().computeDepths(n);
          for (var c = o.getEdges().iterator(); c.hasNext(); ) {
            var g = c.next();
            g.setVisited(true), this.copySymDepths(g);
          }
        } }, { key: "computeDepth", value: function(o) {
          this.clearVisitedEdges();
          var n = this._finder.getEdge();
          n.getNode(), n.getLabel(), n.setEdgeDepths(re.RIGHT, o), this.copySymDepths(n), this.computeDepths(n);
        } }, { key: "create", value: function(o) {
          this.addReachable(o), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
        } }, { key: "findResultEdges", value: function() {
          for (var o = this._dirEdgeList.iterator(); o.hasNext(); ) {
            var n = o.next();
            n.getDepth(re.RIGHT) >= 1 && n.getDepth(re.LEFT) <= 0 && !n.isInteriorAreaEdge() && n.setInResult(true);
          }
        } }, { key: "computeDepths", value: function(o) {
          var n = new Gr(), i = new gi(), a = o.getNode();
          for (i.addLast(a), n.add(a), o.setVisited(true); !i.isEmpty(); ) {
            var c = i.removeFirst();
            n.add(c), this.computeNodeDepth(c);
            for (var g = c.getEdges().iterator(); g.hasNext(); ) {
              var m = g.next().getSym();
              if (!m.isVisited()) {
                var y = m.getNode();
                n.contains(y) || (i.addLast(y), n.add(y));
              }
            }
          }
        } }, { key: "compareTo", value: function(o) {
          var n = o;
          return this._rightMostCoord.x < n._rightMostCoord.x ? -1 : this._rightMostCoord.x > n._rightMostCoord.x ? 1 : 0;
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            for (var o = new Ie(), n = this._dirEdgeList.iterator(); n.hasNext(); ) for (var i = n.next().getEdge().getCoordinates(), a = 0; a < i.length - 1; a++) o.expandToInclude(i[a]);
            this._env = o;
          }
          return this._env;
        } }, { key: "addReachable", value: function(o) {
          var n = new Po();
          for (n.add(o); !n.empty(); ) {
            var i = n.pop();
            this.add(i, n);
          }
        } }, { key: "copySymDepths", value: function(o) {
          var n = o.getSym();
          n.setDepth(re.LEFT, o.getDepth(re.RIGHT)), n.setDepth(re.RIGHT, o.getDepth(re.LEFT));
        } }, { key: "add", value: function(o, n) {
          o.setVisited(true), this._nodes.add(o);
          for (var i = o.getEdges().iterator(); i.hasNext(); ) {
            var a = i.next();
            this._dirEdgeList.add(a);
            var c = a.getSym().getNode();
            c.isVisited() || n.push(c);
          }
        } }, { key: "getNodes", value: function() {
          return this._nodes;
        } }, { key: "getDirectedEdges", value: function() {
          return this._dirEdgeList;
        } }, { key: "interfaces_", get: function() {
          return [j];
        } }], [{ key: "constructor_", value: function() {
          this._finder = null, this._dirEdgeList = new pe(), this._nodes = new pe(), this._rightMostCoord = null, this._env = null, this._finder = new la();
        } }]);
      })(), Ur = (function() {
        return h((function o() {
          u(this, o);
        }), null, [{ key: "intersection", value: function(o, n, i, a) {
          var c = o.x < n.x ? o.x : n.x, g = o.y < n.y ? o.y : n.y, m = o.x > n.x ? o.x : n.x, y = o.y > n.y ? o.y : n.y, w = i.x < a.x ? i.x : a.x, A = i.y < a.y ? i.y : a.y, z = i.x > a.x ? i.x : a.x, V = i.y > a.y ? i.y : a.y, ee = ((c > w ? c : w) + (m < z ? m : z)) / 2, ue = ((g > A ? g : A) + (y < V ? y : V)) / 2, fe = o.x - ee, me = o.y - ue, Ae = n.x - ee, be = n.y - ue, Ge = i.x - ee, ht = i.y - ue, gt = a.x - ee, Jr = a.y - ue, hs = me - be, Dc = Ae - fe, Fc = fe * be - Ae * me, Gc = ht - Jr, Bc = gt - Ge, Uc = Ge * Jr - gt * ht, zc = hs * Bc - Gc * Dc, Ho = (Dc * Uc - Bc * Fc) / zc, Jo = (Gc * Fc - hs * Uc) / zc;
          return Z.isNaN(Ho) || Z.isInfinite(Ho) || Z.isNaN(Jo) || Z.isInfinite(Jo) ? null : new H(Ho + ee, Jo + ue);
        } }]);
      })(), Pt = (function() {
        return h((function o() {
          u(this, o);
        }), null, [{ key: "arraycopy", value: function(o, n, i, a, c) {
          for (var g = 0, m = n; m < n + c; m++) i[a + g] = o[m], g++;
        } }, { key: "getProperty", value: function(o) {
          return { "line.separator": `
` }[o];
        } }]);
      })(), Ln = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "log10", value: function(n) {
          var i = Math.log(n);
          return Z.isInfinite(i) || Z.isNaN(i) ? i : i / o.LOG_10;
        } }, { key: "min", value: function(n, i, a, c) {
          var g = n;
          return i < g && (g = i), a < g && (g = a), c < g && (g = c), g;
        } }, { key: "clamp", value: function() {
          if (typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var n = arguments[0], i = arguments[1], a = arguments[2];
            return n < i ? i : n > a ? a : n;
          }
          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var c = arguments[0], g = arguments[1], m = arguments[2];
            return c < g ? g : c > m ? m : c;
          }
        } }, { key: "wrap", value: function(n, i) {
          return n < 0 ? i - -n % i : n % i;
        } }, { key: "max", value: function() {
          if (arguments.length === 3) {
            var n = arguments[1], i = arguments[2], a = arguments[0];
            return n > a && (a = n), i > a && (a = i), a;
          }
          if (arguments.length === 4) {
            var c = arguments[1], g = arguments[2], m = arguments[3], y = arguments[0];
            return c > y && (y = c), g > y && (y = g), m > y && (y = m), y;
          }
        } }, { key: "average", value: function(n, i) {
          return (n + i) / 2;
        } }]);
      })();
      Ln.LOG_10 = Math.log(10);
      var Et = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "segmentToSegment", value: function(n, i, a, c) {
          if (n.equals(i)) return o.pointToSegment(n, a, c);
          if (a.equals(c)) return o.pointToSegment(c, n, i);
          var g = false;
          if (Ie.intersects(n, i, a, c)) {
            var m = (i.x - n.x) * (c.y - a.y) - (i.y - n.y) * (c.x - a.x);
            if (m === 0) g = true;
            else {
              var y = (n.y - a.y) * (c.x - a.x) - (n.x - a.x) * (c.y - a.y), w = ((n.y - a.y) * (i.x - n.x) - (n.x - a.x) * (i.y - n.y)) / m, A = y / m;
              (A < 0 || A > 1 || w < 0 || w > 1) && (g = true);
            }
          } else g = true;
          return g ? Ln.min(o.pointToSegment(n, a, c), o.pointToSegment(i, a, c), o.pointToSegment(a, n, i), o.pointToSegment(c, n, i)) : 0;
        } }, { key: "pointToSegment", value: function(n, i, a) {
          if (i.x === a.x && i.y === a.y) return n.distance(i);
          var c = (a.x - i.x) * (a.x - i.x) + (a.y - i.y) * (a.y - i.y), g = ((n.x - i.x) * (a.x - i.x) + (n.y - i.y) * (a.y - i.y)) / c;
          if (g <= 0) return n.distance(i);
          if (g >= 1) return n.distance(a);
          var m = ((i.y - n.y) * (a.x - i.x) - (i.x - n.x) * (a.y - i.y)) / c;
          return Math.abs(m) * Math.sqrt(c);
        } }, { key: "pointToLinePerpendicular", value: function(n, i, a) {
          var c = (a.x - i.x) * (a.x - i.x) + (a.y - i.y) * (a.y - i.y), g = ((i.y - n.y) * (a.x - i.x) - (i.x - n.x) * (a.y - i.y)) / c;
          return Math.abs(g) * Math.sqrt(c);
        } }, { key: "pointToSegmentString", value: function(n, i) {
          if (i.length === 0) throw new $("Line array must contain at least one vertex");
          for (var a = n.distance(i[0]), c = 0; c < i.length - 1; c++) {
            var g = o.pointToSegment(n, i[c], i[c + 1]);
            g < a && (a = g);
          }
          return a;
        } }]);
      })(), ca = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "create", value: function() {
          if (arguments.length === 1) arguments[0] instanceof Array || Ee(arguments[0], Me);
          else if (arguments.length !== 2) {
            if (arguments.length === 3) {
              var o = arguments[0], n = arguments[1];
              return this.create(o, n);
            }
          }
        } }]);
      })(), Tn = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "filter", value: function(o) {
        } }]);
      })(), Oo = (function() {
        return h((function o() {
          u(this, o);
        }), null, [{ key: "ofLine", value: function(o) {
          var n = o.size();
          if (n <= 1) return 0;
          var i = 0, a = new H();
          o.getCoordinate(0, a);
          for (var c = a.x, g = a.y, m = 1; m < n; m++) {
            o.getCoordinate(m, a);
            var y = a.x, w = a.y, A = y - c, z = w - g;
            i += Math.sqrt(A * A + z * z), c = y, g = w;
          }
          return i;
        } }]);
      })(), ha = h((function o() {
        u(this, o);
      })), Fe = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "copyCoord", value: function(n, i, a, c) {
          for (var g = Math.min(n.getDimension(), a.getDimension()), m = 0; m < g; m++) a.setOrdinate(c, m, n.getOrdinate(i, m));
        } }, { key: "isRing", value: function(n) {
          var i = n.size();
          return i === 0 || !(i <= 3) && n.getOrdinate(0, Me.X) === n.getOrdinate(i - 1, Me.X) && n.getOrdinate(0, Me.Y) === n.getOrdinate(i - 1, Me.Y);
        } }, { key: "scroll", value: function() {
          if (arguments.length === 2) {
            if (Ee(arguments[0], Me) && Number.isInteger(arguments[1])) {
              var n = arguments[0], i = arguments[1];
              o.scroll(n, i, o.isRing(n));
            } else if (Ee(arguments[0], Me) && arguments[1] instanceof H) {
              var a = arguments[0], c = arguments[1], g = o.indexOf(c, a);
              if (g <= 0) return null;
              o.scroll(a, g);
            }
          } else if (arguments.length === 3) {
            var m = arguments[0], y = arguments[1], w = arguments[2];
            if (y <= 0) return null;
            for (var A = m.copy(), z = w ? m.size() - 1 : m.size(), V = 0; V < z; V++) for (var ee = 0; ee < m.getDimension(); ee++) m.setOrdinate(V, ee, A.getOrdinate((y + V) % z, ee));
            if (w) for (var ue = 0; ue < m.getDimension(); ue++) m.setOrdinate(z, ue, m.getOrdinate(0, ue));
          }
        } }, { key: "isEqual", value: function(n, i) {
          var a = n.size();
          if (a !== i.size()) return false;
          for (var c = Math.min(n.getDimension(), i.getDimension()), g = 0; g < a; g++) for (var m = 0; m < c; m++) {
            var y = n.getOrdinate(g, m), w = i.getOrdinate(g, m);
            if (n.getOrdinate(g, m) !== i.getOrdinate(g, m) && (!Z.isNaN(y) || !Z.isNaN(w))) return false;
          }
          return true;
        } }, { key: "minCoordinateIndex", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            return o.minCoordinateIndex(n, 0, n.size() - 1);
          }
          if (arguments.length === 3) {
            for (var i = arguments[0], a = arguments[2], c = -1, g = null, m = arguments[1]; m <= a; m++) {
              var y = i.getCoordinate(m);
              (g === null || g.compareTo(y) > 0) && (g = y, c = m);
            }
            return c;
          }
        } }, { key: "extend", value: function(n, i, a) {
          var c = n.create(a, i.getDimension()), g = i.size();
          if (o.copy(i, 0, c, 0, g), g > 0) for (var m = g; m < a; m++) o.copy(i, g - 1, c, m, 1);
          return c;
        } }, { key: "reverse", value: function(n) {
          for (var i = n.size() - 1, a = Math.trunc(i / 2), c = 0; c <= a; c++) o.swap(n, c, i - c);
        } }, { key: "swap", value: function(n, i, a) {
          if (i === a) return null;
          for (var c = 0; c < n.getDimension(); c++) {
            var g = n.getOrdinate(i, c);
            n.setOrdinate(i, c, n.getOrdinate(a, c)), n.setOrdinate(a, c, g);
          }
        } }, { key: "copy", value: function(n, i, a, c, g) {
          for (var m = 0; m < g; m++) o.copyCoord(n, i + m, a, c + m);
        } }, { key: "ensureValidRing", value: function(n, i) {
          var a = i.size();
          return a === 0 ? i : a <= 3 ? o.createClosedRing(n, i, 4) : i.getOrdinate(0, Me.X) === i.getOrdinate(a - 1, Me.X) && i.getOrdinate(0, Me.Y) === i.getOrdinate(a - 1, Me.Y) ? i : o.createClosedRing(n, i, a + 1);
        } }, { key: "indexOf", value: function(n, i) {
          for (var a = 0; a < i.size(); a++) if (n.x === i.getOrdinate(a, Me.X) && n.y === i.getOrdinate(a, Me.Y)) return a;
          return -1;
        } }, { key: "createClosedRing", value: function(n, i, a) {
          var c = n.create(a, i.getDimension()), g = i.size();
          o.copy(i, 0, c, 0, g);
          for (var m = g; m < a; m++) o.copy(i, 0, c, m, 1);
          return c;
        } }, { key: "minCoordinate", value: function(n) {
          for (var i = null, a = 0; a < n.size(); a++) {
            var c = n.getCoordinate(a);
            (i === null || i.compareTo(c) > 0) && (i = c);
          }
          return i;
        } }]);
      })(), ie = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "toDimensionSymbol", value: function(n) {
          switch (n) {
            case o.FALSE:
              return o.SYM_FALSE;
            case o.TRUE:
              return o.SYM_TRUE;
            case o.DONTCARE:
              return o.SYM_DONTCARE;
            case o.P:
              return o.SYM_P;
            case o.L:
              return o.SYM_L;
            case o.A:
              return o.SYM_A;
          }
          throw new $("Unknown dimension value: " + n);
        } }, { key: "toDimensionValue", value: function(n) {
          switch (Ct.toUpperCase(n)) {
            case o.SYM_FALSE:
              return o.FALSE;
            case o.SYM_TRUE:
              return o.TRUE;
            case o.SYM_DONTCARE:
              return o.DONTCARE;
            case o.SYM_P:
              return o.P;
            case o.SYM_L:
              return o.L;
            case o.SYM_A:
              return o.A;
          }
          throw new $("Unknown dimension symbol: " + n);
        } }]);
      })();
      ie.P = 0, ie.L = 1, ie.A = 2, ie.FALSE = -1, ie.TRUE = -2, ie.DONTCARE = -3, ie.SYM_FALSE = "F", ie.SYM_TRUE = "T", ie.SYM_DONTCARE = "*", ie.SYM_P = "0", ie.SYM_L = "1", ie.SYM_A = "2";
      var di = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "filter", value: function(o) {
        } }]);
      })(), zr = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "filter", value: function(o, n) {
        } }, { key: "isDone", value: function() {
        } }, { key: "isGeometryChanged", value: function() {
        } }]);
      })(), Zn = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "computeEnvelopeInternal", value: function() {
          return this.isEmpty() ? new Ie() : this._points.expandEnvelope(new Ie());
        } }, { key: "isRing", value: function() {
          return this.isClosed() && this.isSimple();
        } }, { key: "getCoordinates", value: function() {
          return this._points.toCoordinateArray();
        } }, { key: "copyInternal", value: function() {
          return new n(this._points.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof ce) {
            var i = arguments[0], a = arguments[1];
            if (!this.isEquivalentClass(i)) return false;
            var c = i;
            if (this._points.size() !== c._points.size()) return false;
            for (var g = 0; g < this._points.size(); g++) if (!this.equal(this._points.getCoordinate(g), c._points.getCoordinate(g), a)) return false;
            return true;
          }
          return I(n, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {
            var a = this._points.size() - 1 - i;
            if (!this._points.getCoordinate(i).equals(this._points.getCoordinate(a))) {
              if (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(a)) > 0) {
                var c = this._points.copy();
                Fe.reverse(c), this._points = c;
              }
              return null;
            }
          }
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._points.getCoordinate(0);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? ie.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
        } }, { key: "reverseInternal", value: function() {
          var i = this._points.copy();
          return Fe.reverse(i), this.getFactory().createLineString(i);
        } }, { key: "getEndPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
        } }, { key: "getTypeCode", value: function() {
          return ce.TYPECODE_LINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getLength", value: function() {
          return Oo.ofLine(this._points);
        } }, { key: "getNumPoints", value: function() {
          return this._points.size();
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            for (var i = arguments[0], a = 0, c = 0; a < this._points.size() && c < i._points.size(); ) {
              var g = this._points.getCoordinate(a).compareTo(i._points.getCoordinate(c));
              if (g !== 0) return g;
              a++, c++;
            }
            return a < this._points.size() ? 1 : c < i._points.size() ? -1 : 0;
          }
          if (arguments.length === 2) {
            var m = arguments[0];
            return arguments[1].compare(this._points, m._points);
          }
        } }, { key: "apply", value: function() {
          if (Ee(arguments[0], Tn)) for (var i = arguments[0], a = 0; a < this._points.size(); a++) i.filter(this._points.getCoordinate(a));
          else if (Ee(arguments[0], zr)) {
            var c = arguments[0];
            if (this._points.size() === 0) return null;
            for (var g = 0; g < this._points.size() && (c.filter(this._points, g), !c.isDone()); g++) ;
            c.isGeometryChanged() && this.geometryChanged();
          } else Ee(arguments[0], di) ? arguments[0].filter(this) : Ee(arguments[0], Y) && arguments[0].filter(this);
        } }, { key: "getBoundary", value: function() {
          throw new ke();
        } }, { key: "isEquivalentClass", value: function(i) {
          return i instanceof n;
        } }, { key: "getCoordinateN", value: function(i) {
          return this._points.getCoordinate(i);
        } }, { key: "getGeometryType", value: function() {
          return ce.TYPENAME_LINESTRING;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._points;
        } }, { key: "isEmpty", value: function() {
          return this._points.size() === 0;
        } }, { key: "init", value: function(i) {
          if (i === null && (i = this.getFactory().getCoordinateSequenceFactory().create([])), i.size() === 1) throw new $("Invalid number of points in LineString (found " + i.size() + " - must be 0 or >= 2)");
          this._points = i;
        } }, { key: "isCoordinate", value: function(i) {
          for (var a = 0; a < this._points.size(); a++) if (this._points.getCoordinate(a).equals(i)) return true;
          return false;
        } }, { key: "getStartPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(0);
        } }, { key: "getPointN", value: function(i) {
          return this.getFactory().createPoint(this._points.getCoordinate(i));
        } }, { key: "interfaces_", get: function() {
          return [ha];
        } }], [{ key: "constructor_", value: function() {
          if (this._points = null, arguments.length !== 0) {
            if (arguments.length === 2) {
              var i = arguments[0], a = arguments[1];
              ce.constructor_.call(this, a), this.init(i);
            }
          }
        } }]);
      })(ce), ss = h((function o() {
        u(this, o);
      })), pi = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "computeEnvelopeInternal", value: function() {
          if (this.isEmpty()) return new Ie();
          var i = new Ie();
          return i.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), i;
        } }, { key: "getCoordinates", value: function() {
          return this.isEmpty() ? [] : [this.getCoordinate()];
        } }, { key: "copyInternal", value: function() {
          return new n(this._coordinates.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof ce) {
            var i = arguments[0], a = arguments[1];
            return !!this.isEquivalentClass(i) && (!(!this.isEmpty() || !i.isEmpty()) || this.isEmpty() === i.isEmpty() && this.equal(i.getCoordinate(), this.getCoordinate(), a));
          }
          return I(n, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
        } }, { key: "getCoordinate", value: function() {
          return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
        } }, { key: "getBoundaryDimension", value: function() {
          return ie.FALSE;
        } }, { key: "reverseInternal", value: function() {
          return this.getFactory().createPoint(this._coordinates.copy());
        } }, { key: "getTypeCode", value: function() {
          return ce.TYPECODE_POINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getNumPoints", value: function() {
          return this.isEmpty() ? 0 : 1;
        } }, { key: "getX", value: function() {
          if (this.getCoordinate() === null) throw new IllegalStateException("getX called on empty Point");
          return this.getCoordinate().x;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var i = arguments[0];
            return this.getCoordinate().compareTo(i.getCoordinate());
          }
          if (arguments.length === 2) {
            var a = arguments[0];
            return arguments[1].compare(this._coordinates, a._coordinates);
          }
        } }, { key: "apply", value: function() {
          if (Ee(arguments[0], Tn)) {
            var i = arguments[0];
            if (this.isEmpty()) return null;
            i.filter(this.getCoordinate());
          } else if (Ee(arguments[0], zr)) {
            var a = arguments[0];
            if (this.isEmpty()) return null;
            a.filter(this._coordinates, 0), a.isGeometryChanged() && this.geometryChanged();
          } else Ee(arguments[0], di) ? arguments[0].filter(this) : Ee(arguments[0], Y) && arguments[0].filter(this);
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return ce.TYPENAME_POINT;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._coordinates;
        } }, { key: "getY", value: function() {
          if (this.getCoordinate() === null) throw new IllegalStateException("getY called on empty Point");
          return this.getCoordinate().y;
        } }, { key: "isEmpty", value: function() {
          return this._coordinates.size() === 0;
        } }, { key: "init", value: function(i) {
          i === null && (i = this.getFactory().getCoordinateSequenceFactory().create([])), ae.isTrue(i.size() <= 1), this._coordinates = i;
        } }, { key: "isSimple", value: function() {
          return true;
        } }, { key: "interfaces_", get: function() {
          return [ss];
        } }], [{ key: "constructor_", value: function() {
          this._coordinates = null;
          var i = arguments[0], a = arguments[1];
          ce.constructor_.call(this, a), this.init(i);
        } }]);
      })(ce), fa = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "ofRing", value: function() {
          if (arguments[0] instanceof Array) {
            var n = arguments[0];
            return Math.abs(o.ofRingSigned(n));
          }
          if (Ee(arguments[0], Me)) {
            var i = arguments[0];
            return Math.abs(o.ofRingSigned(i));
          }
        } }, { key: "ofRingSigned", value: function() {
          if (arguments[0] instanceof Array) {
            var n = arguments[0];
            if (n.length < 3) return 0;
            for (var i = 0, a = n[0].x, c = 1; c < n.length - 1; c++) {
              var g = n[c].x - a, m = n[c + 1].y;
              i += g * (n[c - 1].y - m);
            }
            return i / 2;
          }
          if (Ee(arguments[0], Me)) {
            var y = arguments[0], w = y.size();
            if (w < 3) return 0;
            var A = new H(), z = new H(), V = new H();
            y.getCoordinate(0, z), y.getCoordinate(1, V);
            var ee = z.x;
            V.x -= ee;
            for (var ue = 0, fe = 1; fe < w - 1; fe++) A.y = z.y, z.x = V.x, z.y = V.y, y.getCoordinate(fe + 1, V), V.x -= ee, ue += z.x * (A.y - V.y);
            return ue / 2;
          }
        } }]);
      })(), rt = (function() {
        return h((function o() {
          u(this, o);
        }), null, [{ key: "sort", value: function() {
          var o = arguments, n = arguments[0];
          if (arguments.length === 1) n.sort((function(ee, ue) {
            return ee.compareTo(ue);
          }));
          else if (arguments.length === 2) n.sort((function(ee, ue) {
            return o[1].compare(ee, ue);
          }));
          else if (arguments.length === 3) {
            var i = n.slice(arguments[1], arguments[2]);
            i.sort();
            var a = n.slice(0, arguments[1]).concat(i, n.slice(arguments[2], n.length));
            n.splice(0, n.length);
            var c, g = p(a);
            try {
              for (g.s(); !(c = g.n()).done; ) {
                var m = c.value;
                n.push(m);
              }
            } catch (ee) {
              g.e(ee);
            } finally {
              g.f();
            }
          } else if (arguments.length === 4) {
            var y = n.slice(arguments[1], arguments[2]);
            y.sort((function(ee, ue) {
              return o[3].compare(ee, ue);
            }));
            var w = n.slice(0, arguments[1]).concat(y, n.slice(arguments[2], n.length));
            n.splice(0, n.length);
            var A, z = p(w);
            try {
              for (z.s(); !(A = z.n()).done; ) {
                var V = A.value;
                n.push(V);
              }
            } catch (ee) {
              z.e(ee);
            } finally {
              z.f();
            }
          }
        } }, { key: "asList", value: function(o) {
          var n, i = new pe(), a = p(o);
          try {
            for (a.s(); !(n = a.n()).done; ) {
              var c = n.value;
              i.add(c);
            }
          } catch (g) {
            a.e(g);
          } finally {
            a.f();
          }
          return i;
        } }, { key: "copyOf", value: function(o, n) {
          return o.slice(0, n);
        } }]);
      })(), Cn = h((function o() {
        u(this, o);
      })), qr = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "computeEnvelopeInternal", value: function() {
          return this._shell.getEnvelopeInternal();
        } }, { key: "getCoordinates", value: function() {
          if (this.isEmpty()) return [];
          for (var i = new Array(this.getNumPoints()).fill(null), a = -1, c = this._shell.getCoordinates(), g = 0; g < c.length; g++) i[++a] = c[g];
          for (var m = 0; m < this._holes.length; m++) for (var y = this._holes[m].getCoordinates(), w = 0; w < y.length; w++) i[++a] = y[w];
          return i;
        } }, { key: "getArea", value: function() {
          var i = 0;
          i += fa.ofRing(this._shell.getCoordinateSequence());
          for (var a = 0; a < this._holes.length; a++) i -= fa.ofRing(this._holes[a].getCoordinateSequence());
          return i;
        } }, { key: "copyInternal", value: function() {
          for (var i = this._shell.copy(), a = new Array(this._holes.length).fill(null), c = 0; c < this._holes.length; c++) a[c] = this._holes[c].copy();
          return new n(i, a, this._factory);
        } }, { key: "isRectangle", value: function() {
          if (this.getNumInteriorRing() !== 0 || this._shell === null || this._shell.getNumPoints() !== 5) return false;
          for (var i = this._shell.getCoordinateSequence(), a = this.getEnvelopeInternal(), c = 0; c < 5; c++) {
            var g = i.getX(c);
            if (g !== a.getMinX() && g !== a.getMaxX()) return false;
            var m = i.getY(c);
            if (m !== a.getMinY() && m !== a.getMaxY()) return false;
          }
          for (var y = i.getX(0), w = i.getY(0), A = 1; A <= 4; A++) {
            var z = i.getX(A), V = i.getY(A);
            if (z !== y == (V !== w)) return false;
            y = z, w = V;
          }
          return true;
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof ce) {
            var i = arguments[0], a = arguments[1];
            if (!this.isEquivalentClass(i)) return false;
            var c = i, g = this._shell, m = c._shell;
            if (!g.equalsExact(m, a) || this._holes.length !== c._holes.length) return false;
            for (var y = 0; y < this._holes.length; y++) if (!this._holes[y].equalsExact(c._holes[y], a)) return false;
            return true;
          }
          return I(n, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          if (arguments.length === 0) {
            this._shell = this.normalized(this._shell, true);
            for (var i = 0; i < this._holes.length; i++) this._holes[i] = this.normalized(this._holes[i], false);
            rt.sort(this._holes);
          } else if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            if (a.isEmpty()) return null;
            var g = a.getCoordinateSequence(), m = Fe.minCoordinateIndex(g, 0, g.size() - 2);
            Fe.scroll(g, m, true), ye.isCCW(g) === c && Fe.reverse(g);
          }
        } }, { key: "getCoordinate", value: function() {
          return this._shell.getCoordinate();
        } }, { key: "getNumInteriorRing", value: function() {
          return this._holes.length;
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "reverseInternal", value: function() {
          for (var i = this.getExteriorRing().reverse(), a = new Array(this.getNumInteriorRing()).fill(null), c = 0; c < a.length; c++) a[c] = this.getInteriorRingN(c).reverse();
          return this.getFactory().createPolygon(i, a);
        } }, { key: "getTypeCode", value: function() {
          return ce.TYPECODE_POLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getLength", value: function() {
          var i = 0;
          i += this._shell.getLength();
          for (var a = 0; a < this._holes.length; a++) i += this._holes[a].getLength();
          return i;
        } }, { key: "getNumPoints", value: function() {
          for (var i = this._shell.getNumPoints(), a = 0; a < this._holes.length; a++) i += this._holes[a].getNumPoints();
          return i;
        } }, { key: "convexHull", value: function() {
          return this.getExteriorRing().convexHull();
        } }, { key: "normalized", value: function(i, a) {
          var c = i.copy();
          return this.normalize(c, a), c;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var i = arguments[0], a = this._shell, c = i._shell;
            return a.compareToSameClass(c);
          }
          if (arguments.length === 2) {
            var g = arguments[1], m = arguments[0], y = this._shell, w = m._shell, A = y.compareToSameClass(w, g);
            if (A !== 0) return A;
            for (var z = this.getNumInteriorRing(), V = m.getNumInteriorRing(), ee = 0; ee < z && ee < V; ) {
              var ue = this.getInteriorRingN(ee), fe = m.getInteriorRingN(ee), me = ue.compareToSameClass(fe, g);
              if (me !== 0) return me;
              ee++;
            }
            return ee < z ? 1 : ee < V ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (Ee(arguments[0], Tn)) {
            var i = arguments[0];
            this._shell.apply(i);
            for (var a = 0; a < this._holes.length; a++) this._holes[a].apply(i);
          } else if (Ee(arguments[0], zr)) {
            var c = arguments[0];
            if (this._shell.apply(c), !c.isDone()) for (var g = 0; g < this._holes.length && (this._holes[g].apply(c), !c.isDone()); g++) ;
            c.isGeometryChanged() && this.geometryChanged();
          } else if (Ee(arguments[0], di))
            arguments[0].filter(this);
          else if (Ee(arguments[0], Y)) {
            var m = arguments[0];
            m.filter(this), this._shell.apply(m);
            for (var y = 0; y < this._holes.length; y++) this._holes[y].apply(m);
          }
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          var i = new Array(this._holes.length + 1).fill(null);
          i[0] = this._shell;
          for (var a = 0; a < this._holes.length; a++) i[a + 1] = this._holes[a];
          return i.length <= 1 ? this.getFactory().createLinearRing(i[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(i);
        } }, { key: "getGeometryType", value: function() {
          return ce.TYPENAME_POLYGON;
        } }, { key: "getExteriorRing", value: function() {
          return this._shell;
        } }, { key: "isEmpty", value: function() {
          return this._shell.isEmpty();
        } }, { key: "getInteriorRingN", value: function(i) {
          return this._holes[i];
        } }, { key: "interfaces_", get: function() {
          return [Cn];
        } }], [{ key: "constructor_", value: function() {
          this._shell = null, this._holes = null;
          var i = arguments[0], a = arguments[1], c = arguments[2];
          if (ce.constructor_.call(this, c), i === null && (i = this.getFactory().createLinearRing()), a === null && (a = []), ce.hasNullElements(a)) throw new $("holes must not contain null elements");
          if (i.isEmpty() && ce.hasNonEmptyElements(a)) throw new $("shell is empty but holes are not");
          this._shell = i, this._holes = a;
        } }]);
      })(ce), ga = (function(o) {
        function n() {
          return u(this, n), s(this, n, arguments);
        }
        return _(n, o), h(n);
      })(hi), mi = (function(o) {
        function n(i) {
          var a;
          return u(this, n), (a = s(this, n)).array = [], i instanceof Ce && a.addAll(i), a;
        }
        return _(n, o), h(n, [{ key: "contains", value: function(i) {
          var a, c = p(this.array);
          try {
            for (c.s(); !(a = c.n()).done; )
              if (a.value.compareTo(i) === 0) return true;
          } catch (g) {
            c.e(g);
          } finally {
            c.f();
          }
          return false;
        } }, { key: "add", value: function(i) {
          if (this.contains(i)) return false;
          for (var a = 0, c = this.array.length; a < c; a++)
            if (this.array[a].compareTo(i) === 1) return !!this.array.splice(a, 0, i);
          return this.array.push(i), true;
        } }, { key: "addAll", value: function(i) {
          var a, c = p(i);
          try {
            for (c.s(); !(a = c.n()).done; ) {
              var g = a.value;
              this.add(g);
            }
          } catch (m) {
            c.e(m);
          } finally {
            c.f();
          }
          return true;
        } }, { key: "remove", value: function() {
          throw new ke();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "iterator", value: function() {
          return new da(this.array);
        } }]);
      })(ga), da = (function() {
        return h((function o(n) {
          u(this, o), this.array = n, this.position = 0;
        }), [{ key: "next", value: function() {
          if (this.position === this.array.length) throw new De();
          return this.array[this.position++];
        } }, { key: "hasNext", value: function() {
          return this.position < this.array.length;
        } }, { key: "remove", value: function() {
          throw new ke();
        } }]);
      })(), Ve = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "computeEnvelopeInternal", value: function() {
          for (var i = new Ie(), a = 0; a < this._geometries.length; a++) i.expandToInclude(this._geometries[a].getEnvelopeInternal());
          return i;
        } }, { key: "getGeometryN", value: function(i) {
          return this._geometries[i];
        } }, { key: "getCoordinates", value: function() {
          for (var i = new Array(this.getNumPoints()).fill(null), a = -1, c = 0; c < this._geometries.length; c++) for (var g = this._geometries[c].getCoordinates(), m = 0; m < g.length; m++) i[++a] = g[m];
          return i;
        } }, { key: "getArea", value: function() {
          for (var i = 0, a = 0; a < this._geometries.length; a++) i += this._geometries[a].getArea();
          return i;
        } }, { key: "copyInternal", value: function() {
          for (var i = new Array(this._geometries.length).fill(null), a = 0; a < i.length; a++) i[a] = this._geometries[a].copy();
          return new n(i, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof ce) {
            var i = arguments[0], a = arguments[1];
            if (!this.isEquivalentClass(i)) return false;
            var c = i;
            if (this._geometries.length !== c._geometries.length) return false;
            for (var g = 0; g < this._geometries.length; g++) if (!this._geometries[g].equalsExact(c._geometries[g], a)) return false;
            return true;
          }
          return I(n, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var i = 0; i < this._geometries.length; i++) this._geometries[i].normalize();
          rt.sort(this._geometries);
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._geometries[0].getCoordinate();
        } }, { key: "getBoundaryDimension", value: function() {
          for (var i = ie.FALSE, a = 0; a < this._geometries.length; a++) i = Math.max(i, this._geometries[a].getBoundaryDimension());
          return i;
        } }, { key: "reverseInternal", value: function() {
          for (var i = this._geometries.length, a = new pe(i), c = 0; c < i; c++) a.add(this._geometries[c].reverse());
          return this.getFactory().buildGeometry(a);
        } }, { key: "getTypeCode", value: function() {
          return ce.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getDimension", value: function() {
          for (var i = ie.FALSE, a = 0; a < this._geometries.length; a++) i = Math.max(i, this._geometries[a].getDimension());
          return i;
        } }, { key: "getLength", value: function() {
          for (var i = 0, a = 0; a < this._geometries.length; a++) i += this._geometries[a].getLength();
          return i;
        } }, { key: "getNumPoints", value: function() {
          for (var i = 0, a = 0; a < this._geometries.length; a++) i += this._geometries[a].getNumPoints();
          return i;
        } }, { key: "getNumGeometries", value: function() {
          return this._geometries.length;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var i = arguments[0], a = new mi(rt.asList(this._geometries)), c = new mi(rt.asList(i._geometries));
            return this.compare(a, c);
          }
          if (arguments.length === 2) {
            for (var g = arguments[1], m = arguments[0], y = this.getNumGeometries(), w = m.getNumGeometries(), A = 0; A < y && A < w; ) {
              var z = this.getGeometryN(A), V = m.getGeometryN(A), ee = z.compareToSameClass(V, g);
              if (ee !== 0) return ee;
              A++;
            }
            return A < y ? 1 : A < w ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (Ee(arguments[0], Tn)) for (var i = arguments[0], a = 0; a < this._geometries.length; a++) this._geometries[a].apply(i);
          else if (Ee(arguments[0], zr)) {
            var c = arguments[0];
            if (this._geometries.length === 0) return null;
            for (var g = 0; g < this._geometries.length && (this._geometries[g].apply(c), !c.isDone()); g++) ;
            c.isGeometryChanged() && this.geometryChanged();
          } else if (Ee(arguments[0], di)) {
            var m = arguments[0];
            m.filter(this);
            for (var y = 0; y < this._geometries.length; y++) this._geometries[y].apply(m);
          } else if (Ee(arguments[0], Y)) {
            var w = arguments[0];
            w.filter(this);
            for (var A = 0; A < this._geometries.length; A++) this._geometries[A].apply(w);
          }
        } }, { key: "getBoundary", value: function() {
          return ce.checkNotGeometryCollection(this), ae.shouldNeverReachHere(), null;
        } }, { key: "getGeometryType", value: function() {
          return ce.TYPENAME_GEOMETRYCOLLECTION;
        } }, { key: "isEmpty", value: function() {
          for (var i = 0; i < this._geometries.length; i++) if (!this._geometries[i].isEmpty()) return false;
          return true;
        } }], [{ key: "constructor_", value: function() {
          if (this._geometries = null, arguments.length !== 0) {
            if (arguments.length === 2) {
              var i = arguments[0], a = arguments[1];
              if (ce.constructor_.call(this, a), i === null && (i = []), ce.hasNullElements(i)) throw new $("geometries must not contain null elements");
              this._geometries = i;
            }
          }
        } }]);
      })(ce), vi = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "copyInternal", value: function() {
          for (var i = new Array(this._geometries.length).fill(null), a = 0; a < i.length; a++) i[a] = this._geometries[a].copy();
          return new n(i, this._factory);
        } }, { key: "isValid", value: function() {
          return true;
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof ce) {
            var i = arguments[0], a = arguments[1];
            return !!this.isEquivalentClass(i) && I(n, "equalsExact", this, 1).call(this, i, a);
          }
          return I(n, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 1 && Number.isInteger(arguments[0])) {
            var i = arguments[0];
            return this._geometries[i].getCoordinate();
          }
          return I(n, "getCoordinate", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return ie.FALSE;
        } }, { key: "getTypeCode", value: function() {
          return ce.TYPECODE_MULTIPOINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return ce.TYPENAME_MULTIPOINT;
        } }, { key: "interfaces_", get: function() {
          return [ss];
        } }], [{ key: "constructor_", value: function() {
          var i = arguments[0], a = arguments[1];
          Ve.constructor_.call(this, i, a);
        } }]);
      })(Ve), xr = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "copyInternal", value: function() {
          return new n(this._points.copy(), this._factory);
        } }, { key: "getBoundaryDimension", value: function() {
          return ie.FALSE;
        } }, { key: "isClosed", value: function() {
          return !!this.isEmpty() || I(n, "isClosed", this, 1).call(this);
        } }, { key: "reverseInternal", value: function() {
          var i = this._points.copy();
          return Fe.reverse(i), this.getFactory().createLinearRing(i);
        } }, { key: "getTypeCode", value: function() {
          return ce.TYPECODE_LINEARRING;
        } }, { key: "validateConstruction", value: function() {
          if (!this.isEmpty() && !I(n, "isClosed", this, 1).call(this)) throw new $("Points of LinearRing do not form a closed linestring");
          if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < n.MINIMUM_VALID_SIZE) throw new $("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
        } }, { key: "getGeometryType", value: function() {
          return ce.TYPENAME_LINEARRING;
        } }], [{ key: "constructor_", value: function() {
          var i = arguments[0], a = arguments[1];
          Zn.constructor_.call(this, i, a), this.validateConstruction();
        } }]);
      })(Zn);
      xr.MINIMUM_VALID_SIZE = 4;
      var Nn = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "setOrdinate", value: function(i, a) {
          switch (i) {
            case n.X:
              this.x = a;
              break;
            case n.Y:
              this.y = a;
              break;
            default:
              throw new $("Invalid ordinate index: " + i);
          }
        } }, { key: "getZ", value: function() {
          return H.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(i) {
          switch (i) {
            case n.X:
              return this.x;
            case n.Y:
              return this.y;
          }
          throw new $("Invalid ordinate index: " + i);
        } }, { key: "setZ", value: function(i) {
          throw new $("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new n(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ")";
        } }, { key: "setCoordinate", value: function(i) {
          this.x = i.x, this.y = i.y, this.z = i.getZ();
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length === 0) H.constructor_.call(this);
          else if (arguments.length === 1) {
            if (arguments[0] instanceof n) {
              var i = arguments[0];
              H.constructor_.call(this, i.x, i.y);
            } else if (arguments[0] instanceof H) {
              var a = arguments[0];
              H.constructor_.call(this, a.x, a.y);
            }
          } else if (arguments.length === 2) {
            var c = arguments[0], g = arguments[1];
            H.constructor_.call(this, c, g, H.NULL_ORDINATE);
          }
        } }]);
      })(H);
      Nn.X = 0, Nn.Y = 1, Nn.Z = -1, Nn.M = -1;
      var Pn = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(i, a) {
          switch (i) {
            case n.X:
              this.x = a;
              break;
            case n.Y:
              this.y = a;
              break;
            case n.M:
              this._m = a;
              break;
            default:
              throw new $("Invalid ordinate index: " + i);
          }
        } }, { key: "setM", value: function(i) {
          this._m = i;
        } }, { key: "getZ", value: function() {
          return H.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(i) {
          switch (i) {
            case n.X:
              return this.x;
            case n.Y:
              return this.y;
            case n.M:
              return this._m;
          }
          throw new $("Invalid ordinate index: " + i);
        } }, { key: "setZ", value: function(i) {
          throw new $("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new n(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(i) {
          this.x = i.x, this.y = i.y, this.z = i.getZ(), this._m = i.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, arguments.length === 0) H.constructor_.call(this), this._m = 0;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof n) {
              var i = arguments[0];
              H.constructor_.call(this, i.x, i.y), this._m = i._m;
            } else if (arguments[0] instanceof H) {
              var a = arguments[0];
              H.constructor_.call(this, a.x, a.y), this._m = this.getM();
            }
          } else if (arguments.length === 3) {
            var c = arguments[0], g = arguments[1], m = arguments[2];
            H.constructor_.call(this, c, g, H.NULL_ORDINATE), this._m = m;
          }
        } }]);
      })(H);
      Pn.X = 0, Pn.Y = 1, Pn.Z = -1, Pn.M = 2;
      var as = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(i, a) {
          switch (i) {
            case H.X:
              this.x = a;
              break;
            case H.Y:
              this.y = a;
              break;
            case H.Z:
              this.z = a;
              break;
            case H.M:
              this._m = a;
              break;
            default:
              throw new $("Invalid ordinate index: " + i);
          }
        } }, { key: "setM", value: function(i) {
          this._m = i;
        } }, { key: "getOrdinate", value: function(i) {
          switch (i) {
            case H.X:
              return this.x;
            case H.Y:
              return this.y;
            case H.Z:
              return this.getZ();
            case H.M:
              return this.getM();
          }
          throw new $("Invalid ordinate index: " + i);
        } }, { key: "copy", value: function() {
          return new n(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(i) {
          this.x = i.x, this.y = i.y, this.z = i.getZ(), this._m = i.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, arguments.length === 0) H.constructor_.call(this), this._m = 0;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof n) {
              var i = arguments[0];
              H.constructor_.call(this, i), this._m = i._m;
            } else if (arguments[0] instanceof H) {
              var a = arguments[0];
              H.constructor_.call(this, a), this._m = this.getM();
            }
          } else if (arguments.length === 4) {
            var c = arguments[0], g = arguments[1], m = arguments[2], y = arguments[3];
            H.constructor_.call(this, c, g, m), this._m = y;
          }
        } }]);
      })(H), de = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "measures", value: function(n) {
          return n instanceof Nn ? 0 : n instanceof Pn || n instanceof as ? 1 : 0;
        } }, { key: "dimension", value: function(n) {
          return n instanceof Nn ? 2 : n instanceof Pn ? 3 : n instanceof as ? 4 : 3;
        } }, { key: "create", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            return o.create(n, 0);
          }
          if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            return i === 2 ? new Nn() : i === 3 && a === 0 ? new H() : i === 3 && a === 1 ? new Pn() : i === 4 && a === 1 ? new as() : new H();
          }
        } }]);
      })(), B = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "getCoordinate", value: function(i) {
          return this.get(i);
        } }, { key: "addAll", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "boolean" && Ee(arguments[0], Ce)) {
            for (var i = arguments[1], a = false, c = arguments[0].iterator(); c.hasNext(); ) this.add(c.next(), i), a = true;
            return a;
          }
          return I(n, "addAll", this, 1).apply(this, arguments);
        } }, { key: "clone", value: function() {
          for (var i = I(n, "clone", this, 1).call(this), a = 0; a < this.size(); a++) i.add(a, this.get(a).clone());
          return i;
        } }, { key: "toCoordinateArray", value: function() {
          if (arguments.length === 0) return this.toArray(n.coordArrayType);
          if (arguments.length === 1) {
            if (arguments[0]) return this.toArray(n.coordArrayType);
            for (var i = this.size(), a = new Array(i).fill(null), c = 0; c < i; c++) a[c] = this.get(i - c - 1);
            return a;
          }
        } }, { key: "add", value: function() {
          if (arguments.length === 1) {
            var i = arguments[0];
            return I(n, "add", this, 1).call(this, i);
          }
          if (arguments.length === 2) {
            if (arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
              var a = arguments[0], c = arguments[1];
              return this.add(a, c, true), true;
            }
            if (arguments[0] instanceof H && typeof arguments[1] == "boolean") {
              var g = arguments[0];
              if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(g)) return null;
              I(n, "add", this, 1).call(this, g);
            } else if (arguments[0] instanceof Object && typeof arguments[1] == "boolean") {
              var m = arguments[0], y = arguments[1];
              return this.add(m, y), true;
            }
          } else if (arguments.length === 3) {
            if (typeof arguments[2] == "boolean" && arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
              var w = arguments[0], A = arguments[1];
              if (arguments[2]) for (var z = 0; z < w.length; z++) this.add(w[z], A);
              else for (var V = w.length - 1; V >= 0; V--) this.add(w[V], A);
              return true;
            }
            if (typeof arguments[2] == "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof H) {
              var ee = arguments[0], ue = arguments[1];
              if (!arguments[2]) {
                var fe = this.size();
                if (fe > 0 && (ee > 0 && this.get(ee - 1).equals2D(ue) || ee < fe && this.get(ee).equals2D(ue)))
                  return null;
              }
              I(n, "add", this, 1).call(this, ee, ue);
            }
          } else if (arguments.length === 4) {
            var me = arguments[0], Ae = arguments[1], be = arguments[2], Ge = arguments[3], ht = 1;
            be > Ge && (ht = -1);
            for (var gt = be; gt !== Ge; gt += ht) this.add(me[gt], Ae);
            return true;
          }
        } }, { key: "closeRing", value: function() {
          if (this.size() > 0) {
            var i = this.get(0).copy();
            this.add(i, false);
          }
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length !== 0) {
            if (arguments.length === 1) {
              var i = arguments[0];
              this.ensureCapacity(i.length), this.add(i, true);
            } else if (arguments.length === 2) {
              var a = arguments[0], c = arguments[1];
              this.ensureCapacity(a.length), this.add(a, c);
            }
          }
        } }]);
      })(pe);
      B.coordArrayType = new Array(0).fill(null);
      var Q = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "isRing", value: function(n) {
          return !(n.length < 4) && !!n[0].equals2D(n[n.length - 1]);
        } }, { key: "ptNotInList", value: function(n, i) {
          for (var a = 0; a < n.length; a++) {
            var c = n[a];
            if (o.indexOf(c, i) < 0) return c;
          }
          return null;
        } }, { key: "scroll", value: function(n, i) {
          var a = o.indexOf(i, n);
          if (a < 0) return null;
          var c = new Array(n.length).fill(null);
          Pt.arraycopy(n, a, c, 0, n.length - a), Pt.arraycopy(n, 0, c, n.length - a, a), Pt.arraycopy(c, 0, n, 0, n.length);
        } }, { key: "equals", value: function() {
          if (arguments.length === 2) {
            var n = arguments[0], i = arguments[1];
            if (n === i) return true;
            if (n === null || i === null || n.length !== i.length) return false;
            for (var a = 0; a < n.length; a++) if (!n[a].equals(i[a])) return false;
            return true;
          }
          if (arguments.length === 3) {
            var c = arguments[0], g = arguments[1], m = arguments[2];
            if (c === g) return true;
            if (c === null || g === null || c.length !== g.length) return false;
            for (var y = 0; y < c.length; y++) if (m.compare(c[y], g[y]) !== 0) return false;
            return true;
          }
        } }, { key: "intersection", value: function(n, i) {
          for (var a = new B(), c = 0; c < n.length; c++) i.intersects(n[c]) && a.add(n[c], true);
          return a.toCoordinateArray();
        } }, { key: "measures", value: function(n) {
          if (n === null || n.length === 0) return 0;
          var i, a = 0, c = p(n);
          try {
            for (c.s(); !(i = c.n()).done; ) {
              var g = i.value;
              a = Math.max(a, de.measures(g));
            }
          } catch (m) {
            c.e(m);
          } finally {
            c.f();
          }
          return a;
        } }, { key: "hasRepeatedPoints", value: function(n) {
          for (var i = 1; i < n.length; i++) if (n[i - 1].equals(n[i])) return true;
          return false;
        } }, { key: "removeRepeatedPoints", value: function(n) {
          return o.hasRepeatedPoints(n) ? new B(n, false).toCoordinateArray() : n;
        } }, { key: "reverse", value: function(n) {
          for (var i = n.length - 1, a = Math.trunc(i / 2), c = 0; c <= a; c++) {
            var g = n[c];
            n[c] = n[i - c], n[i - c] = g;
          }
        } }, { key: "removeNull", value: function(n) {
          for (var i = 0, a = 0; a < n.length; a++) n[a] !== null && i++;
          var c = new Array(i).fill(null);
          if (i === 0) return c;
          for (var g = 0, m = 0; m < n.length; m++) n[m] !== null && (c[g++] = n[m]);
          return c;
        } }, { key: "copyDeep", value: function() {
          if (arguments.length === 1) {
            for (var n = arguments[0], i = new Array(n.length).fill(null), a = 0; a < n.length; a++) i[a] = n[a].copy();
            return i;
          }
          if (arguments.length === 5) for (var c = arguments[0], g = arguments[1], m = arguments[2], y = arguments[3], w = arguments[4], A = 0; A < w; A++) m[y + A] = c[g + A].copy();
        } }, { key: "isEqualReversed", value: function(n, i) {
          for (var a = 0; a < n.length; a++) {
            var c = n[a], g = i[n.length - a - 1];
            if (c.compareTo(g) !== 0) return false;
          }
          return true;
        } }, { key: "envelope", value: function(n) {
          for (var i = new Ie(), a = 0; a < n.length; a++) i.expandToInclude(n[a]);
          return i;
        } }, { key: "toCoordinateArray", value: function(n) {
          return n.toArray(o.coordArrayType);
        } }, { key: "dimension", value: function(n) {
          if (n === null || n.length === 0) return 3;
          var i, a = 0, c = p(n);
          try {
            for (c.s(); !(i = c.n()).done; ) {
              var g = i.value;
              a = Math.max(a, de.dimension(g));
            }
          } catch (m) {
            c.e(m);
          } finally {
            c.f();
          }
          return a;
        } }, { key: "atLeastNCoordinatesOrNothing", value: function(n, i) {
          return i.length >= n ? i : [];
        } }, { key: "indexOf", value: function(n, i) {
          for (var a = 0; a < i.length; a++) if (n.equals(i[a])) return a;
          return -1;
        } }, { key: "increasingDirection", value: function(n) {
          for (var i = 0; i < Math.trunc(n.length / 2); i++) {
            var a = n.length - 1 - i, c = n[i].compareTo(n[a]);
            if (c !== 0) return c;
          }
          return 1;
        } }, { key: "compare", value: function(n, i) {
          for (var a = 0; a < n.length && a < i.length; ) {
            var c = n[a].compareTo(i[a]);
            if (c !== 0) return c;
            a++;
          }
          return a < i.length ? -1 : a < n.length ? 1 : 0;
        } }, { key: "minCoordinate", value: function(n) {
          for (var i = null, a = 0; a < n.length; a++) (i === null || i.compareTo(n[a]) > 0) && (i = n[a]);
          return i;
        } }, { key: "extract", value: function(n, i, a) {
          i = Ln.clamp(i, 0, n.length);
          var c = (a = Ln.clamp(a, -1, n.length)) - i + 1;
          a < 0 && (c = 0), i >= n.length && (c = 0), a < i && (c = 0);
          var g = new Array(c).fill(null);
          if (c === 0) return g;
          for (var m = 0, y = i; y <= a; y++) g[m++] = n[y];
          return g;
        } }]);
      })(), he = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "compare", value: function(o, n) {
          var i = o, a = n;
          return Q.compare(i, a);
        } }, { key: "interfaces_", get: function() {
          return [ne];
        } }]);
      })(), Ue = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "compare", value: function(o, n) {
          var i = o, a = n;
          if (i.length < a.length) return -1;
          if (i.length > a.length) return 1;
          if (i.length === 0) return 0;
          var c = Q.compare(i, a);
          return Q.isEqualReversed(i, a) ? 0 : c;
        } }, { key: "OLDcompare", value: function(o, n) {
          var i = o, a = n;
          if (i.length < a.length) return -1;
          if (i.length > a.length) return 1;
          if (i.length === 0) return 0;
          for (var c = Q.increasingDirection(i), g = Q.increasingDirection(a), m = c > 0 ? 0 : i.length - 1, y = g > 0 ? 0 : i.length - 1, w = 0; w < i.length; w++) {
            var A = i[m].compareTo(a[y]);
            if (A !== 0) return A;
            m += c, y += g;
          }
          return 0;
        } }, { key: "interfaces_", get: function() {
          return [ne];
        } }]);
      })();
      Q.ForwardComparator = he, Q.BidirectionalComparator = Ue, Q.coordArrayType = new Array(0).fill(null);
      var Qe = (function() {
        return h((function o(n) {
          u(this, o), this.str = n;
        }), [{ key: "append", value: function(o) {
          this.str += o;
        } }, { key: "setCharAt", value: function(o, n) {
          this.str = this.str.substr(0, o) + n + this.str.substr(o + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]);
      })(), ze = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "getM", value: function(n) {
          return this.hasM() ? this._coordinates[n].getM() : Z.NaN;
        } }, { key: "setOrdinate", value: function(n, i, a) {
          switch (i) {
            case Me.X:
              this._coordinates[n].x = a;
              break;
            case Me.Y:
              this._coordinates[n].y = a;
              break;
            default:
              this._coordinates[n].setOrdinate(i, a);
          }
        } }, { key: "getZ", value: function(n) {
          return this.hasZ() ? this._coordinates[n].getZ() : Z.NaN;
        } }, { key: "size", value: function() {
          return this._coordinates.length;
        } }, { key: "getOrdinate", value: function(n, i) {
          switch (i) {
            case Me.X:
              return this._coordinates[n].x;
            case Me.Y:
              return this._coordinates[n].y;
            default:
              return this._coordinates[n].getOrdinate(i);
          }
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            return this._coordinates[n];
          }
          if (arguments.length === 2) {
            var i = arguments[0];
            arguments[1].setCoordinate(this._coordinates[i]);
          }
        } }, { key: "getCoordinateCopy", value: function(n) {
          var i = this.createCoordinate();
          return i.setCoordinate(this._coordinates[n]), i;
        } }, { key: "createCoordinate", value: function() {
          return de.create(this.getDimension(), this.getMeasures());
        } }, { key: "getDimension", value: function() {
          return this._dimension;
        } }, { key: "getX", value: function(n) {
          return this._coordinates[n].x;
        } }, { key: "getMeasures", value: function() {
          return this._measures;
        } }, { key: "expandEnvelope", value: function(n) {
          for (var i = 0; i < this._coordinates.length; i++) n.expandToInclude(this._coordinates[i]);
          return n;
        } }, { key: "copy", value: function() {
          for (var n = new Array(this.size()).fill(null), i = 0; i < this._coordinates.length; i++) {
            var a = this.createCoordinate();
            a.setCoordinate(this._coordinates[i]), n[i] = a;
          }
          return new o(n, this._dimension, this._measures);
        } }, { key: "toString", value: function() {
          if (this._coordinates.length > 0) {
            var n = new Qe(17 * this._coordinates.length);
            n.append("("), n.append(this._coordinates[0]);
            for (var i = 1; i < this._coordinates.length; i++) n.append(", "), n.append(this._coordinates[i]);
            return n.append(")"), n.toString();
          }
          return "()";
        } }, { key: "getY", value: function(n) {
          return this._coordinates[n].y;
        } }, { key: "toCoordinateArray", value: function() {
          return this._coordinates;
        } }, { key: "interfaces_", get: function() {
          return [Me, k];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimension = 3, this._measures = 0, this._coordinates = null, arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var n = arguments[0];
              o.constructor_.call(this, n, Q.dimension(n), Q.measures(n));
            } else if (Number.isInteger(arguments[0])) {
              var i = arguments[0];
              this._coordinates = new Array(i).fill(null);
              for (var a = 0; a < i; a++) this._coordinates[a] = new H();
            } else if (Ee(arguments[0], Me)) {
              var c = arguments[0];
              if (c === null) return this._coordinates = new Array(0).fill(null), null;
              this._dimension = c.getDimension(), this._measures = c.getMeasures(), this._coordinates = new Array(c.size()).fill(null);
              for (var g = 0; g < this._coordinates.length; g++) this._coordinates[g] = c.getCoordinateCopy(g);
            }
          } else if (arguments.length === 2) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var m = arguments[0], y = arguments[1];
              o.constructor_.call(this, m, y, Q.measures(m));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var w = arguments[0], A = arguments[1];
              this._coordinates = new Array(w).fill(null), this._dimension = A;
              for (var z = 0; z < w; z++) this._coordinates[z] = de.create(A);
            }
          } else if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var V = arguments[0], ee = arguments[1], ue = arguments[2];
              this._dimension = ee, this._measures = ue, this._coordinates = V === null ? new Array(0).fill(null) : V;
            } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var fe = arguments[0], me = arguments[1], Ae = arguments[2];
              this._coordinates = new Array(fe).fill(null), this._dimension = me, this._measures = Ae;
              for (var be = 0; be < fe; be++) this._coordinates[be] = this.createCoordinate();
            }
          }
        } }]);
      })(), it = (function() {
        function o() {
          u(this, o);
        }
        return h(o, [{ key: "readResolve", value: function() {
          return o.instance();
        } }, { key: "create", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) return new ze(arguments[0]);
            if (Ee(arguments[0], Me)) return new ze(arguments[0]);
          } else {
            if (arguments.length === 2) {
              var n = arguments[1];
              return n > 3 && (n = 3), n < 2 && (n = 2), new ze(arguments[0], n);
            }
            if (arguments.length === 3) {
              var i = arguments[2], a = arguments[1] - i;
              return i > 1 && (i = 1), a > 3 && (a = 3), a < 2 && (a = 2), new ze(arguments[0], a + i, i);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [ca, k];
        } }], [{ key: "instance", value: function() {
          return o.instanceObject;
        } }]);
      })();
      it.instanceObject = new it();
      var Gt = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "copyInternal", value: function() {
          for (var i = new Array(this._geometries.length).fill(null), a = 0; a < i.length; a++) i[a] = this._geometries[a].copy();
          return new n(i, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof ce) {
            var i = arguments[0], a = arguments[1];
            return !!this.isEquivalentClass(i) && I(n, "equalsExact", this, 1).call(this, i, a);
          }
          return I(n, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "getTypeCode", value: function() {
          return ce.TYPECODE_MULTIPOLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          for (var i = new pe(), a = 0; a < this._geometries.length; a++) for (var c = this._geometries[a].getBoundary(), g = 0; g < c.getNumGeometries(); g++) i.add(c.getGeometryN(g));
          var m = new Array(i.size()).fill(null);
          return this.getFactory().createMultiLineString(i.toArray(m));
        } }, { key: "getGeometryType", value: function() {
          return ce.TYPENAME_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [Cn];
        } }], [{ key: "constructor_", value: function() {
          var i = arguments[0], a = arguments[1];
          Ve.constructor_.call(this, i, a);
        } }]);
      })(Ve), Kn = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "get", value: function() {
        } }, { key: "put", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "values", value: function() {
        } }, { key: "entrySet", value: function() {
        } }]);
      })(), os = (function(o) {
        function n() {
          var i;
          return u(this, n), (i = s(this, n)).map = /* @__PURE__ */ new Map(), i;
        }
        return _(n, o), h(n, [{ key: "get", value: function(i) {
          return this.map.get(i) || null;
        } }, { key: "put", value: function(i, a) {
          return this.map.set(i, a), a;
        } }, { key: "values", value: function() {
          for (var i = new pe(), a = this.map.values(), c = a.next(); !c.done; ) i.add(c.value), c = a.next();
          return i;
        } }, { key: "entrySet", value: function() {
          var i = new Gr();
          return this.map.entries().forEach((function(a) {
            return i.add(a);
          })), i;
        } }, { key: "size", value: function() {
          return this.map.size();
        } }]);
      })(Kn), Re = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "equals", value: function(n) {
          if (!(n instanceof o)) return false;
          var i = n;
          return this._modelType === i._modelType && this._scale === i._scale;
        } }, { key: "compareTo", value: function(n) {
          var i = n, a = this.getMaximumSignificantDigits(), c = i.getMaximumSignificantDigits();
          return hn.compare(a, c);
        } }, { key: "getScale", value: function() {
          return this._scale;
        } }, { key: "isFloating", value: function() {
          return this._modelType === o.FLOATING || this._modelType === o.FLOATING_SINGLE;
        } }, { key: "getType", value: function() {
          return this._modelType;
        } }, { key: "toString", value: function() {
          var n = "UNKNOWN";
          return this._modelType === o.FLOATING ? n = "Floating" : this._modelType === o.FLOATING_SINGLE ? n = "Floating-Single" : this._modelType === o.FIXED && (n = "Fixed (Scale=" + this.getScale() + ")"), n;
        } }, { key: "makePrecise", value: function() {
          if (typeof arguments[0] == "number") {
            var n = arguments[0];
            return Z.isNaN(n) || this._modelType === o.FLOATING_SINGLE ? n : this._modelType === o.FIXED ? Math.round(n * this._scale) / this._scale : n;
          }
          if (arguments[0] instanceof H) {
            var i = arguments[0];
            if (this._modelType === o.FLOATING) return null;
            i.x = this.makePrecise(i.x), i.y = this.makePrecise(i.y);
          }
        } }, { key: "getMaximumSignificantDigits", value: function() {
          var n = 16;
          return this._modelType === o.FLOATING ? n = 16 : this._modelType === o.FLOATING_SINGLE ? n = 6 : this._modelType === o.FIXED && (n = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), n;
        } }, { key: "setScale", value: function(n) {
          this._scale = Math.abs(n);
        } }, { key: "interfaces_", get: function() {
          return [k, j];
        } }], [{ key: "constructor_", value: function() {
          if (this._modelType = null, this._scale = null, arguments.length === 0) this._modelType = o.FLOATING;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof Qn) {
              var n = arguments[0];
              this._modelType = n, n === o.FIXED && this.setScale(1);
            } else if (typeof arguments[0] == "number") {
              var i = arguments[0];
              this._modelType = o.FIXED, this.setScale(i);
            } else if (arguments[0] instanceof o) {
              var a = arguments[0];
              this._modelType = a._modelType, this._scale = a._scale;
            }
          }
        } }, { key: "mostPrecise", value: function(n, i) {
          return n.compareTo(i) >= 0 ? n : i;
        } }]);
      })(), Qn = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "readResolve", value: function() {
          return o.nameToTypeMap.get(this._name);
        } }, { key: "toString", value: function() {
          return this._name;
        } }, { key: "interfaces_", get: function() {
          return [k];
        } }], [{ key: "constructor_", value: function() {
          this._name = null;
          var n = arguments[0];
          this._name = n, o.nameToTypeMap.put(n, this);
        } }]);
      })();
      Qn.nameToTypeMap = new os(), Re.Type = Qn, Re.FIXED = new Qn("FIXED"), Re.FLOATING = new Qn("FLOATING"), Re.FLOATING_SINGLE = new Qn("FLOATING SINGLE"), Re.maximumPreciseValue = 9007199254740992;
      var yi = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "copyInternal", value: function() {
          for (var i = new Array(this._geometries.length).fill(null), a = 0; a < i.length; a++) i[a] = this._geometries[a].copy();
          return new n(i, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof ce) {
            var i = arguments[0], a = arguments[1];
            return !!this.isEquivalentClass(i) && I(n, "equalsExact", this, 1).call(this, i, a);
          }
          return I(n, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? ie.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          if (this.isEmpty()) return false;
          for (var i = 0; i < this._geometries.length; i++) if (!this._geometries[i].isClosed()) return false;
          return true;
        } }, { key: "getTypeCode", value: function() {
          return ce.TYPECODE_MULTILINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getBoundary", value: function() {
          throw new ke();
        } }, { key: "getGeometryType", value: function() {
          return ce.TYPENAME_MULTILINESTRING;
        } }, { key: "interfaces_", get: function() {
          return [ha];
        } }], [{ key: "constructor_", value: function() {
          var i = arguments[0], a = arguments[1];
          Ve.constructor_.call(this, i, a);
        } }]);
      })(Ve), _i4 = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "createEmpty", value: function(n) {
          switch (n) {
            case -1:
              return this.createGeometryCollection();
            case 0:
              return this.createPoint();
            case 1:
              return this.createLineString();
            case 2:
              return this.createPolygon();
            default:
              throw new $("Invalid dimension: " + n);
          }
        } }, { key: "toGeometry", value: function(n) {
          return n.isNull() ? this.createPoint() : n.getMinX() === n.getMaxX() && n.getMinY() === n.getMaxY() ? this.createPoint(new H(n.getMinX(), n.getMinY())) : n.getMinX() === n.getMaxX() || n.getMinY() === n.getMaxY() ? this.createLineString([new H(n.getMinX(), n.getMinY()), new H(n.getMaxX(), n.getMaxY())]) : this.createPolygon(this.createLinearRing([new H(n.getMinX(), n.getMinY()), new H(n.getMinX(), n.getMaxY()), new H(n.getMaxX(), n.getMaxY()), new H(n.getMaxX(), n.getMinY()), new H(n.getMinX(), n.getMinY())]), null);
        } }, { key: "createLineString", value: function() {
          if (arguments.length === 0) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var n = arguments[0];
              return this.createLineString(n !== null ? this.getCoordinateSequenceFactory().create(n) : null);
            }
            if (Ee(arguments[0], Me)) return new Zn(arguments[0], this);
          }
        } }, { key: "createMultiLineString", value: function() {
          return arguments.length === 0 ? new yi(null, this) : arguments.length === 1 ? new yi(arguments[0], this) : void 0;
        } }, { key: "buildGeometry", value: function(n) {
          for (var i = null, a = false, c = false, g = n.iterator(); g.hasNext(); ) {
            var m = g.next(), y = m.getTypeCode();
            i === null && (i = y), y !== i && (a = true), m instanceof Ve && (c = true);
          }
          if (i === null) return this.createGeometryCollection();
          if (a || c) return this.createGeometryCollection(o.toGeometryArray(n));
          var w = n.iterator().next();
          if (n.size() > 1) {
            if (w instanceof qr) return this.createMultiPolygon(o.toPolygonArray(n));
            if (w instanceof Zn) return this.createMultiLineString(o.toLineStringArray(n));
            if (w instanceof pi) return this.createMultiPoint(o.toPointArray(n));
            ae.shouldNeverReachHere("Unhandled geometry type: " + w.getGeometryType());
          }
          return w;
        } }, { key: "createMultiPointFromCoords", value: function(n) {
          return this.createMultiPoint(n !== null ? this.getCoordinateSequenceFactory().create(n) : null);
        } }, { key: "createPoint", value: function() {
          if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof H) {
              var n = arguments[0];
              return this.createPoint(n !== null ? this.getCoordinateSequenceFactory().create([n]) : null);
            }
            if (Ee(arguments[0], Me)) return new pi(arguments[0], this);
          }
        } }, { key: "getCoordinateSequenceFactory", value: function() {
          return this._coordinateSequenceFactory;
        } }, { key: "createPolygon", value: function() {
          if (arguments.length === 0) return this.createPolygon(null, null);
          if (arguments.length === 1) {
            if (Ee(arguments[0], Me)) {
              var n = arguments[0];
              return this.createPolygon(this.createLinearRing(n));
            }
            if (arguments[0] instanceof Array) {
              var i = arguments[0];
              return this.createPolygon(this.createLinearRing(i));
            }
            if (arguments[0] instanceof xr) {
              var a = arguments[0];
              return this.createPolygon(a, null);
            }
          } else if (arguments.length === 2)
            return new qr(arguments[0], arguments[1], this);
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "createGeometryCollection", value: function() {
          return arguments.length === 0 ? new Ve(null, this) : arguments.length === 1 ? new Ve(arguments[0], this) : void 0;
        } }, { key: "getPrecisionModel", value: function() {
          return this._precisionModel;
        } }, { key: "createLinearRing", value: function() {
          if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var n = arguments[0];
              return this.createLinearRing(n !== null ? this.getCoordinateSequenceFactory().create(n) : null);
            }
            if (Ee(arguments[0], Me)) return new xr(arguments[0], this);
          }
        } }, { key: "createMultiPolygon", value: function() {
          return arguments.length === 0 ? new Gt(null, this) : arguments.length === 1 ? new Gt(arguments[0], this) : void 0;
        } }, { key: "createMultiPoint", value: function() {
          if (arguments.length === 0) return new vi(null, this);
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) return new vi(arguments[0], this);
            if (Ee(arguments[0], Me)) {
              var n = arguments[0];
              if (n === null) return this.createMultiPoint(new Array(0).fill(null));
              for (var i = new Array(n.size()).fill(null), a = 0; a < n.size(); a++) {
                var c = this.getCoordinateSequenceFactory().create(1, n.getDimension(), n.getMeasures());
                Fe.copy(n, a, c, 0, 1), i[a] = this.createPoint(c);
              }
              return this.createMultiPoint(i);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [k];
        } }], [{ key: "constructor_", value: function() {
          if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, arguments.length === 0) o.constructor_.call(this, new Re(), 0);
          else if (arguments.length === 1) {
            if (Ee(arguments[0], ca)) {
              var n = arguments[0];
              o.constructor_.call(this, new Re(), 0, n);
            } else if (arguments[0] instanceof Re) {
              var i = arguments[0];
              o.constructor_.call(this, i, 0, o.getDefaultCoordinateSequenceFactory());
            }
          } else if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            o.constructor_.call(this, a, c, o.getDefaultCoordinateSequenceFactory());
          } else if (arguments.length === 3) {
            var g = arguments[0], m = arguments[1], y = arguments[2];
            this._precisionModel = g, this._coordinateSequenceFactory = y, this._SRID = m;
          }
        } }, { key: "toMultiPolygonArray", value: function(n) {
          var i = new Array(n.size()).fill(null);
          return n.toArray(i);
        } }, { key: "toGeometryArray", value: function(n) {
          if (n === null) return null;
          var i = new Array(n.size()).fill(null);
          return n.toArray(i);
        } }, { key: "getDefaultCoordinateSequenceFactory", value: function() {
          return it.instance();
        } }, { key: "toMultiLineStringArray", value: function(n) {
          var i = new Array(n.size()).fill(null);
          return n.toArray(i);
        } }, { key: "toLineStringArray", value: function(n) {
          var i = new Array(n.size()).fill(null);
          return n.toArray(i);
        } }, { key: "toMultiPointArray", value: function(n) {
          var i = new Array(n.size()).fill(null);
          return n.toArray(i);
        } }, { key: "toLinearRingArray", value: function(n) {
          var i = new Array(n.size()).fill(null);
          return n.toArray(i);
        } }, { key: "toPointArray", value: function(n) {
          var i = new Array(n.size()).fill(null);
          return n.toArray(i);
        } }, { key: "toPolygonArray", value: function(n) {
          var i = new Array(n.size()).fill(null);
          return n.toArray(i);
        } }, { key: "createPointFromInternalCoord", value: function(n, i) {
          return i.getPrecisionModel().makePrecise(n), i.getFactory().createPoint(n);
        } }]);
      })(), Ro = "XY", Pp = "XYZ", Op = "XYM", Rp = "XYZM", ic = { POINT: "Point", LINE_STRING: "LineString", LINEAR_RING: "LinearRing", POLYGON: "Polygon", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon", GEOMETRY_COLLECTION: "GeometryCollection", CIRCLE: "Circle" }, sc = "EMPTY", pa = 1, er = 2, wr = 3, ac = 4, Ei = 5, Dp = 6;
      for (var Fp in ic) ic[Fp].toUpperCase();
      var Gp = (function() {
        return h((function o(n) {
          u(this, o), this.wkt = n, this.index_ = -1;
        }), [{ key: "isAlpha_", value: function(o) {
          return o >= "a" && o <= "z" || o >= "A" && o <= "Z";
        } }, { key: "isNumeric_", value: function(o, n) {
          return o >= "0" && o <= "9" || o == "." && !(n !== void 0 && n);
        } }, { key: "isWhiteSpace_", value: function(o) {
          return o == " " || o == "	" || o == "\r" || o == `
`;
        } }, { key: "nextChar_", value: function() {
          return this.wkt.charAt(++this.index_);
        } }, { key: "nextToken", value: function() {
          var o, n = this.nextChar_(), i = this.index_, a = n;
          if (n == "(") o = er;
          else if (n == ",") o = Ei;
          else if (n == ")") o = wr;
          else if (this.isNumeric_(n) || n == "-") o = ac, a = this.readNumber_();
          else if (this.isAlpha_(n)) o = pa, a = this.readText_();
          else {
            if (this.isWhiteSpace_(n)) return this.nextToken();
            if (n !== "") throw new Error("Unexpected character: " + n);
            o = Dp;
          }
          return { position: i, value: a, type: o };
        } }, { key: "readNumber_", value: function() {
          var o, n = this.index_, i = false, a = false;
          do
            o == "." ? i = true : o != "e" && o != "E" || (a = true), o = this.nextChar_();
          while (this.isNumeric_(o, i) || !a && (o == "e" || o == "E") || a && (o == "-" || o == "+"));
          return parseFloat(this.wkt.substring(n, this.index_--));
        } }, { key: "readText_", value: function() {
          var o, n = this.index_;
          do
            o = this.nextChar_();
          while (this.isAlpha_(o));
          return this.wkt.substring(n, this.index_--).toUpperCase();
        } }]);
      })(), Bp = (function() {
        return h((function o(n, i) {
          u(this, o), this.lexer_ = n, this.token_, this.layout_ = Ro, this.factory = i;
        }), [{ key: "consume_", value: function() {
          this.token_ = this.lexer_.nextToken();
        } }, { key: "isTokenType", value: function(o) {
          return this.token_.type == o;
        } }, { key: "match", value: function(o) {
          var n = this.isTokenType(o);
          return n && this.consume_(), n;
        } }, { key: "parse", value: function() {
          return this.consume_(), this.parseGeometry_();
        } }, { key: "parseGeometryLayout_", value: function() {
          var o = Ro, n = this.token_;
          if (this.isTokenType(pa)) {
            var i = n.value;
            i === "Z" ? o = Pp : i === "M" ? o = Op : i === "ZM" && (o = Rp), o !== Ro && this.consume_();
          }
          return o;
        } }, { key: "parseGeometryCollectionText_", value: function() {
          if (this.match(er)) {
            var o = [];
            do
              o.push(this.parseGeometry_());
            while (this.match(Ei));
            if (this.match(wr)) return o;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointText_", value: function() {
          if (this.match(er)) {
            var o = this.parsePoint_();
            if (this.match(wr)) return o;
          } else if (this.isEmptyGeometry_()) return null;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseLineStringText_", value: function() {
          if (this.match(er)) {
            var o = this.parsePointList_();
            if (this.match(wr)) return o;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePolygonText_", value: function() {
          if (this.match(er)) {
            var o = this.parseLineStringTextList_();
            if (this.match(wr)) return o;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPointText_", value: function() {
          var o;
          if (this.match(er)) {
            if (o = this.token_.type == er ? this.parsePointTextList_() : this.parsePointList_(), this.match(wr)) return o;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiLineStringText_", value: function() {
          if (this.match(er)) {
            var o = this.parseLineStringTextList_();
            if (this.match(wr)) return o;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPolygonText_", value: function() {
          if (this.match(er)) {
            var o = this.parsePolygonTextList_();
            if (this.match(wr)) return o;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePoint_", value: function() {
          for (var o = [], n = this.layout_.length, i = 0; i < n; ++i) {
            var a = this.token_;
            if (!this.match(ac)) break;
            o.push(a.value);
          }
          if (o.length == n) return o;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointList_", value: function() {
          for (var o = [this.parsePoint_()]; this.match(Ei); ) o.push(this.parsePoint_());
          return o;
        } }, { key: "parsePointTextList_", value: function() {
          for (var o = [this.parsePointText_()]; this.match(Ei); ) o.push(this.parsePointText_());
          return o;
        } }, { key: "parseLineStringTextList_", value: function() {
          for (var o = [this.parseLineStringText_()]; this.match(Ei); ) o.push(this.parseLineStringText_());
          return o;
        } }, { key: "parsePolygonTextList_", value: function() {
          for (var o = [this.parsePolygonText_()]; this.match(Ei); ) o.push(this.parsePolygonText_());
          return o;
        } }, { key: "isEmptyGeometry_", value: function() {
          var o = this.isTokenType(pa) && this.token_.value == sc;
          return o && this.consume_(), o;
        } }, { key: "formatErrorMessage_", value: function() {
          return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
        } }, { key: "parseGeometry_", value: function() {
          var o = this.factory, n = function(me) {
            return l(H, D(me));
          }, i = function(me) {
            var Ae = me.map((function(be) {
              return o.createLinearRing(be.map(n));
            }));
            return Ae.length > 1 ? o.createPolygon(Ae[0], Ae.slice(1)) : o.createPolygon(Ae[0]);
          }, a = this.token_;
          if (this.match(pa)) {
            var c = a.value;
            if (this.layout_ = this.parseGeometryLayout_(), c == "GEOMETRYCOLLECTION") {
              var g = this.parseGeometryCollectionText_();
              return o.createGeometryCollection(g);
            }
            switch (c) {
              case "POINT":
                var m = this.parsePointText_();
                return m ? o.createPoint(l(H, D(m))) : o.createPoint();
              case "LINESTRING":
                var y = this.parseLineStringText_().map(n);
                return o.createLineString(y);
              case "LINEARRING":
                var w = this.parseLineStringText_().map(n);
                return o.createLinearRing(w);
              case "POLYGON":
                var A = this.parsePolygonText_();
                return A && A.length !== 0 ? i(A) : o.createPolygon();
              case "MULTIPOINT":
                var z = this.parseMultiPointText_();
                if (!z || z.length === 0) return o.createMultiPoint();
                var V = z.map(n).map((function(me) {
                  return o.createPoint(me);
                }));
                return o.createMultiPoint(V);
              case "MULTILINESTRING":
                var ee = this.parseMultiLineStringText_().map((function(me) {
                  return o.createLineString(me.map(n));
                }));
                return o.createMultiLineString(ee);
              case "MULTIPOLYGON":
                var ue = this.parseMultiPolygonText_();
                if (!ue || ue.length === 0) return o.createMultiPolygon();
                var fe = ue.map(i);
                return o.createMultiPolygon(fe);
              default:
                throw new Error("Invalid geometry type: " + c);
            }
          }
          throw new Error(this.formatErrorMessage_());
        } }]);
      })();
      function oc(o) {
        if (o.isEmpty()) return "";
        var n = o.getCoordinate(), i = [n.x, n.y];
        return n.z === void 0 || Number.isNaN(n.z) || i.push(n.z), n.m === void 0 || Number.isNaN(n.m) || i.push(n.m), i.join(" ");
      }
      function us(o) {
        for (var n = o.getCoordinates().map((function(g) {
          var m = [g.x, g.y];
          return g.z === void 0 || Number.isNaN(g.z) || m.push(g.z), g.m === void 0 || Number.isNaN(g.m) || m.push(g.m), m;
        })), i = [], a = 0, c = n.length; a < c; ++a) i.push(n[a].join(" "));
        return i.join(", ");
      }
      function uc(o) {
        var n = [];
        n.push("(" + us(o.getExteriorRing()) + ")");
        for (var i = 0, a = o.getNumInteriorRing(); i < a; ++i) n.push("(" + us(o.getInteriorRingN(i)) + ")");
        return n.join(", ");
      }
      var Up = { Point: oc, LineString: us, LinearRing: us, Polygon: uc, MultiPoint: function(o) {
        for (var n = [], i = 0, a = o.getNumGeometries(); i < a; ++i) n.push("(" + oc(o.getGeometryN(i)) + ")");
        return n.join(", ");
      }, MultiLineString: function(o) {
        for (var n = [], i = 0, a = o.getNumGeometries(); i < a; ++i) n.push("(" + us(o.getGeometryN(i)) + ")");
        return n.join(", ");
      }, MultiPolygon: function(o) {
        for (var n = [], i = 0, a = o.getNumGeometries(); i < a; ++i) n.push("(" + uc(o.getGeometryN(i)) + ")");
        return n.join(", ");
      }, GeometryCollection: function(o) {
        for (var n = [], i = 0, a = o.getNumGeometries(); i < a; ++i) n.push(lc(o.getGeometryN(i)));
        return n.join(", ");
      } };
      function lc(o) {
        var n = o.getGeometryType(), i = Up[n];
        n = n.toUpperCase();
        var a = (function(c) {
          var g = "";
          if (c.isEmpty()) return g;
          var m = c.getCoordinate();
          return m.z === void 0 || Number.isNaN(m.z) || (g += "Z"), m.m === void 0 || Number.isNaN(m.m) || (g += "M"), g;
        })(o);
        return a.length > 0 && (n += " " + a), o.isEmpty() ? n + " " + sc : n + " (" + i(o) + ")";
      }
      var zp = (function() {
        return h((function o(n) {
          u(this, o), this.geometryFactory = n || new _i4(), this.precisionModel = this.geometryFactory.getPrecisionModel();
        }), [{ key: "read", value: function(o) {
          var n = new Gp(o);
          return new Bp(n, this.geometryFactory).parse();
        } }, { key: "write", value: function(o) {
          return lc(o);
        } }]);
      })(), Do = (function() {
        return h((function o(n) {
          u(this, o), this.parser = new zp(n);
        }), [{ key: "write", value: function(o) {
          return this.parser.write(o);
        } }], [{ key: "toLineString", value: function(o, n) {
          if (arguments.length !== 2) throw new Error("Not implemented");
          return "LINESTRING ( " + o.x + " " + o.y + ", " + n.x + " " + n.y + " )";
        } }]);
      })(), $e = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "getIndexAlongSegment", value: function(n, i) {
          return this.computeIntLineIndex(), this._intLineIndex[n][i];
        } }, { key: "getTopologySummary", value: function() {
          var n = new Qe();
          return this.isEndPoint() && n.append(" endpoint"), this._isProper && n.append(" proper"), this.isCollinear() && n.append(" collinear"), n.toString();
        } }, { key: "computeIntersection", value: function(n, i, a, c) {
          this._inputLines[0][0] = n, this._inputLines[0][1] = i, this._inputLines[1][0] = a, this._inputLines[1][1] = c, this._result = this.computeIntersect(n, i, a, c);
        } }, { key: "getIntersectionNum", value: function() {
          return this._result;
        } }, { key: "computeIntLineIndex", value: function() {
          if (arguments.length === 0) this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map((function() {
            return Array(2);
          })), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
          else if (arguments.length === 1) {
            var n = arguments[0];
            this.getEdgeDistance(n, 0) > this.getEdgeDistance(n, 1) ? (this._intLineIndex[n][0] = 0, this._intLineIndex[n][1] = 1) : (this._intLineIndex[n][0] = 1, this._intLineIndex[n][1] = 0);
          }
        } }, { key: "isProper", value: function() {
          return this.hasIntersection() && this._isProper;
        } }, { key: "setPrecisionModel", value: function(n) {
          this._precisionModel = n;
        } }, { key: "isInteriorIntersection", value: function() {
          if (arguments.length === 0) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
          if (arguments.length === 1) {
            for (var n = arguments[0], i = 0; i < this._result; i++) if (!this._intPt[i].equals2D(this._inputLines[n][0]) && !this._intPt[i].equals2D(this._inputLines[n][1])) return true;
            return false;
          }
        } }, { key: "getIntersection", value: function(n) {
          return this._intPt[n];
        } }, { key: "isEndPoint", value: function() {
          return this.hasIntersection() && !this._isProper;
        } }, { key: "hasIntersection", value: function() {
          return this._result !== o.NO_INTERSECTION;
        } }, { key: "getEdgeDistance", value: function(n, i) {
          return o.computeEdgeDistance(this._intPt[i], this._inputLines[n][0], this._inputLines[n][1]);
        } }, { key: "isCollinear", value: function() {
          return this._result === o.COLLINEAR_INTERSECTION;
        } }, { key: "toString", value: function() {
          return Do.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Do.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
        } }, { key: "getEndpoint", value: function(n, i) {
          return this._inputLines[n][i];
        } }, { key: "isIntersection", value: function(n) {
          for (var i = 0; i < this._result; i++) if (this._intPt[i].equals2D(n)) return true;
          return false;
        } }, { key: "getIntersectionAlongSegment", value: function(n, i) {
          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[n][i]];
        } }], [{ key: "constructor_", value: function() {
          this._result = null, this._inputLines = Array(2).fill().map((function() {
            return Array(2);
          })), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new H(), this._intPt[1] = new H(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
        } }, { key: "computeEdgeDistance", value: function(n, i, a) {
          var c = Math.abs(a.x - i.x), g = Math.abs(a.y - i.y), m = -1;
          if (n.equals(i)) m = 0;
          else if (n.equals(a)) m = c > g ? c : g;
          else {
            var y = Math.abs(n.x - i.x), w = Math.abs(n.y - i.y);
            (m = c > g ? y : w) !== 0 || n.equals(i) || (m = Math.max(y, w));
          }
          return ae.isTrue(!(m === 0 && !n.equals(i)), "Bad distance calculation"), m;
        } }, { key: "nonRobustComputeEdgeDistance", value: function(n, i, a) {
          var c = n.x - i.x, g = n.y - i.y, m = Math.sqrt(c * c + g * g);
          return ae.isTrue(!(m === 0 && !n.equals(i)), "Invalid distance calculation"), m;
        } }]);
      })();
      $e.DONT_INTERSECT = 0, $e.DO_INTERSECT = 1, $e.COLLINEAR = 2, $e.NO_INTERSECTION = 0, $e.POINT_INTERSECTION = 1, $e.COLLINEAR_INTERSECTION = 2;
      var Yr = (function(o) {
        function n() {
          return u(this, n), s(this, n);
        }
        return _(n, o), h(n, [{ key: "isInSegmentEnvelopes", value: function(i) {
          var a = new Ie(this._inputLines[0][0], this._inputLines[0][1]), c = new Ie(this._inputLines[1][0], this._inputLines[1][1]);
          return a.contains(i) && c.contains(i);
        } }, { key: "computeIntersection", value: function() {
          if (arguments.length !== 3) return I(n, "computeIntersection", this, 1).apply(this, arguments);
          var i = arguments[0], a = arguments[1], c = arguments[2];
          if (this._isProper = false, Ie.intersects(a, c, i) && ye.index(a, c, i) === 0 && ye.index(c, a, i) === 0) return this._isProper = true, (i.equals(a) || i.equals(c)) && (this._isProper = false), this._result = $e.POINT_INTERSECTION, null;
          this._result = $e.NO_INTERSECTION;
        } }, { key: "intersection", value: function(i, a, c, g) {
          var m = this.intersectionSafe(i, a, c, g);
          return this.isInSegmentEnvelopes(m) || (m = new H(n.nearestEndpoint(i, a, c, g))), this._precisionModel !== null && this._precisionModel.makePrecise(m), m;
        } }, { key: "checkDD", value: function(i, a, c, g, m) {
          var y = fi.intersection(i, a, c, g), w = this.isInSegmentEnvelopes(y);
          Pt.out.println("DD in env = " + w + "  --------------------- " + y), m.distance(y) > 1e-4 && Pt.out.println("Distance = " + m.distance(y));
        } }, { key: "intersectionSafe", value: function(i, a, c, g) {
          var m = Ur.intersection(i, a, c, g);
          return m === null && (m = n.nearestEndpoint(i, a, c, g)), m;
        } }, { key: "computeCollinearIntersection", value: function(i, a, c, g) {
          var m = Ie.intersects(i, a, c), y = Ie.intersects(i, a, g), w = Ie.intersects(c, g, i), A = Ie.intersects(c, g, a);
          return m && y ? (this._intPt[0] = c, this._intPt[1] = g, $e.COLLINEAR_INTERSECTION) : w && A ? (this._intPt[0] = i, this._intPt[1] = a, $e.COLLINEAR_INTERSECTION) : m && w ? (this._intPt[0] = c, this._intPt[1] = i, !c.equals(i) || y || A ? $e.COLLINEAR_INTERSECTION : $e.POINT_INTERSECTION) : m && A ? (this._intPt[0] = c, this._intPt[1] = a, !c.equals(a) || y || w ? $e.COLLINEAR_INTERSECTION : $e.POINT_INTERSECTION) : y && w ? (this._intPt[0] = g, this._intPt[1] = i, !g.equals(i) || m || A ? $e.COLLINEAR_INTERSECTION : $e.POINT_INTERSECTION) : y && A ? (this._intPt[0] = g, this._intPt[1] = a, !g.equals(a) || m || w ? $e.COLLINEAR_INTERSECTION : $e.POINT_INTERSECTION) : $e.NO_INTERSECTION;
        } }, { key: "computeIntersect", value: function(i, a, c, g) {
          if (this._isProper = false, !Ie.intersects(i, a, c, g)) return $e.NO_INTERSECTION;
          var m = ye.index(i, a, c), y = ye.index(i, a, g);
          if (m > 0 && y > 0 || m < 0 && y < 0) return $e.NO_INTERSECTION;
          var w = ye.index(c, g, i), A = ye.index(c, g, a);
          return w > 0 && A > 0 || w < 0 && A < 0 ? $e.NO_INTERSECTION : m === 0 && y === 0 && w === 0 && A === 0 ? this.computeCollinearIntersection(i, a, c, g) : (m === 0 || y === 0 || w === 0 || A === 0 ? (this._isProper = false, i.equals2D(c) || i.equals2D(g) ? this._intPt[0] = i : a.equals2D(c) || a.equals2D(g) ? this._intPt[0] = a : m === 0 ? this._intPt[0] = new H(c) : y === 0 ? this._intPt[0] = new H(g) : w === 0 ? this._intPt[0] = new H(i) : A === 0 && (this._intPt[0] = new H(a))) : (this._isProper = true, this._intPt[0] = this.intersection(i, a, c, g)), $e.POINT_INTERSECTION);
        } }], [{ key: "nearestEndpoint", value: function(i, a, c, g) {
          var m = i, y = Et.pointToSegment(i, c, g), w = Et.pointToSegment(a, c, g);
          return w < y && (y = w, m = a), (w = Et.pointToSegment(c, i, a)) < y && (y = w, m = c), (w = Et.pointToSegment(g, i, a)) < y && (y = w, m = g), m;
        } }]);
      })($e), qp = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "countSegment", value: function(n, i) {
          if (n.x < this._p.x && i.x < this._p.x) return null;
          if (this._p.x === i.x && this._p.y === i.y) return this._isPointOnSegment = true, null;
          if (n.y === this._p.y && i.y === this._p.y) {
            var a = n.x, c = i.x;
            return a > c && (a = i.x, c = n.x), this._p.x >= a && this._p.x <= c && (this._isPointOnSegment = true), null;
          }
          if (n.y > this._p.y && i.y <= this._p.y || i.y > this._p.y && n.y <= this._p.y) {
            var g = ye.index(n, i, this._p);
            if (g === ye.COLLINEAR) return this._isPointOnSegment = true, null;
            i.y < n.y && (g = -g), g === ye.LEFT && this._crossingCount++;
          }
        } }, { key: "isPointInPolygon", value: function() {
          return this.getLocation() !== N.EXTERIOR;
        } }, { key: "getLocation", value: function() {
          return this._isPointOnSegment ? N.BOUNDARY : this._crossingCount % 2 == 1 ? N.INTERIOR : N.EXTERIOR;
        } }, { key: "isOnSegment", value: function() {
          return this._isPointOnSegment;
        } }], [{ key: "constructor_", value: function() {
          this._p = null, this._crossingCount = 0, this._isPointOnSegment = false;
          var n = arguments[0];
          this._p = n;
        } }, { key: "locatePointInRing", value: function() {
          if (arguments[0] instanceof H && Ee(arguments[1], Me)) {
            for (var n = arguments[1], i = new o(arguments[0]), a = new H(), c = new H(), g = 1; g < n.size(); g++) if (n.getCoordinate(g, a), n.getCoordinate(g - 1, c), i.countSegment(a, c), i.isOnSegment()) return i.getLocation();
            return i.getLocation();
          }
          if (arguments[0] instanceof H && arguments[1] instanceof Array) {
            for (var m = arguments[1], y = new o(arguments[0]), w = 1; w < m.length; w++) {
              var A = m[w], z = m[w - 1];
              if (y.countSegment(A, z), y.isOnSegment()) return y.getLocation();
            }
            return y.getLocation();
          }
        } }]);
      })(), Fo = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "isOnLine", value: function() {
          if (arguments[0] instanceof H && Ee(arguments[1], Me)) {
            for (var n = arguments[0], i = arguments[1], a = new Yr(), c = new H(), g = new H(), m = i.size(), y = 1; y < m; y++) if (i.getCoordinate(y - 1, c), i.getCoordinate(y, g), a.computeIntersection(n, c, g), a.hasIntersection()) return true;
            return false;
          }
          if (arguments[0] instanceof H && arguments[1] instanceof Array) {
            for (var w = arguments[0], A = arguments[1], z = new Yr(), V = 1; V < A.length; V++) {
              var ee = A[V - 1], ue = A[V];
              if (z.computeIntersection(w, ee, ue), z.hasIntersection()) return true;
            }
            return false;
          }
        } }, { key: "locateInRing", value: function(n, i) {
          return qp.locatePointInRing(n, i);
        } }, { key: "isInRing", value: function(n, i) {
          return o.locateInRing(n, i) !== N.EXTERIOR;
        } }]);
      })(), Vt = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "setAllLocations", value: function(n) {
          for (var i = 0; i < this.location.length; i++) this.location[i] = n;
        } }, { key: "isNull", value: function() {
          for (var n = 0; n < this.location.length; n++) if (this.location[n] !== N.NONE) return false;
          return true;
        } }, { key: "setAllLocationsIfNull", value: function(n) {
          for (var i = 0; i < this.location.length; i++) this.location[i] === N.NONE && (this.location[i] = n);
        } }, { key: "isLine", value: function() {
          return this.location.length === 1;
        } }, { key: "merge", value: function(n) {
          if (n.location.length > this.location.length) {
            var i = new Array(3).fill(null);
            i[re.ON] = this.location[re.ON], i[re.LEFT] = N.NONE, i[re.RIGHT] = N.NONE, this.location = i;
          }
          for (var a = 0; a < this.location.length; a++) this.location[a] === N.NONE && a < n.location.length && (this.location[a] = n.location[a]);
        } }, { key: "getLocations", value: function() {
          return this.location;
        } }, { key: "flip", value: function() {
          if (this.location.length <= 1) return null;
          var n = this.location[re.LEFT];
          this.location[re.LEFT] = this.location[re.RIGHT], this.location[re.RIGHT] = n;
        } }, { key: "toString", value: function() {
          var n = new cn();
          return this.location.length > 1 && n.append(N.toLocationSymbol(this.location[re.LEFT])), n.append(N.toLocationSymbol(this.location[re.ON])), this.location.length > 1 && n.append(N.toLocationSymbol(this.location[re.RIGHT])), n.toString();
        } }, { key: "setLocations", value: function(n, i, a) {
          this.location[re.ON] = n, this.location[re.LEFT] = i, this.location[re.RIGHT] = a;
        } }, { key: "get", value: function(n) {
          return n < this.location.length ? this.location[n] : N.NONE;
        } }, { key: "isArea", value: function() {
          return this.location.length > 1;
        } }, { key: "isAnyNull", value: function() {
          for (var n = 0; n < this.location.length; n++) if (this.location[n] === N.NONE) return true;
          return false;
        } }, { key: "setLocation", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            this.setLocation(re.ON, n);
          } else if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            this.location[i] = a;
          }
        } }, { key: "init", value: function(n) {
          this.location = new Array(n).fill(null), this.setAllLocations(N.NONE);
        } }, { key: "isEqualOnSide", value: function(n, i) {
          return this.location[i] === n.location[i];
        } }, { key: "allPositionsEqual", value: function(n) {
          for (var i = 0; i < this.location.length; i++) if (this.location[i] !== n) return false;
          return true;
        } }], [{ key: "constructor_", value: function() {
          if (this.location = null, arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var n = arguments[0];
              this.init(n.length);
            } else if (Number.isInteger(arguments[0])) {
              var i = arguments[0];
              this.init(1), this.location[re.ON] = i;
            } else if (arguments[0] instanceof o) {
              var a = arguments[0];
              if (this.init(a.location.length), a !== null) for (var c = 0; c < this.location.length; c++) this.location[c] = a.location[c];
            }
          } else if (arguments.length === 3) {
            var g = arguments[0], m = arguments[1], y = arguments[2];
            this.init(3), this.location[re.ON] = g, this.location[re.LEFT] = m, this.location[re.RIGHT] = y;
          }
        } }]);
      })(), Xt = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "getGeometryCount", value: function() {
          var n = 0;
          return this.elt[0].isNull() || n++, this.elt[1].isNull() || n++, n;
        } }, { key: "setAllLocations", value: function(n, i) {
          this.elt[n].setAllLocations(i);
        } }, { key: "isNull", value: function(n) {
          return this.elt[n].isNull();
        } }, { key: "setAllLocationsIfNull", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            this.setAllLocationsIfNull(0, n), this.setAllLocationsIfNull(1, n);
          } else if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            this.elt[i].setAllLocationsIfNull(a);
          }
        } }, { key: "isLine", value: function(n) {
          return this.elt[n].isLine();
        } }, { key: "merge", value: function(n) {
          for (var i = 0; i < 2; i++) this.elt[i] === null && n.elt[i] !== null ? this.elt[i] = new Vt(n.elt[i]) : this.elt[i].merge(n.elt[i]);
        } }, { key: "flip", value: function() {
          this.elt[0].flip(), this.elt[1].flip();
        } }, { key: "getLocation", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            return this.elt[n].get(re.ON);
          }
          if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            return this.elt[i].get(a);
          }
        } }, { key: "toString", value: function() {
          var n = new cn();
          return this.elt[0] !== null && (n.append("A:"), n.append(this.elt[0].toString())), this.elt[1] !== null && (n.append(" B:"), n.append(this.elt[1].toString())), n.toString();
        } }, { key: "isArea", value: function() {
          if (arguments.length === 0) return this.elt[0].isArea() || this.elt[1].isArea();
          if (arguments.length === 1) {
            var n = arguments[0];
            return this.elt[n].isArea();
          }
        } }, { key: "isAnyNull", value: function(n) {
          return this.elt[n].isAnyNull();
        } }, { key: "setLocation", value: function() {
          if (arguments.length === 2) {
            var n = arguments[0], i = arguments[1];
            this.elt[n].setLocation(re.ON, i);
          } else if (arguments.length === 3) {
            var a = arguments[0], c = arguments[1], g = arguments[2];
            this.elt[a].setLocation(c, g);
          }
        } }, { key: "isEqualOnSide", value: function(n, i) {
          return this.elt[0].isEqualOnSide(n.elt[0], i) && this.elt[1].isEqualOnSide(n.elt[1], i);
        } }, { key: "allPositionsEqual", value: function(n, i) {
          return this.elt[n].allPositionsEqual(i);
        } }, { key: "toLine", value: function(n) {
          this.elt[n].isArea() && (this.elt[n] = new Vt(this.elt[n].location[0]));
        } }], [{ key: "constructor_", value: function() {
          if (this.elt = new Array(2).fill(null), arguments.length === 1) {
            if (Number.isInteger(arguments[0])) {
              var n = arguments[0];
              this.elt[0] = new Vt(n), this.elt[1] = new Vt(n);
            } else if (arguments[0] instanceof o) {
              var i = arguments[0];
              this.elt[0] = new Vt(i.elt[0]), this.elt[1] = new Vt(i.elt[1]);
            }
          } else if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            this.elt[0] = new Vt(N.NONE), this.elt[1] = new Vt(N.NONE), this.elt[a].setLocation(c);
          } else if (arguments.length === 3) {
            var g = arguments[0], m = arguments[1], y = arguments[2];
            this.elt[0] = new Vt(g, m, y), this.elt[1] = new Vt(g, m, y);
          } else if (arguments.length === 4) {
            var w = arguments[0], A = arguments[1], z = arguments[2], V = arguments[3];
            this.elt[0] = new Vt(N.NONE, N.NONE, N.NONE), this.elt[1] = new Vt(N.NONE, N.NONE, N.NONE), this.elt[w].setLocations(A, z, V);
          }
        } }, { key: "toLineLabel", value: function(n) {
          for (var i = new o(N.NONE), a = 0; a < 2; a++) i.setLocation(a, n.getLocation(a));
          return i;
        } }]);
      })(), ma = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "computeRing", value: function() {
          if (this._ring !== null) return null;
          for (var o = new Array(this._pts.size()).fill(null), n = 0; n < this._pts.size(); n++) o[n] = this._pts.get(n);
          this._ring = this._geometryFactory.createLinearRing(o), this._isHole = ye.isCCW(this._ring.getCoordinates());
        } }, { key: "isIsolated", value: function() {
          return this._label.getGeometryCount() === 1;
        } }, { key: "computePoints", value: function(o) {
          this._startDe = o;
          var n = o, i = true;
          do {
            if (n === null) throw new Nt("Found null DirectedEdge");
            if (n.getEdgeRing() === this) throw new Nt("Directed Edge visited twice during ring-building at " + n.getCoordinate());
            this._edges.add(n);
            var a = n.getLabel();
            ae.isTrue(a.isArea()), this.mergeLabel(a), this.addPoints(n.getEdge(), n.isForward(), i), i = false, this.setEdgeRing(n, this), n = this.getNext(n);
          } while (n !== this._startDe);
        } }, { key: "getLinearRing", value: function() {
          return this._ring;
        } }, { key: "getCoordinate", value: function(o) {
          return this._pts.get(o);
        } }, { key: "computeMaxNodeDegree", value: function() {
          this._maxNodeDegree = 0;
          var o = this._startDe;
          do {
            var n = o.getNode().getEdges().getOutgoingDegree(this);
            n > this._maxNodeDegree && (this._maxNodeDegree = n), o = this.getNext(o);
          } while (o !== this._startDe);
          this._maxNodeDegree *= 2;
        } }, { key: "addPoints", value: function(o, n, i) {
          var a = o.getCoordinates();
          if (n) {
            var c = 1;
            i && (c = 0);
            for (var g = c; g < a.length; g++) this._pts.add(a[g]);
          } else {
            var m = a.length - 2;
            i && (m = a.length - 1);
            for (var y = m; y >= 0; y--) this._pts.add(a[y]);
          }
        } }, { key: "isHole", value: function() {
          return this._isHole;
        } }, { key: "setInResult", value: function() {
          var o = this._startDe;
          do
            o.getEdge().setInResult(true), o = o.getNext();
          while (o !== this._startDe);
        } }, { key: "containsPoint", value: function(o) {
          var n = this.getLinearRing();
          if (!n.getEnvelopeInternal().contains(o) || !Fo.isInRing(o, n.getCoordinates())) return false;
          for (var i = this._holes.iterator(); i.hasNext(); )
            if (i.next().containsPoint(o)) return false;
          return true;
        } }, { key: "addHole", value: function(o) {
          this._holes.add(o);
        } }, { key: "isShell", value: function() {
          return this._shell === null;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "getMaxNodeDegree", value: function() {
          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
        } }, { key: "getShell", value: function() {
          return this._shell;
        } }, { key: "mergeLabel", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.mergeLabel(o, 0), this.mergeLabel(o, 1);
          } else if (arguments.length === 2) {
            var n = arguments[1], i = arguments[0].getLocation(n, re.RIGHT);
            if (i === N.NONE) return null;
            if (this._label.getLocation(n) === N.NONE) return this._label.setLocation(n, i), null;
          }
        } }, { key: "setShell", value: function(o) {
          this._shell = o, o !== null && o.addHole(this);
        } }, { key: "toPolygon", value: function(o) {
          for (var n = new Array(this._holes.size()).fill(null), i = 0; i < this._holes.size(); i++) n[i] = this._holes.get(i).getLinearRing();
          return o.createPolygon(this.getLinearRing(), n);
        } }], [{ key: "constructor_", value: function() {
          if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new pe(), this._pts = new pe(), this._label = new Xt(N.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new pe(), this._geometryFactory = null, arguments.length !== 0) {
            if (arguments.length === 2) {
              var o = arguments[0], n = arguments[1];
              this._geometryFactory = n, this.computePoints(o), this.computeRing();
            }
          }
        } }]);
      })(), Yp = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "setEdgeRing", value: function(i, a) {
          i.setMinEdgeRing(a);
        } }, { key: "getNext", value: function(i) {
          return i.getNextMin();
        } }], [{ key: "constructor_", value: function() {
          var i = arguments[0], a = arguments[1];
          ma.constructor_.call(this, i, a);
        } }]);
      })(ma), Hp = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "buildMinimalRings", value: function() {
          var i = new pe(), a = this._startDe;
          do {
            if (a.getMinEdgeRing() === null) {
              var c = new Yp(a, this._geometryFactory);
              i.add(c);
            }
            a = a.getNext();
          } while (a !== this._startDe);
          return i;
        } }, { key: "setEdgeRing", value: function(i, a) {
          i.setEdgeRing(a);
        } }, { key: "linkDirectedEdgesForMinimalEdgeRings", value: function() {
          var i = this._startDe;
          do
            i.getNode().getEdges().linkMinimalDirectedEdges(this), i = i.getNext();
          while (i !== this._startDe);
        } }, { key: "getNext", value: function(i) {
          return i.getNext();
        } }], [{ key: "constructor_", value: function() {
          var i = arguments[0], a = arguments[1];
          ma.constructor_.call(this, i, a);
        } }]);
      })(ma), cc = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "setVisited", value: function(o) {
          this._isVisited = o;
        } }, { key: "setInResult", value: function(o) {
          this._isInResult = o;
        } }, { key: "isCovered", value: function() {
          return this._isCovered;
        } }, { key: "isCoveredSet", value: function() {
          return this._isCoveredSet;
        } }, { key: "setLabel", value: function(o) {
          this._label = o;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "setCovered", value: function(o) {
          this._isCovered = o, this._isCoveredSet = true;
        } }, { key: "updateIM", value: function(o) {
          ae.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(o);
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          if (this._label = null, this._isInResult = false, this._isCovered = false, this._isCoveredSet = false, this._isVisited = false, arguments.length !== 0) {
            if (arguments.length === 1) {
              var o = arguments[0];
              this._label = o;
            }
          }
        } }]);
      })(), va = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "isIncidentEdgeInResult", value: function() {
          for (var i = this.getEdges().getEdges().iterator(); i.hasNext(); )
            if (i.next().getEdge().isInResult()) return true;
          return false;
        } }, { key: "isIsolated", value: function() {
          return this._label.getGeometryCount() === 1;
        } }, { key: "getCoordinate", value: function() {
          return this._coord;
        } }, { key: "print", value: function(i) {
          i.println("node " + this._coord + " lbl: " + this._label);
        } }, { key: "computeIM", value: function(i) {
        } }, { key: "computeMergedLocation", value: function(i, a) {
          var c = N.NONE;
          if (c = this._label.getLocation(a), !i.isNull(a)) {
            var g = i.getLocation(a);
            c !== N.BOUNDARY && (c = g);
          }
          return c;
        } }, { key: "setLabel", value: function() {
          if (arguments.length !== 2 || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return I(n, "setLabel", this, 1).apply(this, arguments);
          var i = arguments[0], a = arguments[1];
          this._label === null ? this._label = new Xt(i, a) : this._label.setLocation(i, a);
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "mergeLabel", value: function() {
          if (arguments[0] instanceof n) {
            var i = arguments[0];
            this.mergeLabel(i._label);
          } else if (arguments[0] instanceof Xt) for (var a = arguments[0], c = 0; c < 2; c++) {
            var g = this.computeMergedLocation(a, c);
            this._label.getLocation(c) === N.NONE && this._label.setLocation(c, g);
          }
        } }, { key: "add", value: function(i) {
          this._edges.insert(i), i.setNode(this);
        } }, { key: "setLabelBoundary", value: function(i) {
          if (this._label === null) return null;
          var a = N.NONE;
          this._label !== null && (a = this._label.getLocation(i));
          var c = null;
          switch (a) {
            case N.BOUNDARY:
              c = N.INTERIOR;
              break;
            case N.INTERIOR:
            default:
              c = N.BOUNDARY;
          }
          this._label.setLocation(i, c);
        } }], [{ key: "constructor_", value: function() {
          this._coord = null, this._edges = null;
          var i = arguments[0], a = arguments[1];
          this._coord = i, this._edges = a, this._label = new Xt(0, N.NONE);
        } }]);
      })(cc), Jp = (function(o) {
        function n() {
          return u(this, n), s(this, n, arguments);
        }
        return _(n, o), h(n);
      })(Kn);
      function hc(o) {
        return o == null ? 0 : o.color;
      }
      function Pe(o) {
        return o == null ? null : o.parent;
      }
      function On(o, n) {
        o !== null && (o.color = n);
      }
      function Go(o) {
        return o == null ? null : o.left;
      }
      function fc(o) {
        return o == null ? null : o.right;
      }
      var ls = (function(o) {
        function n() {
          var i;
          return u(this, n), (i = s(this, n)).root_ = null, i.size_ = 0, i;
        }
        return _(n, o), h(n, [{ key: "get", value: function(i) {
          for (var a = this.root_; a !== null; ) {
            var c = i.compareTo(a.key);
            if (c < 0) a = a.left;
            else {
              if (!(c > 0)) return a.value;
              a = a.right;
            }
          }
          return null;
        } }, { key: "put", value: function(i, a) {
          if (this.root_ === null) return this.root_ = { key: i, value: a, left: null, right: null, parent: null, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } }, this.size_ = 1, null;
          var c, g, m = this.root_;
          do
            if (c = m, (g = i.compareTo(m.key)) < 0) m = m.left;
            else {
              if (!(g > 0)) {
                var y = m.value;
                return m.value = a, y;
              }
              m = m.right;
            }
          while (m !== null);
          var w = { key: i, left: null, right: null, value: a, parent: c, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } };
          return g < 0 ? c.left = w : c.right = w, this.fixAfterInsertion(w), this.size_++, null;
        } }, { key: "fixAfterInsertion", value: function(i) {
          var a;
          for (i.color = 1; i != null && i !== this.root_ && i.parent.color === 1; ) Pe(i) === Go(Pe(Pe(i))) ? hc(a = fc(Pe(Pe(i)))) === 1 ? (On(Pe(i), 0), On(a, 0), On(Pe(Pe(i)), 1), i = Pe(Pe(i))) : (i === fc(Pe(i)) && (i = Pe(i), this.rotateLeft(i)), On(Pe(i), 0), On(Pe(Pe(i)), 1), this.rotateRight(Pe(Pe(i)))) : hc(a = Go(Pe(Pe(i)))) === 1 ? (On(Pe(i), 0), On(a, 0), On(Pe(Pe(i)), 1), i = Pe(Pe(i))) : (i === Go(Pe(i)) && (i = Pe(i), this.rotateRight(i)), On(Pe(i), 0), On(Pe(Pe(i)), 1), this.rotateLeft(Pe(Pe(i))));
          this.root_.color = 0;
        } }, { key: "values", value: function() {
          var i = new pe(), a = this.getFirstEntry();
          if (a !== null) for (i.add(a.value); (a = n.successor(a)) !== null; ) i.add(a.value);
          return i;
        } }, { key: "entrySet", value: function() {
          var i = new Gr(), a = this.getFirstEntry();
          if (a !== null) for (i.add(a); (a = n.successor(a)) !== null; ) i.add(a);
          return i;
        } }, { key: "rotateLeft", value: function(i) {
          if (i != null) {
            var a = i.right;
            i.right = a.left, a.left != null && (a.left.parent = i), a.parent = i.parent, i.parent == null ? this.root_ = a : i.parent.left === i ? i.parent.left = a : i.parent.right = a, a.left = i, i.parent = a;
          }
        } }, { key: "rotateRight", value: function(i) {
          if (i != null) {
            var a = i.left;
            i.left = a.right, a.right != null && (a.right.parent = i), a.parent = i.parent, i.parent == null ? this.root_ = a : i.parent.right === i ? i.parent.right = a : i.parent.left = a, a.right = i, i.parent = a;
          }
        } }, { key: "getFirstEntry", value: function() {
          var i = this.root_;
          if (i != null) for (; i.left != null; ) i = i.left;
          return i;
        } }, { key: "size", value: function() {
          return this.size_;
        } }, { key: "containsKey", value: function(i) {
          for (var a = this.root_; a !== null; ) {
            var c = i.compareTo(a.key);
            if (c < 0) a = a.left;
            else {
              if (!(c > 0)) return true;
              a = a.right;
            }
          }
          return false;
        } }], [{ key: "successor", value: function(i) {
          var a;
          if (i === null) return null;
          if (i.right !== null) {
            for (a = i.right; a.left !== null; ) a = a.left;
            return a;
          }
          a = i.parent;
          for (var c = i; a !== null && c === a.right; ) c = a, a = a.parent;
          return a;
        } }]);
      })(Jp), gc = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "find", value: function(o) {
          return this.nodeMap.get(o);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof H) {
            var o = arguments[0], n = this.nodeMap.get(o);
            return n === null && (n = this.nodeFact.createNode(o), this.nodeMap.put(o, n)), n;
          }
          if (arguments[0] instanceof va) {
            var i = arguments[0], a = this.nodeMap.get(i.getCoordinate());
            return a === null ? (this.nodeMap.put(i.getCoordinate(), i), i) : (a.mergeLabel(i), a);
          }
        } }, { key: "print", value: function(o) {
          for (var n = this.iterator(); n.hasNext(); )
            n.next().print(o);
        } }, { key: "iterator", value: function() {
          return this.nodeMap.values().iterator();
        } }, { key: "values", value: function() {
          return this.nodeMap.values();
        } }, { key: "getBoundaryNodes", value: function(o) {
          for (var n = new pe(), i = this.iterator(); i.hasNext(); ) {
            var a = i.next();
            a.getLabel().getLocation(o) === N.BOUNDARY && n.add(a);
          }
          return n;
        } }, { key: "add", value: function(o) {
          var n = o.getCoordinate();
          this.addNode(n).add(o);
        } }], [{ key: "constructor_", value: function() {
          this.nodeMap = new ls(), this.nodeFact = null;
          var o = arguments[0];
          this.nodeFact = o;
        } }]);
      })(), xt = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "isNorthern", value: function(n) {
          return n === o.NE || n === o.NW;
        } }, { key: "isOpposite", value: function(n, i) {
          return n !== i && (n - i + 4) % 4 === 2;
        } }, { key: "commonHalfPlane", value: function(n, i) {
          if (n === i) return n;
          if ((n - i + 4) % 4 === 2) return -1;
          var a = n < i ? n : i;
          return a === 0 && (n > i ? n : i) === 3 ? 3 : a;
        } }, { key: "isInHalfPlane", value: function(n, i) {
          return i === o.SE ? n === o.SE || n === o.SW : n === i || n === i + 1;
        } }, { key: "quadrant", value: function() {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var n = arguments[0], i = arguments[1];
            if (n === 0 && i === 0) throw new $("Cannot compute the quadrant for point ( " + n + ", " + i + " )");
            return n >= 0 ? i >= 0 ? o.NE : o.SE : i >= 0 ? o.NW : o.SW;
          }
          if (arguments[0] instanceof H && arguments[1] instanceof H) {
            var a = arguments[0], c = arguments[1];
            if (c.x === a.x && c.y === a.y) throw new $("Cannot compute the quadrant for two identical points " + a);
            return c.x >= a.x ? c.y >= a.y ? o.NE : o.SE : c.y >= a.y ? o.NW : o.SW;
          }
        } }]);
      })();
      xt.NE = 0, xt.NW = 1, xt.SW = 2, xt.SE = 3;
      var dc = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "compareDirection", value: function(n) {
          return this._dx === n._dx && this._dy === n._dy ? 0 : this._quadrant > n._quadrant ? 1 : this._quadrant < n._quadrant ? -1 : ye.index(n._p0, n._p1, this._p1);
        } }, { key: "getDy", value: function() {
          return this._dy;
        } }, { key: "getCoordinate", value: function() {
          return this._p0;
        } }, { key: "setNode", value: function(n) {
          this._node = n;
        } }, { key: "print", value: function(n) {
          var i = Math.atan2(this._dy, this._dx), a = this.getClass().getName(), c = a.lastIndexOf("."), g = a.substring(c + 1);
          n.print("  " + g + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + i + "   " + this._label);
        } }, { key: "compareTo", value: function(n) {
          var i = n;
          return this.compareDirection(i);
        } }, { key: "getDirectedCoordinate", value: function() {
          return this._p1;
        } }, { key: "getDx", value: function() {
          return this._dx;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "getQuadrant", value: function() {
          return this._quadrant;
        } }, { key: "getNode", value: function() {
          return this._node;
        } }, { key: "toString", value: function() {
          var n = Math.atan2(this._dy, this._dx), i = this.getClass().getName(), a = i.lastIndexOf(".");
          return "  " + i.substring(a + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + n + "   " + this._label;
        } }, { key: "computeLabel", value: function(n) {
        } }, { key: "init", value: function(n, i) {
          this._p0 = n, this._p1 = i, this._dx = i.x - n.x, this._dy = i.y - n.y, this._quadrant = xt.quadrant(this._dx, this._dy), ae.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
        } }, { key: "interfaces_", get: function() {
          return [j];
        } }], [{ key: "constructor_", value: function() {
          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) {
            var n = arguments[0];
            this._edge = n;
          } else if (arguments.length === 3) {
            var i = arguments[0], a = arguments[1], c = arguments[2];
            o.constructor_.call(this, i, a, c, null);
          } else if (arguments.length === 4) {
            var g = arguments[0], m = arguments[1], y = arguments[2], w = arguments[3];
            o.constructor_.call(this, g), this.init(m, y), this._label = w;
          }
        } }]);
      })(), Bo = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "getNextMin", value: function() {
          return this._nextMin;
        } }, { key: "getDepth", value: function(i) {
          return this._depth[i];
        } }, { key: "setVisited", value: function(i) {
          this._isVisited = i;
        } }, { key: "computeDirectedLabel", value: function() {
          this._label = new Xt(this._edge.getLabel()), this._isForward || this._label.flip();
        } }, { key: "getNext", value: function() {
          return this._next;
        } }, { key: "setDepth", value: function(i, a) {
          if (this._depth[i] !== -999 && this._depth[i] !== a) throw new Nt("assigned depths do not match", this.getCoordinate());
          this._depth[i] = a;
        } }, { key: "isInteriorAreaEdge", value: function() {
          for (var i = true, a = 0; a < 2; a++) this._label.isArea(a) && this._label.getLocation(a, re.LEFT) === N.INTERIOR && this._label.getLocation(a, re.RIGHT) === N.INTERIOR || (i = false);
          return i;
        } }, { key: "setNextMin", value: function(i) {
          this._nextMin = i;
        } }, { key: "print", value: function(i) {
          I(n, "print", this, 1).call(this, i), i.print(" " + this._depth[re.LEFT] + "/" + this._depth[re.RIGHT]), i.print(" (" + this.getDepthDelta() + ")"), this._isInResult && i.print(" inResult");
        } }, { key: "setMinEdgeRing", value: function(i) {
          this._minEdgeRing = i;
        } }, { key: "isLineEdge", value: function() {
          var i = this._label.isLine(0) || this._label.isLine(1), a = !this._label.isArea(0) || this._label.allPositionsEqual(0, N.EXTERIOR), c = !this._label.isArea(1) || this._label.allPositionsEqual(1, N.EXTERIOR);
          return i && a && c;
        } }, { key: "setEdgeRing", value: function(i) {
          this._edgeRing = i;
        } }, { key: "getMinEdgeRing", value: function() {
          return this._minEdgeRing;
        } }, { key: "getDepthDelta", value: function() {
          var i = this._edge.getDepthDelta();
          return this._isForward || (i = -i), i;
        } }, { key: "setInResult", value: function(i) {
          this._isInResult = i;
        } }, { key: "getSym", value: function() {
          return this._sym;
        } }, { key: "isForward", value: function() {
          return this._isForward;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "printEdge", value: function(i) {
          this.print(i), i.print(" "), this._isForward ? this._edge.print(i) : this._edge.printReverse(i);
        } }, { key: "setSym", value: function(i) {
          this._sym = i;
        } }, { key: "setVisitedEdge", value: function(i) {
          this.setVisited(i), this._sym.setVisited(i);
        } }, { key: "setEdgeDepths", value: function(i, a) {
          var c = this.getEdge().getDepthDelta();
          this._isForward || (c = -c);
          var g = 1;
          i === re.LEFT && (g = -1);
          var m = re.opposite(i), y = a + c * g;
          this.setDepth(i, a), this.setDepth(m, y);
        } }, { key: "getEdgeRing", value: function() {
          return this._edgeRing;
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "setNext", value: function(i) {
          this._next = i;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          this._isForward = null, this._isInResult = false, this._isVisited = false, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];
          var i = arguments[0], a = arguments[1];
          if (dc.constructor_.call(this, i), this._isForward = a, a) this.init(i.getCoordinate(0), i.getCoordinate(1));
          else {
            var c = i.getNumPoints() - 1;
            this.init(i.getCoordinate(c), i.getCoordinate(c - 1));
          }
          this.computeDirectedLabel();
        } }, { key: "depthFactor", value: function(i, a) {
          return i === N.EXTERIOR && a === N.INTERIOR ? 1 : i === N.INTERIOR && a === N.EXTERIOR ? -1 : 0;
        } }]);
      })(dc), pc = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "createNode", value: function(o) {
          return new va(o, null);
        } }]);
      })(), mc = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "printEdges", value: function(o) {
          o.println("Edges:");
          for (var n = 0; n < this._edges.size(); n++) {
            o.println("edge " + n + ":");
            var i = this._edges.get(n);
            i.print(o), i.eiList.print(o);
          }
        } }, { key: "find", value: function(o) {
          return this._nodes.find(o);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof va) {
            var o = arguments[0];
            return this._nodes.addNode(o);
          }
          if (arguments[0] instanceof H) {
            var n = arguments[0];
            return this._nodes.addNode(n);
          }
        } }, { key: "getNodeIterator", value: function() {
          return this._nodes.iterator();
        } }, { key: "linkResultDirectedEdges", value: function() {
          for (var o = this._nodes.iterator(); o.hasNext(); )
            o.next().getEdges().linkResultDirectedEdges();
        } }, { key: "debugPrintln", value: function(o) {
          Pt.out.println(o);
        } }, { key: "isBoundaryNode", value: function(o, n) {
          var i = this._nodes.find(n);
          if (i === null) return false;
          var a = i.getLabel();
          return a !== null && a.getLocation(o) === N.BOUNDARY;
        } }, { key: "linkAllDirectedEdges", value: function() {
          for (var o = this._nodes.iterator(); o.hasNext(); )
            o.next().getEdges().linkAllDirectedEdges();
        } }, { key: "matchInSameDirection", value: function(o, n, i, a) {
          return !!o.equals(i) && ye.index(o, n, a) === ye.COLLINEAR && xt.quadrant(o, n) === xt.quadrant(i, a);
        } }, { key: "getEdgeEnds", value: function() {
          return this._edgeEndList;
        } }, { key: "debugPrint", value: function(o) {
          Pt.out.print(o);
        } }, { key: "getEdgeIterator", value: function() {
          return this._edges.iterator();
        } }, { key: "findEdgeInSameDirection", value: function(o, n) {
          for (var i = 0; i < this._edges.size(); i++) {
            var a = this._edges.get(i), c = a.getCoordinates();
            if (this.matchInSameDirection(o, n, c[0], c[1]) || this.matchInSameDirection(o, n, c[c.length - 1], c[c.length - 2])) return a;
          }
          return null;
        } }, { key: "insertEdge", value: function(o) {
          this._edges.add(o);
        } }, { key: "findEdgeEnd", value: function(o) {
          for (var n = this.getEdgeEnds().iterator(); n.hasNext(); ) {
            var i = n.next();
            if (i.getEdge() === o) return i;
          }
          return null;
        } }, { key: "addEdges", value: function(o) {
          for (var n = o.iterator(); n.hasNext(); ) {
            var i = n.next();
            this._edges.add(i);
            var a = new Bo(i, true), c = new Bo(i, false);
            a.setSym(c), c.setSym(a), this.add(a), this.add(c);
          }
        } }, { key: "add", value: function(o) {
          this._nodes.add(o), this._edgeEndList.add(o);
        } }, { key: "getNodes", value: function() {
          return this._nodes.values();
        } }, { key: "findEdge", value: function(o, n) {
          for (var i = 0; i < this._edges.size(); i++) {
            var a = this._edges.get(i), c = a.getCoordinates();
            if (o.equals(c[0]) && n.equals(c[1])) return a;
          }
          return null;
        } }], [{ key: "constructor_", value: function() {
          if (this._edges = new pe(), this._nodes = null, this._edgeEndList = new pe(), arguments.length === 0) this._nodes = new gc(new pc());
          else if (arguments.length === 1) {
            var o = arguments[0];
            this._nodes = new gc(o);
          }
        } }, { key: "linkResultDirectedEdges", value: function(o) {
          for (var n = o.iterator(); n.hasNext(); )
            n.next().getEdges().linkResultDirectedEdges();
        } }]);
      })(), $p = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "sortShellsAndHoles", value: function(n, i, a) {
          for (var c = n.iterator(); c.hasNext(); ) {
            var g = c.next();
            g.isHole() ? a.add(g) : i.add(g);
          }
        } }, { key: "computePolygons", value: function(n) {
          for (var i = new pe(), a = n.iterator(); a.hasNext(); ) {
            var c = a.next().toPolygon(this._geometryFactory);
            i.add(c);
          }
          return i;
        } }, { key: "placeFreeHoles", value: function(n, i) {
          for (var a = i.iterator(); a.hasNext(); ) {
            var c = a.next();
            if (c.getShell() === null) {
              var g = o.findEdgeRingContaining(c, n);
              if (g === null) throw new Nt("unable to assign hole to a shell", c.getCoordinate(0));
              c.setShell(g);
            }
          }
        } }, { key: "buildMinimalEdgeRings", value: function(n, i, a) {
          for (var c = new pe(), g = n.iterator(); g.hasNext(); ) {
            var m = g.next();
            if (m.getMaxNodeDegree() > 2) {
              m.linkDirectedEdgesForMinimalEdgeRings();
              var y = m.buildMinimalRings(), w = this.findShell(y);
              w !== null ? (this.placePolygonHoles(w, y), i.add(w)) : a.addAll(y);
            } else c.add(m);
          }
          return c;
        } }, { key: "buildMaximalEdgeRings", value: function(n) {
          for (var i = new pe(), a = n.iterator(); a.hasNext(); ) {
            var c = a.next();
            if (c.isInResult() && c.getLabel().isArea() && c.getEdgeRing() === null) {
              var g = new Hp(c, this._geometryFactory);
              i.add(g), g.setInResult();
            }
          }
          return i;
        } }, { key: "placePolygonHoles", value: function(n, i) {
          for (var a = i.iterator(); a.hasNext(); ) {
            var c = a.next();
            c.isHole() && c.setShell(n);
          }
        } }, { key: "getPolygons", value: function() {
          return this.computePolygons(this._shellList);
        } }, { key: "findShell", value: function(n) {
          for (var i = 0, a = null, c = n.iterator(); c.hasNext(); ) {
            var g = c.next();
            g.isHole() || (a = g, i++);
          }
          return ae.isTrue(i <= 1, "found two shells in MinimalEdgeRing list"), a;
        } }, { key: "add", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            this.add(n.getEdgeEnds(), n.getNodes());
          } else if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            mc.linkResultDirectedEdges(a);
            var c = this.buildMaximalEdgeRings(i), g = new pe(), m = this.buildMinimalEdgeRings(c, this._shellList, g);
            this.sortShellsAndHoles(m, this._shellList, g), this.placeFreeHoles(this._shellList, g);
          }
        } }], [{ key: "constructor_", value: function() {
          this._geometryFactory = null, this._shellList = new pe();
          var n = arguments[0];
          this._geometryFactory = n;
        } }, { key: "findEdgeRingContaining", value: function(n, i) {
          for (var a = n.getLinearRing(), c = a.getEnvelopeInternal(), g = a.getCoordinateN(0), m = null, y = null, w = i.iterator(); w.hasNext(); ) {
            var A = w.next(), z = A.getLinearRing(), V = z.getEnvelopeInternal();
            if (!V.equals(c) && V.contains(c)) {
              g = Q.ptNotInList(a.getCoordinates(), z.getCoordinates());
              var ee = false;
              Fo.isInRing(g, z.getCoordinates()) && (ee = true), ee && (m === null || y.contains(V)) && (y = (m = A).getLinearRing().getEnvelopeInternal());
            }
          }
          return m;
        } }]);
      })(), vc = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "getBounds", value: function() {
        } }]);
      })(), tr = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "getItem", value: function() {
          return this._item;
        } }, { key: "getBounds", value: function() {
          return this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [vc, k];
        } }], [{ key: "constructor_", value: function() {
          this._bounds = null, this._item = null;
          var o = arguments[0], n = arguments[1];
          this._bounds = o, this._item = n;
        } }]);
      })(), ya = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "poll", value: function() {
          if (this.isEmpty()) return null;
          var o = this._items.get(1);
          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), o;
        } }, { key: "size", value: function() {
          return this._size;
        } }, { key: "reorder", value: function(o) {
          for (var n = null, i = this._items.get(o); 2 * o <= this._size && ((n = 2 * o) !== this._size && this._items.get(n + 1).compareTo(this._items.get(n)) < 0 && n++, this._items.get(n).compareTo(i) < 0); o = n) this._items.set(o, this._items.get(n));
          this._items.set(o, i);
        } }, { key: "clear", value: function() {
          this._size = 0, this._items.clear();
        } }, { key: "peek", value: function() {
          return this.isEmpty() ? null : this._items.get(1);
        } }, { key: "isEmpty", value: function() {
          return this._size === 0;
        } }, { key: "add", value: function(o) {
          this._items.add(null), this._size += 1;
          var n = this._size;
          for (this._items.set(0, o); o.compareTo(this._items.get(Math.trunc(n / 2))) < 0; n /= 2) this._items.set(n, this._items.get(Math.trunc(n / 2)));
          this._items.set(n, o);
        } }], [{ key: "constructor_", value: function() {
          this._size = null, this._items = null, this._size = 0, this._items = new pe(), this._items.add(null);
        } }]);
      })(), Vp = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "insert", value: function(o, n) {
        } }, { key: "remove", value: function(o, n) {
        } }, { key: "query", value: function() {
        } }]);
      })(), Wt = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "getLevel", value: function() {
          return this._level;
        } }, { key: "size", value: function() {
          return this._childBoundables.size();
        } }, { key: "getChildBoundables", value: function() {
          return this._childBoundables;
        } }, { key: "addChildBoundable", value: function(o) {
          ae.isTrue(this._bounds === null), this._childBoundables.add(o);
        } }, { key: "isEmpty", value: function() {
          return this._childBoundables.isEmpty();
        } }, { key: "getBounds", value: function() {
          return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [vc, k];
        } }], [{ key: "constructor_", value: function() {
          if (this._childBoundables = new pe(), this._bounds = null, this._level = null, arguments.length !== 0) {
            if (arguments.length === 1) {
              var o = arguments[0];
              this._level = o;
            }
          }
        } }]);
      })(), xi = { reverseOrder: function() {
        return { compare: function(o, n) {
          return n.compareTo(o);
        } };
      }, min: function(o) {
        return xi.sort(o), o.get(0);
      }, sort: function(o, n) {
        var i = o.toArray();
        n ? rt.sort(i, n) : rt.sort(i);
        for (var a = o.iterator(), c = 0, g = i.length; c < g; c++) a.next(), a.set(i[c]);
      }, singletonList: function(o) {
        var n = new pe();
        return n.add(o), n;
      } }, Xp = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "maxDistance", value: function(n, i, a, c, g, m, y, w) {
          var A = o.distance(n, i, g, m);
          return A = Math.max(A, o.distance(n, i, y, w)), A = Math.max(A, o.distance(a, c, g, m)), A = Math.max(A, o.distance(a, c, y, w));
        } }, { key: "distance", value: function(n, i, a, c) {
          var g = a - n, m = c - i;
          return Math.sqrt(g * g + m * m);
        } }, { key: "maximumDistance", value: function(n, i) {
          var a = Math.min(n.getMinX(), i.getMinX()), c = Math.min(n.getMinY(), i.getMinY()), g = Math.max(n.getMaxX(), i.getMaxX()), m = Math.max(n.getMaxY(), i.getMaxY());
          return o.distance(a, c, g, m);
        } }, { key: "minMaxDistance", value: function(n, i) {
          var a = n.getMinX(), c = n.getMinY(), g = n.getMaxX(), m = n.getMaxY(), y = i.getMinX(), w = i.getMinY(), A = i.getMaxX(), z = i.getMaxY(), V = o.maxDistance(a, c, a, m, y, w, y, z);
          return V = Math.min(V, o.maxDistance(a, c, a, m, y, w, A, w)), V = Math.min(V, o.maxDistance(a, c, a, m, A, z, y, z)), V = Math.min(V, o.maxDistance(a, c, a, m, A, z, A, w)), V = Math.min(V, o.maxDistance(a, c, g, c, y, w, y, z)), V = Math.min(V, o.maxDistance(a, c, g, c, y, w, A, w)), V = Math.min(V, o.maxDistance(a, c, g, c, A, z, y, z)), V = Math.min(V, o.maxDistance(a, c, g, c, A, z, A, w)), V = Math.min(V, o.maxDistance(g, m, a, m, y, w, y, z)), V = Math.min(V, o.maxDistance(g, m, a, m, y, w, A, w)), V = Math.min(V, o.maxDistance(g, m, a, m, A, z, y, z)), V = Math.min(V, o.maxDistance(g, m, a, m, A, z, A, w)), V = Math.min(V, o.maxDistance(g, m, g, c, y, w, y, z)), V = Math.min(V, o.maxDistance(g, m, g, c, y, w, A, w)), V = Math.min(V, o.maxDistance(g, m, g, c, A, z, y, z)), V = Math.min(V, o.maxDistance(g, m, g, c, A, z, A, w));
        } }]);
      })(), wi = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "maximumDistance", value: function() {
          return Xp.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
        } }, { key: "expandToQueue", value: function(n, i) {
          var a = o.isComposite(this._boundable1), c = o.isComposite(this._boundable2);
          if (a && c) return o.area(this._boundable1) > o.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, false, n, i), null) : (this.expand(this._boundable2, this._boundable1, true, n, i), null);
          if (a) return this.expand(this._boundable1, this._boundable2, false, n, i), null;
          if (c) return this.expand(this._boundable2, this._boundable1, true, n, i), null;
          throw new $("neither boundable is composite");
        } }, { key: "isLeaves", value: function() {
          return !(o.isComposite(this._boundable1) || o.isComposite(this._boundable2));
        } }, { key: "compareTo", value: function(n) {
          var i = n;
          return this._distance < i._distance ? -1 : this._distance > i._distance ? 1 : 0;
        } }, { key: "expand", value: function(n, i, a, c, g) {
          for (var m = n.getChildBoundables().iterator(); m.hasNext(); ) {
            var y = m.next(), w = null;
            (w = a ? new o(i, y, this._itemDistance) : new o(y, i, this._itemDistance)).getDistance() < g && c.add(w);
          }
        } }, { key: "getBoundable", value: function(n) {
          return n === 0 ? this._boundable1 : this._boundable2;
        } }, { key: "getDistance", value: function() {
          return this._distance;
        } }, { key: "distance", value: function() {
          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
        } }, { key: "interfaces_", get: function() {
          return [j];
        } }], [{ key: "constructor_", value: function() {
          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
          var n = arguments[0], i = arguments[1], a = arguments[2];
          this._boundable1 = n, this._boundable2 = i, this._itemDistance = a, this._distance = this.distance();
        } }, { key: "area", value: function(n) {
          return n.getBounds().getArea();
        } }, { key: "isComposite", value: function(n) {
          return n instanceof Wt;
        } }]);
      })(), yc = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "visitItem", value: function(o) {
        } }]);
      })(), ki = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "queryInternal", value: function() {
          if (Ee(arguments[2], yc) && arguments[0] instanceof Object && arguments[1] instanceof Wt) for (var n = arguments[0], i = arguments[2], a = arguments[1].getChildBoundables(), c = 0; c < a.size(); c++) {
            var g = a.get(c);
            this.getIntersectsOp().intersects(g.getBounds(), n) && (g instanceof Wt ? this.queryInternal(n, g, i) : g instanceof tr ? i.visitItem(g.getItem()) : ae.shouldNeverReachHere());
          }
          else if (Ee(arguments[2], An) && arguments[0] instanceof Object && arguments[1] instanceof Wt) for (var m = arguments[0], y = arguments[2], w = arguments[1].getChildBoundables(), A = 0; A < w.size(); A++) {
            var z = w.get(A);
            this.getIntersectsOp().intersects(z.getBounds(), m) && (z instanceof Wt ? this.queryInternal(m, z, y) : z instanceof tr ? y.add(z.getItem()) : ae.shouldNeverReachHere());
          }
        } }, { key: "getNodeCapacity", value: function() {
          return this._nodeCapacity;
        } }, { key: "lastNode", value: function(n) {
          return n.get(n.size() - 1);
        } }, { key: "size", value: function() {
          if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
          if (arguments.length === 1) {
            for (var n = 0, i = arguments[0].getChildBoundables().iterator(); i.hasNext(); ) {
              var a = i.next();
              a instanceof Wt ? n += this.size(a) : a instanceof tr && (n += 1);
            }
            return n;
          }
        } }, { key: "removeItem", value: function(n, i) {
          for (var a = null, c = n.getChildBoundables().iterator(); c.hasNext(); ) {
            var g = c.next();
            g instanceof tr && g.getItem() === i && (a = g);
          }
          return a !== null && (n.getChildBoundables().remove(a), true);
        } }, { key: "itemsTree", value: function() {
          if (arguments.length === 0) {
            this.build();
            var n = this.itemsTree(this._root);
            return n === null ? new pe() : n;
          }
          if (arguments.length === 1) {
            for (var i = arguments[0], a = new pe(), c = i.getChildBoundables().iterator(); c.hasNext(); ) {
              var g = c.next();
              if (g instanceof Wt) {
                var m = this.itemsTree(g);
                m !== null && a.add(m);
              } else g instanceof tr ? a.add(g.getItem()) : ae.shouldNeverReachHere();
            }
            return a.size() <= 0 ? null : a;
          }
        } }, { key: "insert", value: function(n, i) {
          ae.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new tr(n, i));
        } }, { key: "boundablesAtLevel", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0], i = new pe();
            return this.boundablesAtLevel(n, this._root, i), i;
          }
          if (arguments.length === 3) {
            var a = arguments[0], c = arguments[1], g = arguments[2];
            if (ae.isTrue(a > -2), c.getLevel() === a) return g.add(c), null;
            for (var m = c.getChildBoundables().iterator(); m.hasNext(); ) {
              var y = m.next();
              y instanceof Wt ? this.boundablesAtLevel(a, y, g) : (ae.isTrue(y instanceof tr), a === -1 && g.add(y));
            }
            return null;
          }
        } }, { key: "query", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            this.build();
            var i = new pe();
            return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.queryInternal(n, this._root, i), i;
          }
          if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            if (this.build(), this.isEmpty()) return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), a) && this.queryInternal(a, this._root, c);
          }
        } }, { key: "build", value: function() {
          if (this._built) return null;
          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = true;
        } }, { key: "getRoot", value: function() {
          return this.build(), this._root;
        } }, { key: "remove", value: function() {
          if (arguments.length === 2) {
            var n = arguments[0], i = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.remove(n, this._root, i);
          }
          if (arguments.length === 3) {
            var a = arguments[0], c = arguments[1], g = arguments[2], m = this.removeItem(c, g);
            if (m) return true;
            for (var y = null, w = c.getChildBoundables().iterator(); w.hasNext(); ) {
              var A = w.next();
              if (this.getIntersectsOp().intersects(A.getBounds(), a) && A instanceof Wt && (m = this.remove(a, A, g))) {
                y = A;
                break;
              }
            }
            return y !== null && y.getChildBoundables().isEmpty() && c.getChildBoundables().remove(y), m;
          }
        } }, { key: "createHigherLevels", value: function(n, i) {
          ae.isTrue(!n.isEmpty());
          var a = this.createParentBoundables(n, i + 1);
          return a.size() === 1 ? a.get(0) : this.createHigherLevels(a, i + 1);
        } }, { key: "depth", value: function() {
          if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
          if (arguments.length === 1) {
            for (var n = 0, i = arguments[0].getChildBoundables().iterator(); i.hasNext(); ) {
              var a = i.next();
              if (a instanceof Wt) {
                var c = this.depth(a);
                c > n && (n = c);
              }
            }
            return n + 1;
          }
        } }, { key: "createParentBoundables", value: function(n, i) {
          ae.isTrue(!n.isEmpty());
          var a = new pe();
          a.add(this.createNode(i));
          var c = new pe(n);
          xi.sort(c, this.getComparator());
          for (var g = c.iterator(); g.hasNext(); ) {
            var m = g.next();
            this.lastNode(a).getChildBoundables().size() === this.getNodeCapacity() && a.add(this.createNode(i)), this.lastNode(a).addChildBoundable(m);
          }
          return a;
        } }, { key: "isEmpty", value: function() {
          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
        } }, { key: "interfaces_", get: function() {
          return [k];
        } }], [{ key: "constructor_", value: function() {
          if (this._root = null, this._built = false, this._itemBoundables = new pe(), this._nodeCapacity = null, arguments.length === 0) o.constructor_.call(this, o.DEFAULT_NODE_CAPACITY);
          else if (arguments.length === 1) {
            var n = arguments[0];
            ae.isTrue(n > 1, "Node capacity must be greater than 1"), this._nodeCapacity = n;
          }
        } }, { key: "compareDoubles", value: function(n, i) {
          return n > i ? 1 : n < i ? -1 : 0;
        } }]);
      })();
      ki.IntersectsOp = function() {
      }, ki.DEFAULT_NODE_CAPACITY = 10;
      var Wp = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "distance", value: function(o, n) {
        } }]);
      })(), Rn = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "createParentBoundablesFromVerticalSlices", value: function(i, a) {
          ae.isTrue(i.length > 0);
          for (var c = new pe(), g = 0; g < i.length; g++) c.addAll(this.createParentBoundablesFromVerticalSlice(i[g], a));
          return c;
        } }, { key: "nearestNeighbourK", value: function() {
          if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            return this.nearestNeighbourK(i, Z.POSITIVE_INFINITY, a);
          }
          if (arguments.length === 3) {
            var c = arguments[0], g = arguments[2], m = arguments[1], y = new ya();
            y.add(c);
            for (var w = new ya(); !y.isEmpty() && m >= 0; ) {
              var A = y.poll(), z = A.getDistance();
              if (z >= m) break;
              A.isLeaves() ? w.size() < g ? w.add(A) : (w.peek().getDistance() > z && (w.poll(), w.add(A)), m = w.peek().getDistance()) : A.expandToQueue(y, m);
            }
            return n.getItems(w);
          }
        } }, { key: "createNode", value: function(i) {
          return new _c2(i);
        } }, { key: "size", value: function() {
          return arguments.length === 0 ? I(n, "size", this, 1).call(this) : I(n, "size", this, 1).apply(this, arguments);
        } }, { key: "insert", value: function() {
          if (!(arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Ie)) return I(n, "insert", this, 1).apply(this, arguments);
          var i = arguments[0], a = arguments[1];
          if (i.isNull()) return null;
          I(n, "insert", this, 1).call(this, i, a);
        } }, { key: "getIntersectsOp", value: function() {
          return n.intersectsOp;
        } }, { key: "verticalSlices", value: function(i, a) {
          for (var c = Math.trunc(Math.ceil(i.size() / a)), g = new Array(a).fill(null), m = i.iterator(), y = 0; y < a; y++) {
            g[y] = new pe();
            for (var w = 0; m.hasNext() && w < c; ) {
              var A = m.next();
              g[y].add(A), w++;
            }
          }
          return g;
        } }, { key: "query", value: function() {
          if (arguments.length === 1) {
            var i = arguments[0];
            return I(n, "query", this, 1).call(this, i);
          }
          if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            I(n, "query", this, 1).call(this, a, c);
          }
        } }, { key: "getComparator", value: function() {
          return n.yComparator;
        } }, { key: "createParentBoundablesFromVerticalSlice", value: function(i, a) {
          return I(n, "createParentBoundables", this, 1).call(this, i, a);
        } }, { key: "remove", value: function() {
          if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Ie) {
            var i = arguments[0], a = arguments[1];
            return I(n, "remove", this, 1).call(this, i, a);
          }
          return I(n, "remove", this, 1).apply(this, arguments);
        } }, { key: "depth", value: function() {
          return arguments.length === 0 ? I(n, "depth", this, 1).call(this) : I(n, "depth", this, 1).apply(this, arguments);
        } }, { key: "createParentBoundables", value: function(i, a) {
          ae.isTrue(!i.isEmpty());
          var c = Math.trunc(Math.ceil(i.size() / this.getNodeCapacity())), g = new pe(i);
          xi.sort(g, n.xComparator);
          var m = this.verticalSlices(g, Math.trunc(Math.ceil(Math.sqrt(c))));
          return this.createParentBoundablesFromVerticalSlices(m, a);
        } }, { key: "nearestNeighbour", value: function() {
          if (arguments.length === 1) {
            if (Ee(arguments[0], Wp)) {
              var i = arguments[0];
              if (this.isEmpty()) return null;
              var a = new wi(this.getRoot(), this.getRoot(), i);
              return this.nearestNeighbour(a);
            }
            if (arguments[0] instanceof wi) {
              var c = arguments[0], g = Z.POSITIVE_INFINITY, m = null, y = new ya();
              for (y.add(c); !y.isEmpty() && g > 0; ) {
                var w = y.poll(), A = w.getDistance();
                if (A >= g) break;
                w.isLeaves() ? (g = A, m = w) : w.expandToQueue(y, g);
              }
              return m === null ? null : [m.getBoundable(0).getItem(), m.getBoundable(1).getItem()];
            }
          } else {
            if (arguments.length === 2) {
              var z = arguments[0], V = arguments[1];
              if (this.isEmpty() || z.isEmpty()) return null;
              var ee = new wi(this.getRoot(), z.getRoot(), V);
              return this.nearestNeighbour(ee);
            }
            if (arguments.length === 3) {
              var ue = arguments[2], fe = new tr(arguments[0], arguments[1]), me = new wi(this.getRoot(), fe, ue);
              return this.nearestNeighbour(me)[0];
            }
            if (arguments.length === 4) {
              var Ae = arguments[2], be = arguments[3], Ge = new tr(arguments[0], arguments[1]), ht = new wi(this.getRoot(), Ge, Ae);
              return this.nearestNeighbourK(ht, be);
            }
          }
        } }, { key: "isWithinDistance", value: function() {
          if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1], c = Z.POSITIVE_INFINITY, g = new ya();
            for (g.add(i); !g.isEmpty(); ) {
              var m = g.poll(), y = m.getDistance();
              if (y > a) return false;
              if (m.maximumDistance() <= a) return true;
              if (m.isLeaves()) {
                if ((c = y) <= a) return true;
              } else m.expandToQueue(g, c);
            }
            return false;
          }
          if (arguments.length === 3) {
            var w = arguments[0], A = arguments[1], z = arguments[2], V = new wi(this.getRoot(), w.getRoot(), A);
            return this.isWithinDistance(V, z);
          }
        } }, { key: "interfaces_", get: function() {
          return [Vp, k];
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length === 0) n.constructor_.call(this, n.DEFAULT_NODE_CAPACITY);
          else if (arguments.length === 1) {
            var i = arguments[0];
            ki.constructor_.call(this, i);
          }
        } }, { key: "centreX", value: function(i) {
          return n.avg(i.getMinX(), i.getMaxX());
        } }, { key: "avg", value: function(i, a) {
          return (i + a) / 2;
        } }, { key: "getItems", value: function(i) {
          for (var a = new Array(i.size()).fill(null), c = 0; !i.isEmpty(); ) {
            var g = i.poll();
            a[c] = g.getBoundable(0).getItem(), c++;
          }
          return a;
        } }, { key: "centreY", value: function(i) {
          return n.avg(i.getMinY(), i.getMaxY());
        } }]);
      })(ki), _c2 = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "computeBounds", value: function() {
          for (var i = null, a = this.getChildBoundables().iterator(); a.hasNext(); ) {
            var c = a.next();
            i === null ? i = new Ie(c.getBounds()) : i.expandToInclude(c.getBounds());
          }
          return i;
        } }], [{ key: "constructor_", value: function() {
          var i = arguments[0];
          Wt.constructor_.call(this, i);
        } }]);
      })(Wt);
      Rn.STRtreeNode = _c2, Rn.xComparator = new ((function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "interfaces_", get: function() {
          return [ne];
        } }, { key: "compare", value: function(o, n) {
          return ki.compareDoubles(Rn.centreX(o.getBounds()), Rn.centreX(n.getBounds()));
        } }]);
      })())(), Rn.yComparator = new ((function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "interfaces_", get: function() {
          return [ne];
        } }, { key: "compare", value: function(o, n) {
          return ki.compareDoubles(Rn.centreY(o.getBounds()), Rn.centreY(n.getBounds()));
        } }]);
      })())(), Rn.intersectsOp = new ((function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "interfaces_", get: function() {
          return [IntersectsOp];
        } }, { key: "intersects", value: function(o, n) {
          return o.intersects(n);
        } }]);
      })())(), Rn.DEFAULT_NODE_CAPACITY = 10;
      var jp = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "relativeSign", value: function(n, i) {
          return n < i ? -1 : n > i ? 1 : 0;
        } }, { key: "compare", value: function(n, i, a) {
          if (i.equals2D(a)) return 0;
          var c = o.relativeSign(i.x, a.x), g = o.relativeSign(i.y, a.y);
          switch (n) {
            case 0:
              return o.compareValue(c, g);
            case 1:
              return o.compareValue(g, c);
            case 2:
              return o.compareValue(g, -c);
            case 3:
              return o.compareValue(-c, g);
            case 4:
              return o.compareValue(-c, -g);
            case 5:
              return o.compareValue(-g, -c);
            case 6:
              return o.compareValue(-g, c);
            case 7:
              return o.compareValue(c, -g);
          }
          return ae.shouldNeverReachHere("invalid octant value"), 0;
        } }, { key: "compareValue", value: function(n, i) {
          return n < 0 ? -1 : n > 0 ? 1 : i < 0 ? -1 : i > 0 ? 1 : 0;
        } }]);
      })(), Zp = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(o) {
          o.print(this.coord), o.print(" seg # = " + this.segmentIndex);
        } }, { key: "compareTo", value: function(o) {
          var n = o;
          return this.segmentIndex < n.segmentIndex ? -1 : this.segmentIndex > n.segmentIndex ? 1 : this.coord.equals2D(n.coord) ? 0 : this._isInterior ? n._isInterior ? jp.compare(this._segmentOctant, this.coord, n.coord) : 1 : -1;
        } }, { key: "isEndPoint", value: function(o) {
          return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === o;
        } }, { key: "toString", value: function() {
          return this.segmentIndex + ":" + this.coord.toString();
        } }, { key: "isInterior", value: function() {
          return this._isInterior;
        } }, { key: "interfaces_", get: function() {
          return [j];
        } }], [{ key: "constructor_", value: function() {
          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
          var o = arguments[0], n = arguments[1], i = arguments[2], a = arguments[3];
          this._segString = o, this.coord = new H(n), this.segmentIndex = i, this._segmentOctant = a, this._isInterior = !n.equals2D(o.getCoordinate(i));
        } }]);
      })(), Kp = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "hasNext", value: function() {
        } }, { key: "next", value: function() {
        } }, { key: "remove", value: function() {
        } }]);
      })(), Qp = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "getSplitCoordinates", value: function() {
          var o = new B();
          this.addEndpoints();
          for (var n = this.iterator(), i = n.next(); n.hasNext(); ) {
            var a = n.next();
            this.addEdgeCoordinates(i, a, o), i = a;
          }
          return o.toCoordinateArray();
        } }, { key: "addCollapsedNodes", value: function() {
          var o = new pe();
          this.findCollapsesFromInsertedNodes(o), this.findCollapsesFromExistingVertices(o);
          for (var n = o.iterator(); n.hasNext(); ) {
            var i = n.next().intValue();
            this.add(this._edge.getCoordinate(i), i);
          }
        } }, { key: "createSplitEdgePts", value: function(o, n) {
          var i = n.segmentIndex - o.segmentIndex + 2;
          if (i === 2) return [new H(o.coord), new H(n.coord)];
          var a = this._edge.getCoordinate(n.segmentIndex), c = n.isInterior() || !n.coord.equals2D(a);
          c || i--;
          var g = new Array(i).fill(null), m = 0;
          g[m++] = new H(o.coord);
          for (var y = o.segmentIndex + 1; y <= n.segmentIndex; y++) g[m++] = this._edge.getCoordinate(y);
          return c && (g[m] = new H(n.coord)), g;
        } }, { key: "print", value: function(o) {
          o.println("Intersections:");
          for (var n = this.iterator(); n.hasNext(); )
            n.next().print(o);
        } }, { key: "findCollapsesFromExistingVertices", value: function(o) {
          for (var n = 0; n < this._edge.size() - 2; n++) {
            var i = this._edge.getCoordinate(n);
            this._edge.getCoordinate(n + 1);
            var a = this._edge.getCoordinate(n + 2);
            i.equals2D(a) && o.add(hn.valueOf(n + 1));
          }
        } }, { key: "addEdgeCoordinates", value: function(o, n, i) {
          var a = this.createSplitEdgePts(o, n);
          i.add(a, false);
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(o) {
          this.addEndpoints(), this.addCollapsedNodes();
          for (var n = this.iterator(), i = n.next(); n.hasNext(); ) {
            var a = n.next(), c = this.createSplitEdge(i, a);
            o.add(c), i = a;
          }
        } }, { key: "findCollapseIndex", value: function(o, n, i) {
          if (!o.coord.equals2D(n.coord)) return false;
          var a = n.segmentIndex - o.segmentIndex;
          return n.isInterior() || a--, a === 1 && (i[0] = o.segmentIndex + 1, true);
        } }, { key: "findCollapsesFromInsertedNodes", value: function(o) {
          for (var n = new Array(1).fill(null), i = this.iterator(), a = i.next(); i.hasNext(); ) {
            var c = i.next();
            this.findCollapseIndex(a, c, n) && o.add(hn.valueOf(n[0])), a = c;
          }
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "addEndpoints", value: function() {
          var o = this._edge.size() - 1;
          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(o), o);
        } }, { key: "createSplitEdge", value: function(o, n) {
          var i = this.createSplitEdgePts(o, n);
          return new Hr(i, this._edge.getData());
        } }, { key: "add", value: function(o, n) {
          var i = new Zp(this._edge, o, n, this._edge.getSegmentOctant(n)), a = this._nodeMap.get(i);
          return a !== null ? (ae.isTrue(a.coord.equals2D(o), "Found equal nodes with different coordinates"), a) : (this._nodeMap.put(i, i), i);
        } }, { key: "checkSplitEdgesCorrectness", value: function(o) {
          var n = this._edge.getCoordinates(), i = o.get(0).getCoordinate(0);
          if (!i.equals2D(n[0])) throw new ge("bad split edge start point at " + i);
          var a = o.get(o.size() - 1).getCoordinates(), c = a[a.length - 1];
          if (!c.equals2D(n[n.length - 1])) throw new ge("bad split edge end point at " + c);
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new ls(), this._edge = null;
          var o = arguments[0];
          this._edge = o;
        } }]);
      })(), em = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "octant", value: function() {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var n = arguments[0], i = arguments[1];
            if (n === 0 && i === 0) throw new $("Cannot compute the octant for point ( " + n + ", " + i + " )");
            var a = Math.abs(n), c = Math.abs(i);
            return n >= 0 ? i >= 0 ? a >= c ? 0 : 1 : a >= c ? 7 : 6 : i >= 0 ? a >= c ? 3 : 2 : a >= c ? 4 : 5;
          }
          if (arguments[0] instanceof H && arguments[1] instanceof H) {
            var g = arguments[0], m = arguments[1], y = m.x - g.x, w = m.y - g.y;
            if (y === 0 && w === 0) throw new $("Cannot compute the octant for two identical points " + g);
            return o.octant(y, w);
          }
        } }]);
      })(), tm = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "getCoordinates", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "getCoordinate", value: function(o) {
        } }, { key: "isClosed", value: function() {
        } }, { key: "setData", value: function(o) {
        } }, { key: "getData", value: function() {
        } }]);
      })(), nm = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "addIntersection", value: function(o, n) {
        } }, { key: "interfaces_", get: function() {
          return [tm];
        } }]);
      })(), Hr = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "getCoordinates", value: function() {
          return this._pts;
        } }, { key: "size", value: function() {
          return this._pts.length;
        } }, { key: "getCoordinate", value: function(n) {
          return this._pts[n];
        } }, { key: "isClosed", value: function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        } }, { key: "getSegmentOctant", value: function(n) {
          return n === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(n), this.getCoordinate(n + 1));
        } }, { key: "setData", value: function(n) {
          this._data = n;
        } }, { key: "safeOctant", value: function(n, i) {
          return n.equals2D(i) ? 0 : em.octant(n, i);
        } }, { key: "getData", value: function() {
          return this._data;
        } }, { key: "addIntersection", value: function() {
          if (arguments.length === 2) {
            var n = arguments[0], i = arguments[1];
            this.addIntersectionNode(n, i);
          } else if (arguments.length === 4) {
            var a = arguments[1], c = arguments[3], g = new H(arguments[0].getIntersection(c));
            this.addIntersection(g, a);
          }
        } }, { key: "toString", value: function() {
          return Do.toLineString(new ze(this._pts));
        } }, { key: "getNodeList", value: function() {
          return this._nodeList;
        } }, { key: "addIntersectionNode", value: function(n, i) {
          var a = i, c = a + 1;
          if (c < this._pts.length) {
            var g = this._pts[c];
            n.equals2D(g) && (a = c);
          }
          return this._nodeList.add(n, a);
        } }, { key: "addIntersections", value: function(n, i, a) {
          for (var c = 0; c < n.getIntersectionNum(); c++) this.addIntersection(n, i, a, c);
        } }, { key: "interfaces_", get: function() {
          return [nm];
        } }], [{ key: "constructor_", value: function() {
          this._nodeList = new Qp(this), this._pts = null, this._data = null;
          var n = arguments[0], i = arguments[1];
          this._pts = n, this._data = i;
        } }, { key: "getNodedSubstrings", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0], i = new pe();
            return o.getNodedSubstrings(n, i), i;
          }
          if (arguments.length === 2) for (var a = arguments[1], c = arguments[0].iterator(); c.hasNext(); )
            c.next().getNodeList().addSplitEdges(a);
        } }]);
      })(), Bt = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "minX", value: function() {
          return Math.min(this.p0.x, this.p1.x);
        } }, { key: "orientationIndex", value: function() {
          if (arguments[0] instanceof o) {
            var n = arguments[0], i = ye.index(this.p0, this.p1, n.p0), a = ye.index(this.p0, this.p1, n.p1);
            return i >= 0 && a >= 0 || i <= 0 && a <= 0 ? Math.max(i, a) : 0;
          }
          if (arguments[0] instanceof H) {
            var c = arguments[0];
            return ye.index(this.p0, this.p1, c);
          }
        } }, { key: "toGeometry", value: function(n) {
          return n.createLineString([this.p0, this.p1]);
        } }, { key: "isVertical", value: function() {
          return this.p0.x === this.p1.x;
        } }, { key: "equals", value: function(n) {
          if (!(n instanceof o)) return false;
          var i = n;
          return this.p0.equals(i.p0) && this.p1.equals(i.p1);
        } }, { key: "intersection", value: function(n) {
          var i = new Yr();
          return i.computeIntersection(this.p0, this.p1, n.p0, n.p1), i.hasIntersection() ? i.getIntersection(0) : null;
        } }, { key: "project", value: function() {
          if (arguments[0] instanceof H) {
            var n = arguments[0];
            if (n.equals(this.p0) || n.equals(this.p1)) return new H(n);
            var i = this.projectionFactor(n), a = new H();
            return a.x = this.p0.x + i * (this.p1.x - this.p0.x), a.y = this.p0.y + i * (this.p1.y - this.p0.y), a;
          }
          if (arguments[0] instanceof o) {
            var c = arguments[0], g = this.projectionFactor(c.p0), m = this.projectionFactor(c.p1);
            if (g >= 1 && m >= 1 || g <= 0 && m <= 0) return null;
            var y = this.project(c.p0);
            g < 0 && (y = this.p0), g > 1 && (y = this.p1);
            var w = this.project(c.p1);
            return m < 0 && (w = this.p0), m > 1 && (w = this.p1), new o(y, w);
          }
        } }, { key: "normalize", value: function() {
          this.p1.compareTo(this.p0) < 0 && this.reverse();
        } }, { key: "angle", value: function() {
          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        } }, { key: "getCoordinate", value: function(n) {
          return n === 0 ? this.p0 : this.p1;
        } }, { key: "distancePerpendicular", value: function(n) {
          return Et.pointToLinePerpendicular(n, this.p0, this.p1);
        } }, { key: "minY", value: function() {
          return Math.min(this.p0.y, this.p1.y);
        } }, { key: "midPoint", value: function() {
          return o.midPoint(this.p0, this.p1);
        } }, { key: "projectionFactor", value: function(n) {
          if (n.equals(this.p0)) return 0;
          if (n.equals(this.p1)) return 1;
          var i = this.p1.x - this.p0.x, a = this.p1.y - this.p0.y, c = i * i + a * a;
          return c <= 0 ? Z.NaN : ((n.x - this.p0.x) * i + (n.y - this.p0.y) * a) / c;
        } }, { key: "closestPoints", value: function(n) {
          var i = this.intersection(n);
          if (i !== null) return [i, i];
          var a = new Array(2).fill(null), c = Z.MAX_VALUE, g = null, m = this.closestPoint(n.p0);
          c = m.distance(n.p0), a[0] = m, a[1] = n.p0;
          var y = this.closestPoint(n.p1);
          (g = y.distance(n.p1)) < c && (c = g, a[0] = y, a[1] = n.p1);
          var w = n.closestPoint(this.p0);
          (g = w.distance(this.p0)) < c && (c = g, a[0] = this.p0, a[1] = w);
          var A = n.closestPoint(this.p1);
          return (g = A.distance(this.p1)) < c && (c = g, a[0] = this.p1, a[1] = A), a;
        } }, { key: "closestPoint", value: function(n) {
          var i = this.projectionFactor(n);
          return i > 0 && i < 1 ? this.project(n) : this.p0.distance(n) < this.p1.distance(n) ? this.p0 : this.p1;
        } }, { key: "maxX", value: function() {
          return Math.max(this.p0.x, this.p1.x);
        } }, { key: "getLength", value: function() {
          return this.p0.distance(this.p1);
        } }, { key: "compareTo", value: function(n) {
          var i = n, a = this.p0.compareTo(i.p0);
          return a !== 0 ? a : this.p1.compareTo(i.p1);
        } }, { key: "reverse", value: function() {
          var n = this.p0;
          this.p0 = this.p1, this.p1 = n;
        } }, { key: "equalsTopo", value: function(n) {
          return this.p0.equals(n.p0) && this.p1.equals(n.p1) || this.p0.equals(n.p1) && this.p1.equals(n.p0);
        } }, { key: "lineIntersection", value: function(n) {
          return Ur.intersection(this.p0, this.p1, n.p0, n.p1);
        } }, { key: "maxY", value: function() {
          return Math.max(this.p0.y, this.p1.y);
        } }, { key: "pointAlongOffset", value: function(n, i) {
          var a = this.p0.x + n * (this.p1.x - this.p0.x), c = this.p0.y + n * (this.p1.y - this.p0.y), g = this.p1.x - this.p0.x, m = this.p1.y - this.p0.y, y = Math.sqrt(g * g + m * m), w = 0, A = 0;
          if (i !== 0) {
            if (y <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
            w = i * g / y, A = i * m / y;
          }
          return new H(a - A, c + w);
        } }, { key: "setCoordinates", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            this.setCoordinates(n.p0, n.p1);
          } else if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            this.p0.x = i.x, this.p0.y = i.y, this.p1.x = a.x, this.p1.y = a.y;
          }
        } }, { key: "segmentFraction", value: function(n) {
          var i = this.projectionFactor(n);
          return i < 0 ? i = 0 : (i > 1 || Z.isNaN(i)) && (i = 1), i;
        } }, { key: "toString", value: function() {
          return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
        } }, { key: "isHorizontal", value: function() {
          return this.p0.y === this.p1.y;
        } }, { key: "reflect", value: function(n) {
          var i = this.p1.getY() - this.p0.getY(), a = this.p0.getX() - this.p1.getX(), c = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()), g = i * i + a * a, m = i * i - a * a, y = n.getX(), w = n.getY();
          return new H((-m * y - 2 * i * a * w - 2 * i * c) / g, (m * w - 2 * i * a * y - 2 * a * c) / g);
        } }, { key: "distance", value: function() {
          if (arguments[0] instanceof o) {
            var n = arguments[0];
            return Et.segmentToSegment(this.p0, this.p1, n.p0, n.p1);
          }
          if (arguments[0] instanceof H) {
            var i = arguments[0];
            return Et.pointToSegment(i, this.p0, this.p1);
          }
        } }, { key: "pointAlong", value: function(n) {
          var i = new H();
          return i.x = this.p0.x + n * (this.p1.x - this.p0.x), i.y = this.p0.y + n * (this.p1.y - this.p0.y), i;
        } }, { key: "hashCode", value: function() {
          var n = Z.doubleToLongBits(this.p0.x);
          n ^= 31 * Z.doubleToLongBits(this.p0.y);
          var i = Math.trunc(n) ^ Math.trunc(n >> 32), a = Z.doubleToLongBits(this.p1.x);
          return a ^= 31 * Z.doubleToLongBits(this.p1.y), i ^ (Math.trunc(a) ^ Math.trunc(a >> 32));
        } }, { key: "interfaces_", get: function() {
          return [j, k];
        } }], [{ key: "constructor_", value: function() {
          if (this.p0 = null, this.p1 = null, arguments.length === 0) o.constructor_.call(this, new H(), new H());
          else if (arguments.length === 1) {
            var n = arguments[0];
            o.constructor_.call(this, n.p0, n.p1);
          } else if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            this.p0 = i, this.p1 = a;
          } else if (arguments.length === 4) {
            var c = arguments[0], g = arguments[1], m = arguments[2], y = arguments[3];
            o.constructor_.call(this, new H(c, g), new H(m, y));
          }
        } }, { key: "midPoint", value: function(n, i) {
          return new H((n.x + i.x) / 2, (n.y + i.y) / 2);
        } }]);
      })(), rm = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "overlap", value: function() {
          if (arguments.length !== 2) {
            if (arguments.length === 4) {
              var o = arguments[1], n = arguments[2], i = arguments[3];
              arguments[0].getLineSegment(o, this._overlapSeg1), n.getLineSegment(i, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
            }
          }
        } }], [{ key: "constructor_", value: function() {
          this._overlapSeg1 = new Bt(), this._overlapSeg2 = new Bt();
        } }]);
      })(), Ec = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "getLineSegment", value: function(o, n) {
          n.p0 = this._pts[o], n.p1 = this._pts[o + 1];
        } }, { key: "computeSelect", value: function(o, n, i, a) {
          var c = this._pts[n], g = this._pts[i];
          if (i - n == 1) return a.select(this, n), null;
          if (!o.intersects(c, g)) return null;
          var m = Math.trunc((n + i) / 2);
          n < m && this.computeSelect(o, n, m, a), m < i && this.computeSelect(o, m, i, a);
        } }, { key: "getCoordinates", value: function() {
          for (var o = new Array(this._end - this._start + 1).fill(null), n = 0, i = this._start; i <= this._end; i++) o[n++] = this._pts[i];
          return o;
        } }, { key: "computeOverlaps", value: function() {
          if (arguments.length === 2) {
            var o = arguments[0], n = arguments[1];
            this.computeOverlaps(this._start, this._end, o, o._start, o._end, n);
          } else if (arguments.length === 6) {
            var i = arguments[0], a = arguments[1], c = arguments[2], g = arguments[3], m = arguments[4], y = arguments[5];
            if (a - i == 1 && m - g == 1) return y.overlap(this, i, c, g), null;
            if (!this.overlaps(i, a, c, g, m)) return null;
            var w = Math.trunc((i + a) / 2), A = Math.trunc((g + m) / 2);
            i < w && (g < A && this.computeOverlaps(i, w, c, g, A, y), A < m && this.computeOverlaps(i, w, c, A, m, y)), w < a && (g < A && this.computeOverlaps(w, a, c, g, A, y), A < m && this.computeOverlaps(w, a, c, A, m, y));
          }
        } }, { key: "setId", value: function(o) {
          this._id = o;
        } }, { key: "select", value: function(o, n) {
          this.computeSelect(o, this._start, this._end, n);
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            var o = this._pts[this._start], n = this._pts[this._end];
            this._env = new Ie(o, n);
          }
          return this._env;
        } }, { key: "overlaps", value: function(o, n, i, a, c) {
          return Ie.intersects(this._pts[o], this._pts[n], i._pts[a], i._pts[c]);
        } }, { key: "getEndIndex", value: function() {
          return this._end;
        } }, { key: "getStartIndex", value: function() {
          return this._start;
        } }, { key: "getContext", value: function() {
          return this._context;
        } }, { key: "getId", value: function() {
          return this._id;
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
          var o = arguments[0], n = arguments[1], i = arguments[2], a = arguments[3];
          this._pts = o, this._start = n, this._end = i, this._context = a;
        } }]);
      })(), im = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "findChainEnd", value: function(n, i) {
          for (var a = i; a < n.length - 1 && n[a].equals2D(n[a + 1]); ) a++;
          if (a >= n.length - 1) return n.length - 1;
          for (var c = xt.quadrant(n[a], n[a + 1]), g = i + 1; g < n.length && !(!n[g - 1].equals2D(n[g]) && xt.quadrant(n[g - 1], n[g]) !== c); )
            g++;
          return g - 1;
        } }, { key: "getChains", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            return o.getChains(n, null);
          }
          if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1], c = new pe(), g = 0;
            do {
              var m = o.findChainEnd(i, g), y = new Ec(i, g, m, a);
              c.add(y), g = m;
            } while (g < i.length - 1);
            return c;
          }
        } }]);
      })(), Uo = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "computeNodes", value: function(o) {
        } }, { key: "getNodedSubstrings", value: function() {
        } }]);
      })(), xc = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "setSegmentIntersector", value: function(o) {
          this._segInt = o;
        } }, { key: "interfaces_", get: function() {
          return [Uo];
        } }], [{ key: "constructor_", value: function() {
          if (this._segInt = null, arguments.length !== 0) {
            if (arguments.length === 1) {
              var o = arguments[0];
              this.setSegmentIntersector(o);
            }
          }
        } }]);
      })(), zo = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "getMonotoneChains", value: function() {
          return this._monoChains;
        } }, { key: "getNodedSubstrings", value: function() {
          return Hr.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "getIndex", value: function() {
          return this._index;
        } }, { key: "add", value: function(i) {
          for (var a = im.getChains(i.getCoordinates(), i).iterator(); a.hasNext(); ) {
            var c = a.next();
            c.setId(this._idCounter++), this._index.insert(c.getEnvelope(), c), this._monoChains.add(c);
          }
        } }, { key: "computeNodes", value: function(i) {
          this._nodedSegStrings = i;
          for (var a = i.iterator(); a.hasNext(); ) this.add(a.next());
          this.intersectChains();
        } }, { key: "intersectChains", value: function() {
          for (var i = new wc(this._segInt), a = this._monoChains.iterator(); a.hasNext(); ) for (var c = a.next(), g = this._index.query(c.getEnvelope()).iterator(); g.hasNext(); ) {
            var m = g.next();
            if (m.getId() > c.getId() && (c.computeOverlaps(m, i), this._nOverlaps++), this._segInt.isDone()) return null;
          }
        } }], [{ key: "constructor_", value: function() {
          if (this._monoChains = new pe(), this._index = new Rn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, arguments.length !== 0) {
            if (arguments.length === 1) {
              var i = arguments[0];
              xc.constructor_.call(this, i);
            }
          }
        } }]);
      })(xc), wc = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "overlap", value: function() {
          if (arguments.length !== 4) return I(n, "overlap", this, 1).apply(this, arguments);
          var i = arguments[1], a = arguments[2], c = arguments[3], g = arguments[0].getContext(), m = a.getContext();
          this._si.processIntersections(g, i, m, c);
        } }], [{ key: "constructor_", value: function() {
          this._si = null;
          var i = arguments[0];
          this._si = i;
        } }]);
      })(rm);
      zo.SegmentOverlapAction = wc;
      var fn = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "isDeletable", value: function(n, i, a, c) {
          var g = this._inputLine[n], m = this._inputLine[i], y = this._inputLine[a];
          return !!this.isConcave(g, m, y) && !!this.isShallow(g, m, y, c) && this.isShallowSampled(g, m, n, a, c);
        } }, { key: "deleteShallowConcavities", value: function() {
          for (var n = 1, i = this.findNextNonDeletedIndex(n), a = this.findNextNonDeletedIndex(i), c = false; a < this._inputLine.length; ) {
            var g = false;
            this.isDeletable(n, i, a, this._distanceTol) && (this._isDeleted[i] = o.DELETE, g = true, c = true), n = g ? a : i, i = this.findNextNonDeletedIndex(n), a = this.findNextNonDeletedIndex(i);
          }
          return c;
        } }, { key: "isShallowConcavity", value: function(n, i, a, c) {
          return ye.index(n, i, a) === this._angleOrientation && Et.pointToSegment(i, n, a) < c;
        } }, { key: "isShallowSampled", value: function(n, i, a, c, g) {
          var m = Math.trunc((c - a) / o.NUM_PTS_TO_CHECK);
          m <= 0 && (m = 1);
          for (var y = a; y < c; y += m) if (!this.isShallow(n, i, this._inputLine[y], g)) return false;
          return true;
        } }, { key: "isConcave", value: function(n, i, a) {
          var c = ye.index(n, i, a) === this._angleOrientation;
          return c;
        } }, { key: "simplify", value: function(n) {
          this._distanceTol = Math.abs(n), n < 0 && (this._angleOrientation = ye.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
          var i = false;
          do
            i = this.deleteShallowConcavities();
          while (i);
          return this.collapseLine();
        } }, { key: "findNextNonDeletedIndex", value: function(n) {
          for (var i = n + 1; i < this._inputLine.length && this._isDeleted[i] === o.DELETE; ) i++;
          return i;
        } }, { key: "isShallow", value: function(n, i, a, c) {
          return Et.pointToSegment(i, n, a) < c;
        } }, { key: "collapseLine", value: function() {
          for (var n = new B(), i = 0; i < this._inputLine.length; i++) this._isDeleted[i] !== o.DELETE && n.add(this._inputLine[i]);
          return n.toCoordinateArray();
        } }], [{ key: "constructor_", value: function() {
          this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = ye.COUNTERCLOCKWISE;
          var n = arguments[0];
          this._inputLine = n;
        } }, { key: "simplify", value: function(n, i) {
          return new o(n).simplify(i);
        } }]);
      })();
      fn.INIT = 0, fn.DELETE = 1, fn.KEEP = 1, fn.NUM_PTS_TO_CHECK = 10;
      var kc = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "getCoordinates", value: function() {
          return this._ptList.toArray(o.COORDINATE_ARRAY_TYPE);
        } }, { key: "setPrecisionModel", value: function(n) {
          this._precisionModel = n;
        } }, { key: "addPt", value: function(n) {
          var i = new H(n);
          if (this._precisionModel.makePrecise(i), this.isRedundant(i)) return null;
          this._ptList.add(i);
        } }, { key: "reverse", value: function() {
        } }, { key: "addPts", value: function(n, i) {
          if (i) for (var a = 0; a < n.length; a++) this.addPt(n[a]);
          else for (var c = n.length - 1; c >= 0; c--) this.addPt(n[c]);
        } }, { key: "isRedundant", value: function(n) {
          if (this._ptList.size() < 1) return false;
          var i = this._ptList.get(this._ptList.size() - 1);
          return n.distance(i) < this._minimimVertexDistance;
        } }, { key: "toString", value: function() {
          return new _i4().createLineString(this.getCoordinates()).toString();
        } }, { key: "closeRing", value: function() {
          if (this._ptList.size() < 1) return null;
          var n = new H(this._ptList.get(0)), i = this._ptList.get(this._ptList.size() - 1);
          if (n.equals(i)) return null;
          this._ptList.add(n);
        } }, { key: "setMinimumVertexDistance", value: function(n) {
          this._minimimVertexDistance = n;
        } }], [{ key: "constructor_", value: function() {
          this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new pe();
        } }]);
      })();
      kc.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);
      var Ut = (function() {
        function o() {
          u(this, o);
        }
        return h(o, null, [{ key: "toDegrees", value: function(n) {
          return 180 * n / Math.PI;
        } }, { key: "normalize", value: function(n) {
          for (; n > Math.PI; ) n -= o.PI_TIMES_2;
          for (; n <= -Math.PI; ) n += o.PI_TIMES_2;
          return n;
        } }, { key: "angle", value: function() {
          if (arguments.length === 1) {
            var n = arguments[0];
            return Math.atan2(n.y, n.x);
          }
          if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1], c = a.x - i.x, g = a.y - i.y;
            return Math.atan2(g, c);
          }
        } }, { key: "isAcute", value: function(n, i, a) {
          var c = n.x - i.x, g = n.y - i.y;
          return c * (a.x - i.x) + g * (a.y - i.y) > 0;
        } }, { key: "isObtuse", value: function(n, i, a) {
          var c = n.x - i.x, g = n.y - i.y;
          return c * (a.x - i.x) + g * (a.y - i.y) < 0;
        } }, { key: "interiorAngle", value: function(n, i, a) {
          var c = o.angle(i, n), g = o.angle(i, a);
          return Math.abs(g - c);
        } }, { key: "normalizePositive", value: function(n) {
          if (n < 0) {
            for (; n < 0; ) n += o.PI_TIMES_2;
            n >= o.PI_TIMES_2 && (n = 0);
          } else {
            for (; n >= o.PI_TIMES_2; ) n -= o.PI_TIMES_2;
            n < 0 && (n = 0);
          }
          return n;
        } }, { key: "angleBetween", value: function(n, i, a) {
          var c = o.angle(i, n), g = o.angle(i, a);
          return o.diff(c, g);
        } }, { key: "diff", value: function(n, i) {
          var a = null;
          return (a = n < i ? i - n : n - i) > Math.PI && (a = 2 * Math.PI - a), a;
        } }, { key: "toRadians", value: function(n) {
          return n * Math.PI / 180;
        } }, { key: "getTurn", value: function(n, i) {
          var a = Math.sin(i - n);
          return a > 0 ? o.COUNTERCLOCKWISE : a < 0 ? o.CLOCKWISE : o.NONE;
        } }, { key: "angleBetweenOriented", value: function(n, i, a) {
          var c = o.angle(i, n), g = o.angle(i, a) - c;
          return g <= -Math.PI ? g + o.PI_TIMES_2 : g > Math.PI ? g - o.PI_TIMES_2 : g;
        } }]);
      })();
      Ut.PI_TIMES_2 = 2 * Math.PI, Ut.PI_OVER_2 = Math.PI / 2, Ut.PI_OVER_4 = Math.PI / 4, Ut.COUNTERCLOCKWISE = ye.COUNTERCLOCKWISE, Ut.CLOCKWISE = ye.CLOCKWISE, Ut.NONE = ye.COLLINEAR;
      var cs = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "addNextSegment", value: function(n, i) {
          if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = n, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
          var a = ye.index(this._s0, this._s1, this._s2), c = a === ye.CLOCKWISE && this._side === re.LEFT || a === ye.COUNTERCLOCKWISE && this._side === re.RIGHT;
          a === 0 ? this.addCollinear(i) : c ? this.addOutsideTurn(a, i) : this.addInsideTurn(a, i);
        } }, { key: "addLineEndCap", value: function(n, i) {
          var a = new Bt(n, i), c = new Bt();
          this.computeOffsetSegment(a, re.LEFT, this._distance, c);
          var g = new Bt();
          this.computeOffsetSegment(a, re.RIGHT, this._distance, g);
          var m = i.x - n.x, y = i.y - n.y, w = Math.atan2(y, m);
          switch (this._bufParams.getEndCapStyle()) {
            case J.CAP_ROUND:
              this._segList.addPt(c.p1), this.addDirectedFillet(i, w + Math.PI / 2, w - Math.PI / 2, ye.CLOCKWISE, this._distance), this._segList.addPt(g.p1);
              break;
            case J.CAP_FLAT:
              this._segList.addPt(c.p1), this._segList.addPt(g.p1);
              break;
            case J.CAP_SQUARE:
              var A = new H();
              A.x = Math.abs(this._distance) * Math.cos(w), A.y = Math.abs(this._distance) * Math.sin(w);
              var z = new H(c.p1.x + A.x, c.p1.y + A.y), V = new H(g.p1.x + A.x, g.p1.y + A.y);
              this._segList.addPt(z), this._segList.addPt(V);
          }
        } }, { key: "getCoordinates", value: function() {
          return this._segList.getCoordinates();
        } }, { key: "addMitreJoin", value: function(n, i, a, c) {
          var g = Ur.intersection(i.p0, i.p1, a.p0, a.p1);
          if (g !== null && (c <= 0 ? 1 : g.distance(n) / Math.abs(c)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(g), null;
          this.addLimitedMitreJoin(i, a, c, this._bufParams.getMitreLimit());
        } }, { key: "addOutsideTurn", value: function(n, i) {
          if (this._offset0.p1.distance(this._offset1.p0) < this._distance * o.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
          this._bufParams.getJoinStyle() === J.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === J.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (i && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, n, this._distance), this._segList.addPt(this._offset1.p0));
        } }, { key: "createSquare", value: function(n) {
          this._segList.addPt(new H(n.x + this._distance, n.y + this._distance)), this._segList.addPt(new H(n.x + this._distance, n.y - this._distance)), this._segList.addPt(new H(n.x - this._distance, n.y - this._distance)), this._segList.addPt(new H(n.x - this._distance, n.y + this._distance)), this._segList.closeRing();
        } }, { key: "addSegments", value: function(n, i) {
          this._segList.addPts(n, i);
        } }, { key: "addFirstSegment", value: function() {
          this._segList.addPt(this._offset1.p0);
        } }, { key: "addCornerFillet", value: function(n, i, a, c, g) {
          var m = i.x - n.x, y = i.y - n.y, w = Math.atan2(y, m), A = a.x - n.x, z = a.y - n.y, V = Math.atan2(z, A);
          c === ye.CLOCKWISE ? w <= V && (w += 2 * Math.PI) : w >= V && (w -= 2 * Math.PI), this._segList.addPt(i), this.addDirectedFillet(n, w, V, c, g), this._segList.addPt(a);
        } }, { key: "addLastSegment", value: function() {
          this._segList.addPt(this._offset1.p1);
        } }, { key: "initSideSegments", value: function(n, i, a) {
          this._s1 = n, this._s2 = i, this._side = a, this._seg1.setCoordinates(n, i), this.computeOffsetSegment(this._seg1, a, this._distance, this._offset1);
        } }, { key: "addLimitedMitreJoin", value: function(n, i, a, c) {
          var g = this._seg0.p1, m = Ut.angle(g, this._seg0.p0), y = Ut.angleBetweenOriented(this._seg0.p0, g, this._seg1.p1) / 2, w = Ut.normalize(m + y), A = Ut.normalize(w + Math.PI), z = c * a, V = a - z * Math.abs(Math.sin(y)), ee = g.x + z * Math.cos(A), ue = g.y + z * Math.sin(A), fe = new H(ee, ue), me = new Bt(g, fe), Ae = me.pointAlongOffset(1, V), be = me.pointAlongOffset(1, -V);
          this._side === re.LEFT ? (this._segList.addPt(Ae), this._segList.addPt(be)) : (this._segList.addPt(be), this._segList.addPt(Ae));
        } }, { key: "addDirectedFillet", value: function(n, i, a, c, g) {
          var m = c === ye.CLOCKWISE ? -1 : 1, y = Math.abs(i - a), w = Math.trunc(y / this._filletAngleQuantum + 0.5);
          if (w < 1) return null;
          for (var A = y / w, z = new H(), V = 0; V < w; V++) {
            var ee = i + m * V * A;
            z.x = n.x + g * Math.cos(ee), z.y = n.y + g * Math.sin(ee), this._segList.addPt(z);
          }
        } }, { key: "computeOffsetSegment", value: function(n, i, a, c) {
          var g = i === re.LEFT ? 1 : -1, m = n.p1.x - n.p0.x, y = n.p1.y - n.p0.y, w = Math.sqrt(m * m + y * y), A = g * a * m / w, z = g * a * y / w;
          c.p0.x = n.p0.x - z, c.p0.y = n.p0.y + A, c.p1.x = n.p1.x - z, c.p1.y = n.p1.y + A;
        } }, { key: "addInsideTurn", value: function(n, i) {
          if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
          else if (this._hasNarrowConcaveAngle = true, this._offset0.p1.distance(this._offset1.p0) < this._distance * o.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
          else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
              var a = new H((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(a);
              var c = new H((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(c);
            } else this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0);
          }
        } }, { key: "createCircle", value: function(n) {
          var i = new H(n.x + this._distance, n.y);
          this._segList.addPt(i), this.addDirectedFillet(n, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
        } }, { key: "addBevelJoin", value: function(n, i) {
          this._segList.addPt(n.p1), this._segList.addPt(i.p0);
        } }, { key: "init", value: function(n) {
          this._distance = n, this._maxCurveSegmentError = n * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new kc(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(n * o.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
        } }, { key: "addCollinear", value: function(n) {
          this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === J.JOIN_BEVEL || this._bufParams.getJoinStyle() === J.JOIN_MITRE ? (n && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, ye.CLOCKWISE, this._distance));
        } }, { key: "closeRing", value: function() {
          this._segList.closeRing();
        } }, { key: "hasNarrowConcaveAngle", value: function() {
          return this._hasNarrowConcaveAngle;
        } }], [{ key: "constructor_", value: function() {
          this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new Bt(), this._seg1 = new Bt(), this._offset0 = new Bt(), this._offset1 = new Bt(), this._side = 0, this._hasNarrowConcaveAngle = false;
          var n = arguments[0], i = arguments[1], a = arguments[2];
          this._precisionModel = n, this._bufParams = i, this._li = new Yr(), this._filletAngleQuantum = Math.PI / 2 / i.getQuadrantSegments(), i.getQuadrantSegments() >= 8 && i.getJoinStyle() === J.JOIN_ROUND && (this._closingSegLengthFactor = o.MAX_CLOSING_SEG_LEN_FACTOR), this.init(a);
        } }]);
      })();
      cs.OFFSET_SEGMENT_SEPARATION_FACTOR = 1e-3, cs.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1e-3, cs.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, cs.MAX_CLOSING_SEG_LEN_FACTOR = 80;
      var sm = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "getOffsetCurve", value: function(n, i) {
          if (this._distance = i, i === 0) return null;
          var a = i < 0, c = Math.abs(i), g = this.getSegGen(c);
          n.length <= 1 ? this.computePointCurve(n[0], g) : this.computeOffsetCurve(n, a, g);
          var m = g.getCoordinates();
          return a && Q.reverse(m), m;
        } }, { key: "computeSingleSidedBufferCurve", value: function(n, i, a) {
          var c = this.simplifyTolerance(this._distance);
          if (i) {
            a.addSegments(n, true);
            var g = fn.simplify(n, -c), m = g.length - 1;
            a.initSideSegments(g[m], g[m - 1], re.LEFT), a.addFirstSegment();
            for (var y = m - 2; y >= 0; y--) a.addNextSegment(g[y], true);
          } else {
            a.addSegments(n, false);
            var w = fn.simplify(n, c), A = w.length - 1;
            a.initSideSegments(w[0], w[1], re.LEFT), a.addFirstSegment();
            for (var z = 2; z <= A; z++) a.addNextSegment(w[z], true);
          }
          a.addLastSegment(), a.closeRing();
        } }, { key: "computeRingBufferCurve", value: function(n, i, a) {
          var c = this.simplifyTolerance(this._distance);
          i === re.RIGHT && (c = -c);
          var g = fn.simplify(n, c), m = g.length - 1;
          a.initSideSegments(g[m - 1], g[0], i);
          for (var y = 1; y <= m; y++) {
            var w = y !== 1;
            a.addNextSegment(g[y], w);
          }
          a.closeRing();
        } }, { key: "computeLineBufferCurve", value: function(n, i) {
          var a = this.simplifyTolerance(this._distance), c = fn.simplify(n, a), g = c.length - 1;
          i.initSideSegments(c[0], c[1], re.LEFT);
          for (var m = 2; m <= g; m++) i.addNextSegment(c[m], true);
          i.addLastSegment(), i.addLineEndCap(c[g - 1], c[g]);
          var y = fn.simplify(n, -a), w = y.length - 1;
          i.initSideSegments(y[w], y[w - 1], re.LEFT);
          for (var A = w - 2; A >= 0; A--) i.addNextSegment(y[A], true);
          i.addLastSegment(), i.addLineEndCap(y[1], y[0]), i.closeRing();
        } }, { key: "computePointCurve", value: function(n, i) {
          switch (this._bufParams.getEndCapStyle()) {
            case J.CAP_ROUND:
              i.createCircle(n);
              break;
            case J.CAP_SQUARE:
              i.createSquare(n);
          }
        } }, { key: "getLineCurve", value: function(n, i) {
          if (this._distance = i, this.isLineOffsetEmpty(i)) return null;
          var a = Math.abs(i), c = this.getSegGen(a);
          if (n.length <= 1) this.computePointCurve(n[0], c);
          else if (this._bufParams.isSingleSided()) {
            var g = i < 0;
            this.computeSingleSidedBufferCurve(n, g, c);
          } else this.computeLineBufferCurve(n, c);
          return c.getCoordinates();
        } }, { key: "getBufferParameters", value: function() {
          return this._bufParams;
        } }, { key: "simplifyTolerance", value: function(n) {
          return n * this._bufParams.getSimplifyFactor();
        } }, { key: "getRingCurve", value: function(n, i, a) {
          if (this._distance = a, n.length <= 2) return this.getLineCurve(n, a);
          if (a === 0) return o.copyCoordinates(n);
          var c = this.getSegGen(a);
          return this.computeRingBufferCurve(n, i, c), c.getCoordinates();
        } }, { key: "computeOffsetCurve", value: function(n, i, a) {
          var c = this.simplifyTolerance(this._distance);
          if (i) {
            var g = fn.simplify(n, -c), m = g.length - 1;
            a.initSideSegments(g[m], g[m - 1], re.LEFT), a.addFirstSegment();
            for (var y = m - 2; y >= 0; y--) a.addNextSegment(g[y], true);
          } else {
            var w = fn.simplify(n, c), A = w.length - 1;
            a.initSideSegments(w[0], w[1], re.LEFT), a.addFirstSegment();
            for (var z = 2; z <= A; z++) a.addNextSegment(w[z], true);
          }
          a.addLastSegment();
        } }, { key: "isLineOffsetEmpty", value: function(n) {
          return n === 0 || n < 0 && !this._bufParams.isSingleSided();
        } }, { key: "getSegGen", value: function(n) {
          return new cs(this._precisionModel, this._bufParams, n);
        } }], [{ key: "constructor_", value: function() {
          this._distance = 0, this._precisionModel = null, this._bufParams = null;
          var n = arguments[0], i = arguments[1];
          this._precisionModel = n, this._bufParams = i;
        } }, { key: "copyCoordinates", value: function(n) {
          for (var i = new Array(n.length).fill(null), a = 0; a < i.length; a++) i[a] = new H(n[a]);
          return i;
        } }]);
      })(), Sc = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "findStabbedSegments", value: function() {
          if (arguments.length === 1) {
            for (var o = arguments[0], n = new pe(), i = this._subgraphs.iterator(); i.hasNext(); ) {
              var a = i.next(), c = a.getEnvelope();
              o.y < c.getMinY() || o.y > c.getMaxY() || this.findStabbedSegments(o, a.getDirectedEdges(), n);
            }
            return n;
          }
          if (arguments.length === 3) {
            if (Ee(arguments[2], An) && arguments[0] instanceof H && arguments[1] instanceof Bo) {
              for (var g = arguments[0], m = arguments[1], y = arguments[2], w = m.getEdge().getCoordinates(), A = 0; A < w.length - 1; A++)
                if (this._seg.p0 = w[A], this._seg.p1 = w[A + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < g.x || this._seg.isHorizontal() || g.y < this._seg.p0.y || g.y > this._seg.p1.y || ye.index(this._seg.p0, this._seg.p1, g) === ye.RIGHT)) {
                  var z = m.getDepth(re.LEFT);
                  this._seg.p0.equals(w[A]) || (z = m.getDepth(re.RIGHT));
                  var V = new Mc(this._seg, z);
                  y.add(V);
                }
            } else if (Ee(arguments[2], An) && arguments[0] instanceof H && Ee(arguments[1], An)) for (var ee = arguments[0], ue = arguments[2], fe = arguments[1].iterator(); fe.hasNext(); ) {
              var me = fe.next();
              me.isForward() && this.findStabbedSegments(ee, me, ue);
            }
          }
        } }, { key: "getDepth", value: function(o) {
          var n = this.findStabbedSegments(o);
          return n.size() === 0 ? 0 : xi.min(n)._leftDepth;
        } }], [{ key: "constructor_", value: function() {
          this._subgraphs = null, this._seg = new Bt();
          var o = arguments[0];
          this._subgraphs = o;
        } }]);
      })(), Mc = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "compareTo", value: function(o) {
          var n = o;
          if (this._upwardSeg.minX() >= n._upwardSeg.maxX()) return 1;
          if (this._upwardSeg.maxX() <= n._upwardSeg.minX()) return -1;
          var i = this._upwardSeg.orientationIndex(n._upwardSeg);
          return i !== 0 || (i = -1 * n._upwardSeg.orientationIndex(this._upwardSeg)) !== 0 ? i : this._upwardSeg.compareTo(n._upwardSeg);
        } }, { key: "compareX", value: function(o, n) {
          var i = o.p0.compareTo(n.p0);
          return i !== 0 ? i : o.p1.compareTo(n.p1);
        } }, { key: "toString", value: function() {
          return this._upwardSeg.toString();
        } }, { key: "interfaces_", get: function() {
          return [j];
        } }], [{ key: "constructor_", value: function() {
          this._upwardSeg = null, this._leftDepth = null;
          var o = arguments[0], n = arguments[1];
          this._upwardSeg = new Bt(o), this._leftDepth = n;
        } }]);
      })();
      Sc.DepthSegment = Mc;
      var Ic = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, null, [{ key: "constructor_", value: function() {
          X.constructor_.call(this, "Projective point not representable on the Cartesian plane.");
        } }]);
      })(X), qo = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "getY", value: function() {
          var n = this.y / this.w;
          if (Z.isNaN(n) || Z.isInfinite(n)) throw new Ic();
          return n;
        } }, { key: "getX", value: function() {
          var n = this.x / this.w;
          if (Z.isNaN(n) || Z.isInfinite(n)) throw new Ic();
          return n;
        } }, { key: "getCoordinate", value: function() {
          var n = new H();
          return n.x = this.getX(), n.y = this.getY(), n;
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.w = null, arguments.length === 0) this.x = 0, this.y = 0, this.w = 1;
          else if (arguments.length === 1) {
            var n = arguments[0];
            this.x = n.x, this.y = n.y, this.w = 1;
          } else if (arguments.length === 2) {
            if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
              var i = arguments[0], a = arguments[1];
              this.x = i, this.y = a, this.w = 1;
            } else if (arguments[0] instanceof o && arguments[1] instanceof o) {
              var c = arguments[0], g = arguments[1];
              this.x = c.y * g.w - g.y * c.w, this.y = g.x * c.w - c.x * g.w, this.w = c.x * g.y - g.x * c.y;
            } else if (arguments[0] instanceof H && arguments[1] instanceof H) {
              var m = arguments[0], y = arguments[1];
              this.x = m.y - y.y, this.y = y.x - m.x, this.w = m.x * y.y - y.x * m.y;
            }
          } else if (arguments.length === 3) {
            var w = arguments[0], A = arguments[1], z = arguments[2];
            this.x = w, this.y = A, this.w = z;
          } else if (arguments.length === 4) {
            var V = arguments[0], ee = arguments[1], ue = arguments[2], fe = arguments[3], me = V.y - ee.y, Ae = ee.x - V.x, be = V.x * ee.y - ee.x * V.y, Ge = ue.y - fe.y, ht = fe.x - ue.x, gt = ue.x * fe.y - fe.x * ue.y;
            this.x = Ae * gt - ht * be, this.y = Ge * be - me * gt, this.w = me * ht - Ge * Ae;
          }
        } }]);
      })(), am = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "area", value: function() {
          return o.area(this.p0, this.p1, this.p2);
        } }, { key: "signedArea", value: function() {
          return o.signedArea(this.p0, this.p1, this.p2);
        } }, { key: "interpolateZ", value: function(n) {
          if (n === null) throw new $("Supplied point is null.");
          return o.interpolateZ(n, this.p0, this.p1, this.p2);
        } }, { key: "longestSideLength", value: function() {
          return o.longestSideLength(this.p0, this.p1, this.p2);
        } }, { key: "isAcute", value: function() {
          return o.isAcute(this.p0, this.p1, this.p2);
        } }, { key: "circumcentre", value: function() {
          return o.circumcentre(this.p0, this.p1, this.p2);
        } }, { key: "area3D", value: function() {
          return o.area3D(this.p0, this.p1, this.p2);
        } }, { key: "centroid", value: function() {
          return o.centroid(this.p0, this.p1, this.p2);
        } }, { key: "inCentre", value: function() {
          return o.inCentre(this.p0, this.p1, this.p2);
        } }], [{ key: "constructor_", value: function() {
          this.p0 = null, this.p1 = null, this.p2 = null;
          var n = arguments[0], i = arguments[1], a = arguments[2];
          this.p0 = n, this.p1 = i, this.p2 = a;
        } }, { key: "area", value: function(n, i, a) {
          return Math.abs(((a.x - n.x) * (i.y - n.y) - (i.x - n.x) * (a.y - n.y)) / 2);
        } }, { key: "signedArea", value: function(n, i, a) {
          return ((a.x - n.x) * (i.y - n.y) - (i.x - n.x) * (a.y - n.y)) / 2;
        } }, { key: "det", value: function(n, i, a, c) {
          return n * c - i * a;
        } }, { key: "interpolateZ", value: function(n, i, a, c) {
          var g = i.x, m = i.y, y = a.x - g, w = c.x - g, A = a.y - m, z = c.y - m, V = y * z - w * A, ee = n.x - g, ue = n.y - m, fe = (z * ee - w * ue) / V, me = (-A * ee + y * ue) / V;
          return i.getZ() + fe * (a.getZ() - i.getZ()) + me * (c.getZ() - i.getZ());
        } }, { key: "longestSideLength", value: function(n, i, a) {
          var c = n.distance(i), g = i.distance(a), m = a.distance(n), y = c;
          return g > y && (y = g), m > y && (y = m), y;
        } }, { key: "circumcentreDD", value: function(n, i, a) {
          var c = ve.valueOf(n.x).subtract(a.x), g = ve.valueOf(n.y).subtract(a.y), m = ve.valueOf(i.x).subtract(a.x), y = ve.valueOf(i.y).subtract(a.y), w = ve.determinant(c, g, m, y).multiply(2), A = c.sqr().add(g.sqr()), z = m.sqr().add(y.sqr()), V = ve.determinant(g, A, y, z), ee = ve.determinant(c, A, m, z), ue = ve.valueOf(a.x).subtract(V.divide(w)).doubleValue(), fe = ve.valueOf(a.y).add(ee.divide(w)).doubleValue();
          return new H(ue, fe);
        } }, { key: "isAcute", value: function(n, i, a) {
          return !!Ut.isAcute(n, i, a) && !!Ut.isAcute(i, a, n) && !!Ut.isAcute(a, n, i);
        } }, { key: "circumcentre", value: function(n, i, a) {
          var c = a.x, g = a.y, m = n.x - c, y = n.y - g, w = i.x - c, A = i.y - g, z = 2 * o.det(m, y, w, A), V = o.det(y, m * m + y * y, A, w * w + A * A), ee = o.det(m, m * m + y * y, w, w * w + A * A);
          return new H(c - V / z, g + ee / z);
        } }, { key: "perpendicularBisector", value: function(n, i) {
          var a = i.x - n.x, c = i.y - n.y, g = new qo(n.x + a / 2, n.y + c / 2, 1), m = new qo(n.x - c + a / 2, n.y + a + c / 2, 1);
          return new qo(g, m);
        } }, { key: "angleBisector", value: function(n, i, a) {
          var c = i.distance(n), g = c / (c + i.distance(a)), m = a.x - n.x, y = a.y - n.y;
          return new H(n.x + g * m, n.y + g * y);
        } }, { key: "area3D", value: function(n, i, a) {
          var c = i.x - n.x, g = i.y - n.y, m = i.getZ() - n.getZ(), y = a.x - n.x, w = a.y - n.y, A = a.getZ() - n.getZ(), z = g * A - m * w, V = m * y - c * A, ee = c * w - g * y, ue = z * z + V * V + ee * ee, fe = Math.sqrt(ue) / 2;
          return fe;
        } }, { key: "centroid", value: function(n, i, a) {
          var c = (n.x + i.x + a.x) / 3, g = (n.y + i.y + a.y) / 3;
          return new H(c, g);
        } }, { key: "inCentre", value: function(n, i, a) {
          var c = i.distance(a), g = n.distance(a), m = n.distance(i), y = c + g + m, w = (c * n.x + g * i.x + m * a.x) / y, A = (c * n.y + g * i.y + m * a.y) / y;
          return new H(w, A);
        } }]);
      })(), om = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "addRingSide", value: function(o, n, i, a, c) {
          if (n === 0 && o.length < xr.MINIMUM_VALID_SIZE) return null;
          var g = a, m = c;
          o.length >= xr.MINIMUM_VALID_SIZE && ye.isCCW(o) && (g = c, m = a, i = re.opposite(i));
          var y = this._curveBuilder.getRingCurve(o, i, n);
          this.addCurve(y, g, m);
        } }, { key: "addRingBothSides", value: function(o, n) {
          this.addRingSide(o, n, re.LEFT, N.EXTERIOR, N.INTERIOR), this.addRingSide(o, n, re.RIGHT, N.INTERIOR, N.EXTERIOR);
        } }, { key: "addPoint", value: function(o) {
          if (this._distance <= 0) return null;
          var n = o.getCoordinates(), i = this._curveBuilder.getLineCurve(n, this._distance);
          this.addCurve(i, N.EXTERIOR, N.INTERIOR);
        } }, { key: "addPolygon", value: function(o) {
          var n = this._distance, i = re.LEFT;
          this._distance < 0 && (n = -this._distance, i = re.RIGHT);
          var a = o.getExteriorRing(), c = Q.removeRepeatedPoints(a.getCoordinates());
          if (this._distance < 0 && this.isErodedCompletely(a, this._distance) || this._distance <= 0 && c.length < 3) return null;
          this.addRingSide(c, n, i, N.EXTERIOR, N.INTERIOR);
          for (var g = 0; g < o.getNumInteriorRing(); g++) {
            var m = o.getInteriorRingN(g), y = Q.removeRepeatedPoints(m.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(m, -this._distance) || this.addRingSide(y, n, re.opposite(i), N.INTERIOR, N.EXTERIOR);
          }
        } }, { key: "isTriangleErodedCompletely", value: function(o, n) {
          var i = new am(o[0], o[1], o[2]), a = i.inCentre();
          return Et.pointToSegment(a, i.p0, i.p1) < Math.abs(n);
        } }, { key: "addLineString", value: function(o) {
          if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
          var n = Q.removeRepeatedPoints(o.getCoordinates());
          if (Q.isRing(n) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(n, this._distance);
          else {
            var i = this._curveBuilder.getLineCurve(n, this._distance);
            this.addCurve(i, N.EXTERIOR, N.INTERIOR);
          }
        } }, { key: "addCurve", value: function(o, n, i) {
          if (o === null || o.length < 2) return null;
          var a = new Hr(o, new Xt(0, N.BOUNDARY, n, i));
          this._curveList.add(a);
        } }, { key: "getCurves", value: function() {
          return this.add(this._inputGeom), this._curveList;
        } }, { key: "add", value: function(o) {
          if (o.isEmpty()) return null;
          if (o instanceof qr) this.addPolygon(o);
          else if (o instanceof Zn) this.addLineString(o);
          else if (o instanceof pi) this.addPoint(o);
          else if (o instanceof vi) this.addCollection(o);
          else if (o instanceof yi) this.addCollection(o);
          else if (o instanceof Gt) this.addCollection(o);
          else {
            if (!(o instanceof Ve)) throw new ke(o.getGeometryType());
            this.addCollection(o);
          }
        } }, { key: "isErodedCompletely", value: function(o, n) {
          var i = o.getCoordinates();
          if (i.length < 4) return n < 0;
          if (i.length === 4) return this.isTriangleErodedCompletely(i, n);
          var a = o.getEnvelopeInternal(), c = Math.min(a.getHeight(), a.getWidth());
          return n < 0 && 2 * Math.abs(n) > c;
        } }, { key: "addCollection", value: function(o) {
          for (var n = 0; n < o.getNumGeometries(); n++) {
            var i = o.getGeometryN(n);
            this.add(i);
          }
        } }], [{ key: "constructor_", value: function() {
          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new pe();
          var o = arguments[0], n = arguments[1], i = arguments[2];
          this._inputGeom = o, this._distance = n, this._curveBuilder = i;
        } }]);
      })(), um = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "locate", value: function(o) {
        } }]);
      })(), lm = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "next", value: function() {
          if (this._atStart) return this._atStart = false, o.isAtomic(this._parent) && this._index++, this._parent;
          if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
            this._subcollectionIterator = null;
          }
          if (this._index >= this._max) throw new De();
          var n = this._parent.getGeometryN(this._index++);
          return n instanceof Ve ? (this._subcollectionIterator = new o(n), this._subcollectionIterator.next()) : n;
        } }, { key: "remove", value: function() {
          throw new ke(this.getClass().getName());
        } }, { key: "hasNext", value: function() {
          if (this._atStart) return true;
          if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return true;
            this._subcollectionIterator = null;
          }
          return !(this._index >= this._max);
        } }, { key: "interfaces_", get: function() {
          return [Kp];
        } }], [{ key: "constructor_", value: function() {
          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
          var n = arguments[0];
          this._parent = n, this._atStart = true, this._index = 0, this._max = n.getNumGeometries();
        } }, { key: "isAtomic", value: function(n) {
          return !(n instanceof Ve);
        } }]);
      })(), cm = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "locate", value: function(n) {
          return o.locate(n, this._geom);
        } }, { key: "interfaces_", get: function() {
          return [um];
        } }], [{ key: "constructor_", value: function() {
          this._geom = null;
          var n = arguments[0];
          this._geom = n;
        } }, { key: "locatePointInPolygon", value: function(n, i) {
          if (i.isEmpty()) return N.EXTERIOR;
          var a = i.getExteriorRing(), c = o.locatePointInRing(n, a);
          if (c !== N.INTERIOR) return c;
          for (var g = 0; g < i.getNumInteriorRing(); g++) {
            var m = i.getInteriorRingN(g), y = o.locatePointInRing(n, m);
            if (y === N.BOUNDARY) return N.BOUNDARY;
            if (y === N.INTERIOR) return N.EXTERIOR;
          }
          return N.INTERIOR;
        } }, { key: "locatePointInRing", value: function(n, i) {
          return i.getEnvelopeInternal().intersects(n) ? Fo.locateInRing(n, i.getCoordinates()) : N.EXTERIOR;
        } }, { key: "containsPointInPolygon", value: function(n, i) {
          return N.EXTERIOR !== o.locatePointInPolygon(n, i);
        } }, { key: "locateInGeometry", value: function(n, i) {
          if (i instanceof qr) return o.locatePointInPolygon(n, i);
          if (i instanceof Ve) for (var a = new lm(i); a.hasNext(); ) {
            var c = a.next();
            if (c !== i) {
              var g = o.locateInGeometry(n, c);
              if (g !== N.EXTERIOR) return g;
            }
          }
          return N.EXTERIOR;
        } }, { key: "isContained", value: function(n, i) {
          return N.EXTERIOR !== o.locate(n, i);
        } }, { key: "locate", value: function(n, i) {
          return i.isEmpty() ? N.EXTERIOR : i.getEnvelopeInternal().intersects(n) ? o.locateInGeometry(n, i) : N.EXTERIOR;
        } }]);
      })(), hm = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "getNextCW", value: function(o) {
          this.getEdges();
          var n = this._edgeList.indexOf(o), i = n - 1;
          return n === 0 && (i = this._edgeList.size() - 1), this._edgeList.get(i);
        } }, { key: "propagateSideLabels", value: function(o) {
          for (var n = N.NONE, i = this.iterator(); i.hasNext(); ) {
            var a = i.next().getLabel();
            a.isArea(o) && a.getLocation(o, re.LEFT) !== N.NONE && (n = a.getLocation(o, re.LEFT));
          }
          if (n === N.NONE) return null;
          for (var c = n, g = this.iterator(); g.hasNext(); ) {
            var m = g.next(), y = m.getLabel();
            if (y.getLocation(o, re.ON) === N.NONE && y.setLocation(o, re.ON, c), y.isArea(o)) {
              var w = y.getLocation(o, re.LEFT), A = y.getLocation(o, re.RIGHT);
              if (A !== N.NONE) {
                if (A !== c) throw new Nt("side location conflict", m.getCoordinate());
                w === N.NONE && ae.shouldNeverReachHere("found single null side (at " + m.getCoordinate() + ")"), c = w;
              } else ae.isTrue(y.getLocation(o, re.LEFT) === N.NONE, "found single null side"), y.setLocation(o, re.RIGHT, c), y.setLocation(o, re.LEFT, c);
            }
          }
        } }, { key: "getCoordinate", value: function() {
          var o = this.iterator();
          return o.hasNext() ? o.next().getCoordinate() : null;
        } }, { key: "print", value: function(o) {
          Pt.out.println("EdgeEndStar:   " + this.getCoordinate());
          for (var n = this.iterator(); n.hasNext(); )
            n.next().print(o);
        } }, { key: "isAreaLabelsConsistent", value: function(o) {
          return this.computeEdgeEndLabels(o.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
        } }, { key: "checkAreaLabelsConsistent", value: function(o) {
          var n = this.getEdges();
          if (n.size() <= 0) return true;
          var i = n.size() - 1, a = n.get(i).getLabel().getLocation(o, re.LEFT);
          ae.isTrue(a !== N.NONE, "Found unlabelled area edge");
          for (var c = a, g = this.iterator(); g.hasNext(); ) {
            var m = g.next().getLabel();
            ae.isTrue(m.isArea(o), "Found non-area edge");
            var y = m.getLocation(o, re.LEFT), w = m.getLocation(o, re.RIGHT);
            if (y === w || w !== c) return false;
            c = y;
          }
          return true;
        } }, { key: "findIndex", value: function(o) {
          this.iterator();
          for (var n = 0; n < this._edgeList.size(); n++)
            if (this._edgeList.get(n) === o) return n;
          return -1;
        } }, { key: "iterator", value: function() {
          return this.getEdges().iterator();
        } }, { key: "getEdges", value: function() {
          return this._edgeList === null && (this._edgeList = new pe(this._edgeMap.values())), this._edgeList;
        } }, { key: "getLocation", value: function(o, n, i) {
          return this._ptInAreaLocation[o] === N.NONE && (this._ptInAreaLocation[o] = cm.locate(n, i[o].getGeometry())), this._ptInAreaLocation[o];
        } }, { key: "toString", value: function() {
          var o = new cn();
          o.append("EdgeEndStar:   " + this.getCoordinate()), o.append(`
`);
          for (var n = this.iterator(); n.hasNext(); ) {
            var i = n.next();
            o.append(i), o.append(`
`);
          }
          return o.toString();
        } }, { key: "computeEdgeEndLabels", value: function(o) {
          for (var n = this.iterator(); n.hasNext(); )
            n.next().computeLabel(o);
        } }, { key: "computeLabelling", value: function(o) {
          this.computeEdgeEndLabels(o[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
          for (var n = [false, false], i = this.iterator(); i.hasNext(); ) for (var a = i.next().getLabel(), c = 0; c < 2; c++) a.isLine(c) && a.getLocation(c) === N.BOUNDARY && (n[c] = true);
          for (var g = this.iterator(); g.hasNext(); ) for (var m = g.next(), y = m.getLabel(), w = 0; w < 2; w++) if (y.isAnyNull(w)) {
            var A = N.NONE;
            if (n[w]) A = N.EXTERIOR;
            else {
              var z = m.getCoordinate();
              A = this.getLocation(w, z, o);
            }
            y.setAllLocationsIfNull(w, A);
          }
        } }, { key: "getDegree", value: function() {
          return this._edgeMap.size();
        } }, { key: "insertEdgeEnd", value: function(o, n) {
          this._edgeMap.put(o, n), this._edgeList = null;
        } }], [{ key: "constructor_", value: function() {
          this._edgeMap = new ls(), this._edgeList = null, this._ptInAreaLocation = [N.NONE, N.NONE];
        } }]);
      })(), fm = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "linkResultDirectedEdges", value: function() {
          this.getResultAreaEdges();
          for (var i = null, a = null, c = this._SCANNING_FOR_INCOMING, g = 0; g < this._resultAreaEdgeList.size(); g++) {
            var m = this._resultAreaEdgeList.get(g), y = m.getSym();
            if (m.getLabel().isArea()) switch (i === null && m.isInResult() && (i = m), c) {
              case this._SCANNING_FOR_INCOMING:
                if (!y.isInResult()) continue;
                a = y, c = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (!m.isInResult()) continue;
                a.setNext(m), c = this._SCANNING_FOR_INCOMING;
            }
          }
          if (c === this._LINKING_TO_OUTGOING) {
            if (i === null) throw new Nt("no outgoing dirEdge found", this.getCoordinate());
            ae.isTrue(i.isInResult(), "unable to link last incoming dirEdge"), a.setNext(i);
          }
        } }, { key: "insert", value: function(i) {
          var a = i;
          this.insertEdgeEnd(a, a);
        } }, { key: "getRightmostEdge", value: function() {
          var i = this.getEdges(), a = i.size();
          if (a < 1) return null;
          var c = i.get(0);
          if (a === 1) return c;
          var g = i.get(a - 1), m = c.getQuadrant(), y = g.getQuadrant();
          return xt.isNorthern(m) && xt.isNorthern(y) ? c : xt.isNorthern(m) || xt.isNorthern(y) ? c.getDy() !== 0 ? c : g.getDy() !== 0 ? g : (ae.shouldNeverReachHere("found two horizontal edges incident on node"), null) : g;
        } }, { key: "print", value: function(i) {
          Pt.out.println("DirectedEdgeStar: " + this.getCoordinate());
          for (var a = this.iterator(); a.hasNext(); ) {
            var c = a.next();
            i.print("out "), c.print(i), i.println(), i.print("in "), c.getSym().print(i), i.println();
          }
        } }, { key: "getResultAreaEdges", value: function() {
          if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
          this._resultAreaEdgeList = new pe();
          for (var i = this.iterator(); i.hasNext(); ) {
            var a = i.next();
            (a.isInResult() || a.getSym().isInResult()) && this._resultAreaEdgeList.add(a);
          }
          return this._resultAreaEdgeList;
        } }, { key: "updateLabelling", value: function(i) {
          for (var a = this.iterator(); a.hasNext(); ) {
            var c = a.next().getLabel();
            c.setAllLocationsIfNull(0, i.getLocation(0)), c.setAllLocationsIfNull(1, i.getLocation(1));
          }
        } }, { key: "linkAllDirectedEdges", value: function() {
          this.getEdges();
          for (var i = null, a = null, c = this._edgeList.size() - 1; c >= 0; c--) {
            var g = this._edgeList.get(c), m = g.getSym();
            a === null && (a = m), i !== null && m.setNext(i), i = g;
          }
          a.setNext(i);
        } }, { key: "computeDepths", value: function() {
          if (arguments.length === 1) {
            var i = arguments[0], a = this.findIndex(i), c = i.getDepth(re.LEFT), g = i.getDepth(re.RIGHT), m = this.computeDepths(a + 1, this._edgeList.size(), c);
            if (this.computeDepths(0, a, m) !== g) throw new Nt("depth mismatch at " + i.getCoordinate());
          } else if (arguments.length === 3) {
            for (var y = arguments[1], w = arguments[2], A = arguments[0]; A < y; A++) {
              var z = this._edgeList.get(A);
              z.setEdgeDepths(re.RIGHT, w), w = z.getDepth(re.LEFT);
            }
            return w;
          }
        } }, { key: "mergeSymLabels", value: function() {
          for (var i = this.iterator(); i.hasNext(); ) {
            var a = i.next();
            a.getLabel().merge(a.getSym().getLabel());
          }
        } }, { key: "linkMinimalDirectedEdges", value: function(i) {
          for (var a = null, c = null, g = this._SCANNING_FOR_INCOMING, m = this._resultAreaEdgeList.size() - 1; m >= 0; m--) {
            var y = this._resultAreaEdgeList.get(m), w = y.getSym();
            switch (a === null && y.getEdgeRing() === i && (a = y), g) {
              case this._SCANNING_FOR_INCOMING:
                if (w.getEdgeRing() !== i) continue;
                c = w, g = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (y.getEdgeRing() !== i) continue;
                c.setNextMin(y), g = this._SCANNING_FOR_INCOMING;
            }
          }
          g === this._LINKING_TO_OUTGOING && (ae.isTrue(a !== null, "found null for first outgoing dirEdge"), ae.isTrue(a.getEdgeRing() === i, "unable to link last incoming dirEdge"), c.setNextMin(a));
        } }, { key: "getOutgoingDegree", value: function() {
          if (arguments.length === 0) {
            for (var i = 0, a = this.iterator(); a.hasNext(); )
              a.next().isInResult() && i++;
            return i;
          }
          if (arguments.length === 1) {
            for (var c = arguments[0], g = 0, m = this.iterator(); m.hasNext(); )
              m.next().getEdgeRing() === c && g++;
            return g;
          }
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "findCoveredLineEdges", value: function() {
          for (var i = N.NONE, a = this.iterator(); a.hasNext(); ) {
            var c = a.next(), g = c.getSym();
            if (!c.isLineEdge()) {
              if (c.isInResult()) {
                i = N.INTERIOR;
                break;
              }
              if (g.isInResult()) {
                i = N.EXTERIOR;
                break;
              }
            }
          }
          if (i === N.NONE) return null;
          for (var m = i, y = this.iterator(); y.hasNext(); ) {
            var w = y.next(), A = w.getSym();
            w.isLineEdge() ? w.getEdge().setCovered(m === N.INTERIOR) : (w.isInResult() && (m = N.EXTERIOR), A.isInResult() && (m = N.INTERIOR));
          }
        } }, { key: "computeLabelling", value: function(i) {
          I(n, "computeLabelling", this, 1).call(this, i), this._label = new Xt(N.NONE);
          for (var a = this.iterator(); a.hasNext(); ) for (var c = a.next().getEdge().getLabel(), g = 0; g < 2; g++) {
            var m = c.getLocation(g);
            m !== N.INTERIOR && m !== N.BOUNDARY || this._label.setLocation(g, N.INTERIOR);
          }
        } }], [{ key: "constructor_", value: function() {
          this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
        } }]);
      })(hm), gm = (function(o) {
        function n() {
          return u(this, n), s(this, n);
        }
        return _(n, o), h(n, [{ key: "createNode", value: function(i) {
          return new va(i, new fm());
        } }]);
      })(pc), bc = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "compareTo", value: function(n) {
          var i = n;
          return o.compareOriented(this._pts, this._orientation, i._pts, i._orientation);
        } }, { key: "interfaces_", get: function() {
          return [j];
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._orientation = null;
          var n = arguments[0];
          this._pts = n, this._orientation = o.orientation(n);
        } }, { key: "orientation", value: function(n) {
          return Q.increasingDirection(n) === 1;
        } }, { key: "compareOriented", value: function(n, i, a, c) {
          for (var g = i ? 1 : -1, m = c ? 1 : -1, y = i ? n.length : -1, w = c ? a.length : -1, A = i ? 0 : n.length - 1, z = c ? 0 : a.length - 1; ; ) {
            var V = n[A].compareTo(a[z]);
            if (V !== 0) return V;
            var ee = (A += g) === y, ue = (z += m) === w;
            if (ee && !ue) return -1;
            if (!ee && ue) return 1;
            if (ee && ue) return 0;
          }
        } }]);
      })(), dm = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "print", value: function(o) {
          o.print("MULTILINESTRING ( ");
          for (var n = 0; n < this._edges.size(); n++) {
            var i = this._edges.get(n);
            n > 0 && o.print(","), o.print("(");
            for (var a = i.getCoordinates(), c = 0; c < a.length; c++) c > 0 && o.print(","), o.print(a[c].x + " " + a[c].y);
            o.println(")");
          }
          o.print(")  ");
        } }, { key: "addAll", value: function(o) {
          for (var n = o.iterator(); n.hasNext(); ) this.add(n.next());
        } }, { key: "findEdgeIndex", value: function(o) {
          for (var n = 0; n < this._edges.size(); n++) if (this._edges.get(n).equals(o)) return n;
          return -1;
        } }, { key: "iterator", value: function() {
          return this._edges.iterator();
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "get", value: function(o) {
          return this._edges.get(o);
        } }, { key: "findEqualEdge", value: function(o) {
          var n = new bc(o.getCoordinates());
          return this._ocaMap.get(n);
        } }, { key: "add", value: function(o) {
          this._edges.add(o);
          var n = new bc(o.getCoordinates());
          this._ocaMap.put(n, o);
        } }], [{ key: "constructor_", value: function() {
          this._edges = new pe(), this._ocaMap = new ls();
        } }]);
      })(), Ac = (function() {
        return h((function o() {
          u(this, o);
        }), [{ key: "processIntersections", value: function(o, n, i, a) {
        } }, { key: "isDone", value: function() {
        } }]);
      })(), pm = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "isTrivialIntersection", value: function(n, i, a, c) {
          if (n === a && this._li.getIntersectionNum() === 1) {
            if (o.isAdjacentSegments(i, c)) return true;
            if (n.isClosed()) {
              var g = n.size() - 1;
              if (i === 0 && c === g || c === 0 && i === g) return true;
            }
          }
          return false;
        } }, { key: "getProperIntersectionPoint", value: function() {
          return this._properIntersectionPoint;
        } }, { key: "hasProperInteriorIntersection", value: function() {
          return this._hasProperInterior;
        } }, { key: "getLineIntersector", value: function() {
          return this._li;
        } }, { key: "hasProperIntersection", value: function() {
          return this._hasProper;
        } }, { key: "processIntersections", value: function(n, i, a, c) {
          if (n === a && i === c) return null;
          this.numTests++;
          var g = n.getCoordinates()[i], m = n.getCoordinates()[i + 1], y = a.getCoordinates()[c], w = a.getCoordinates()[c + 1];
          this._li.computeIntersection(g, m, y, w), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = true), this.isTrivialIntersection(n, i, a, c) || (this._hasIntersection = true, n.addIntersections(this._li, i, 0), a.addIntersections(this._li, c, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = true, this._hasProperInterior = true)));
        } }, { key: "hasIntersection", value: function() {
          return this._hasIntersection;
        } }, { key: "isDone", value: function() {
          return false;
        } }, { key: "hasInteriorIntersection", value: function() {
          return this._hasInterior;
        } }, { key: "interfaces_", get: function() {
          return [Ac];
        } }], [{ key: "constructor_", value: function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._hasInterior = false, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
          var n = arguments[0];
          this._li = n;
        } }, { key: "isAdjacentSegments", value: function(n, i) {
          return Math.abs(n - i) === 1;
        } }]);
      })(), mm = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "getSegmentIndex", value: function() {
          return this.segmentIndex;
        } }, { key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(o) {
          o.print(this.coord), o.print(" seg # = " + this.segmentIndex), o.println(" dist = " + this.dist);
        } }, { key: "compareTo", value: function(o) {
          var n = o;
          return this.compare(n.segmentIndex, n.dist);
        } }, { key: "isEndPoint", value: function(o) {
          return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === o;
        } }, { key: "toString", value: function() {
          return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
        } }, { key: "getDistance", value: function() {
          return this.dist;
        } }, { key: "compare", value: function(o, n) {
          return this.segmentIndex < o ? -1 : this.segmentIndex > o ? 1 : this.dist < n ? -1 : this.dist > n ? 1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [j];
        } }], [{ key: "constructor_", value: function() {
          this.coord = null, this.segmentIndex = null, this.dist = null;
          var o = arguments[0], n = arguments[1], i = arguments[2];
          this.coord = new H(o), this.segmentIndex = n, this.dist = i;
        } }]);
      })(), vm = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "print", value: function(o) {
          o.println("Intersections:");
          for (var n = this.iterator(); n.hasNext(); )
            n.next().print(o);
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(o) {
          this.addEndpoints();
          for (var n = this.iterator(), i = n.next(); n.hasNext(); ) {
            var a = n.next(), c = this.createSplitEdge(i, a);
            o.add(c), i = a;
          }
        } }, { key: "addEndpoints", value: function() {
          var o = this.edge.pts.length - 1;
          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[o], o, 0);
        } }, { key: "createSplitEdge", value: function(o, n) {
          var i = n.segmentIndex - o.segmentIndex + 2, a = this.edge.pts[n.segmentIndex], c = n.dist > 0 || !n.coord.equals2D(a);
          c || i--;
          var g = new Array(i).fill(null), m = 0;
          g[m++] = new H(o.coord);
          for (var y = o.segmentIndex + 1; y <= n.segmentIndex; y++) g[m++] = this.edge.pts[y];
          return c && (g[m] = n.coord), new Tc(g, new Xt(this.edge._label));
        } }, { key: "add", value: function(o, n, i) {
          var a = new mm(o, n, i), c = this._nodeMap.get(a);
          return c !== null ? c : (this._nodeMap.put(a, a), a);
        } }, { key: "isIntersection", value: function(o) {
          for (var n = this.iterator(); n.hasNext(); )
            if (n.next().coord.equals(o)) return true;
          return false;
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new ls(), this.edge = null;
          var o = arguments[0];
          this.edge = o;
        } }]);
      })(), ym = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "isIntersects", value: function() {
          return !this.isDisjoint();
        } }, { key: "isCovers", value: function() {
          return (o.isTrue(this._matrix[N.INTERIOR][N.INTERIOR]) || o.isTrue(this._matrix[N.INTERIOR][N.BOUNDARY]) || o.isTrue(this._matrix[N.BOUNDARY][N.INTERIOR]) || o.isTrue(this._matrix[N.BOUNDARY][N.BOUNDARY])) && this._matrix[N.EXTERIOR][N.INTERIOR] === ie.FALSE && this._matrix[N.EXTERIOR][N.BOUNDARY] === ie.FALSE;
        } }, { key: "isCoveredBy", value: function() {
          return (o.isTrue(this._matrix[N.INTERIOR][N.INTERIOR]) || o.isTrue(this._matrix[N.INTERIOR][N.BOUNDARY]) || o.isTrue(this._matrix[N.BOUNDARY][N.INTERIOR]) || o.isTrue(this._matrix[N.BOUNDARY][N.BOUNDARY])) && this._matrix[N.INTERIOR][N.EXTERIOR] === ie.FALSE && this._matrix[N.BOUNDARY][N.EXTERIOR] === ie.FALSE;
        } }, { key: "set", value: function() {
          if (arguments.length === 1) for (var n = arguments[0], i = 0; i < n.length; i++) {
            var a = Math.trunc(i / 3), c = i % 3;
            this._matrix[a][c] = ie.toDimensionValue(n.charAt(i));
          }
          else if (arguments.length === 3) {
            var g = arguments[0], m = arguments[1], y = arguments[2];
            this._matrix[g][m] = y;
          }
        } }, { key: "isContains", value: function() {
          return o.isTrue(this._matrix[N.INTERIOR][N.INTERIOR]) && this._matrix[N.EXTERIOR][N.INTERIOR] === ie.FALSE && this._matrix[N.EXTERIOR][N.BOUNDARY] === ie.FALSE;
        } }, { key: "setAtLeast", value: function() {
          if (arguments.length === 1) for (var n = arguments[0], i = 0; i < n.length; i++) {
            var a = Math.trunc(i / 3), c = i % 3;
            this.setAtLeast(a, c, ie.toDimensionValue(n.charAt(i)));
          }
          else if (arguments.length === 3) {
            var g = arguments[0], m = arguments[1], y = arguments[2];
            this._matrix[g][m] < y && (this._matrix[g][m] = y);
          }
        } }, { key: "setAtLeastIfValid", value: function(n, i, a) {
          n >= 0 && i >= 0 && this.setAtLeast(n, i, a);
        } }, { key: "isWithin", value: function() {
          return o.isTrue(this._matrix[N.INTERIOR][N.INTERIOR]) && this._matrix[N.INTERIOR][N.EXTERIOR] === ie.FALSE && this._matrix[N.BOUNDARY][N.EXTERIOR] === ie.FALSE;
        } }, { key: "isTouches", value: function(n, i) {
          return n > i ? this.isTouches(i, n) : (n === ie.A && i === ie.A || n === ie.L && i === ie.L || n === ie.L && i === ie.A || n === ie.P && i === ie.A || n === ie.P && i === ie.L) && this._matrix[N.INTERIOR][N.INTERIOR] === ie.FALSE && (o.isTrue(this._matrix[N.INTERIOR][N.BOUNDARY]) || o.isTrue(this._matrix[N.BOUNDARY][N.INTERIOR]) || o.isTrue(this._matrix[N.BOUNDARY][N.BOUNDARY]));
        } }, { key: "isOverlaps", value: function(n, i) {
          return n === ie.P && i === ie.P || n === ie.A && i === ie.A ? o.isTrue(this._matrix[N.INTERIOR][N.INTERIOR]) && o.isTrue(this._matrix[N.INTERIOR][N.EXTERIOR]) && o.isTrue(this._matrix[N.EXTERIOR][N.INTERIOR]) : n === ie.L && i === ie.L && this._matrix[N.INTERIOR][N.INTERIOR] === 1 && o.isTrue(this._matrix[N.INTERIOR][N.EXTERIOR]) && o.isTrue(this._matrix[N.EXTERIOR][N.INTERIOR]);
        } }, { key: "isEquals", value: function(n, i) {
          return n === i && o.isTrue(this._matrix[N.INTERIOR][N.INTERIOR]) && this._matrix[N.INTERIOR][N.EXTERIOR] === ie.FALSE && this._matrix[N.BOUNDARY][N.EXTERIOR] === ie.FALSE && this._matrix[N.EXTERIOR][N.INTERIOR] === ie.FALSE && this._matrix[N.EXTERIOR][N.BOUNDARY] === ie.FALSE;
        } }, { key: "toString", value: function() {
          for (var n = new Qe("123456789"), i = 0; i < 3; i++) for (var a = 0; a < 3; a++) n.setCharAt(3 * i + a, ie.toDimensionSymbol(this._matrix[i][a]));
          return n.toString();
        } }, { key: "setAll", value: function(n) {
          for (var i = 0; i < 3; i++) for (var a = 0; a < 3; a++) this._matrix[i][a] = n;
        } }, { key: "get", value: function(n, i) {
          return this._matrix[n][i];
        } }, { key: "transpose", value: function() {
          var n = this._matrix[1][0];
          return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = n, n = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = n, n = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = n, this;
        } }, { key: "matches", value: function(n) {
          if (n.length !== 9) throw new $("Should be length 9: " + n);
          for (var i = 0; i < 3; i++) for (var a = 0; a < 3; a++) if (!o.matches(this._matrix[i][a], n.charAt(3 * i + a))) return false;
          return true;
        } }, { key: "add", value: function(n) {
          for (var i = 0; i < 3; i++) for (var a = 0; a < 3; a++) this.setAtLeast(i, a, n.get(i, a));
        } }, { key: "isDisjoint", value: function() {
          return this._matrix[N.INTERIOR][N.INTERIOR] === ie.FALSE && this._matrix[N.INTERIOR][N.BOUNDARY] === ie.FALSE && this._matrix[N.BOUNDARY][N.INTERIOR] === ie.FALSE && this._matrix[N.BOUNDARY][N.BOUNDARY] === ie.FALSE;
        } }, { key: "isCrosses", value: function(n, i) {
          return n === ie.P && i === ie.L || n === ie.P && i === ie.A || n === ie.L && i === ie.A ? o.isTrue(this._matrix[N.INTERIOR][N.INTERIOR]) && o.isTrue(this._matrix[N.INTERIOR][N.EXTERIOR]) : n === ie.L && i === ie.P || n === ie.A && i === ie.P || n === ie.A && i === ie.L ? o.isTrue(this._matrix[N.INTERIOR][N.INTERIOR]) && o.isTrue(this._matrix[N.EXTERIOR][N.INTERIOR]) : n === ie.L && i === ie.L && this._matrix[N.INTERIOR][N.INTERIOR] === 0;
        } }, { key: "interfaces_", get: function() {
          return [x];
        } }], [{ key: "constructor_", value: function() {
          if (this._matrix = null, arguments.length === 0) this._matrix = Array(3).fill().map((function() {
            return Array(3);
          })), this.setAll(ie.FALSE);
          else if (arguments.length === 1) {
            if (typeof arguments[0] == "string") {
              var n = arguments[0];
              o.constructor_.call(this), this.set(n);
            } else if (arguments[0] instanceof o) {
              var i = arguments[0];
              o.constructor_.call(this), this._matrix[N.INTERIOR][N.INTERIOR] = i._matrix[N.INTERIOR][N.INTERIOR], this._matrix[N.INTERIOR][N.BOUNDARY] = i._matrix[N.INTERIOR][N.BOUNDARY], this._matrix[N.INTERIOR][N.EXTERIOR] = i._matrix[N.INTERIOR][N.EXTERIOR], this._matrix[N.BOUNDARY][N.INTERIOR] = i._matrix[N.BOUNDARY][N.INTERIOR], this._matrix[N.BOUNDARY][N.BOUNDARY] = i._matrix[N.BOUNDARY][N.BOUNDARY], this._matrix[N.BOUNDARY][N.EXTERIOR] = i._matrix[N.BOUNDARY][N.EXTERIOR], this._matrix[N.EXTERIOR][N.INTERIOR] = i._matrix[N.EXTERIOR][N.INTERIOR], this._matrix[N.EXTERIOR][N.BOUNDARY] = i._matrix[N.EXTERIOR][N.BOUNDARY], this._matrix[N.EXTERIOR][N.EXTERIOR] = i._matrix[N.EXTERIOR][N.EXTERIOR];
            }
          }
        } }, { key: "matches", value: function() {
          if (Number.isInteger(arguments[0]) && typeof arguments[1] == "string") {
            var n = arguments[0], i = arguments[1];
            return i === ie.SYM_DONTCARE || i === ie.SYM_TRUE && (n >= 0 || n === ie.TRUE) || i === ie.SYM_FALSE && n === ie.FALSE || i === ie.SYM_P && n === ie.P || i === ie.SYM_L && n === ie.L || i === ie.SYM_A && n === ie.A;
          }
          if (typeof arguments[0] == "string" && typeof arguments[1] == "string") {
            var a = arguments[1];
            return new o(arguments[0]).matches(a);
          }
        } }, { key: "isTrue", value: function(n) {
          return n >= 0 || n === ie.TRUE;
        } }]);
      })(), _m = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "size", value: function() {
          return this._size;
        } }, { key: "addAll", value: function(n) {
          return n === null || n.length === 0 ? null : (this.ensureCapacity(this._size + n.length), Pt.arraycopy(n, 0, this._data, this._size, n.length), void (this._size += n.length));
        } }, { key: "ensureCapacity", value: function(n) {
          if (n <= this._data.length) return null;
          var i = Math.max(n, 2 * this._data.length);
          this._data = rt.copyOf(this._data, i);
        } }, { key: "toArray", value: function() {
          var n = new Array(this._size).fill(null);
          return Pt.arraycopy(this._data, 0, n, 0, this._size), n;
        } }, { key: "add", value: function(n) {
          this.ensureCapacity(this._size + 1), this._data[this._size] = n, ++this._size;
        } }], [{ key: "constructor_", value: function() {
          if (this._data = null, this._size = 0, arguments.length === 0) o.constructor_.call(this, 10);
          else if (arguments.length === 1) {
            var n = arguments[0];
            this._data = new Array(n).fill(null);
          }
        } }]);
      })(), Em = (function() {
        function o() {
          u(this, o);
        }
        return h(o, [{ key: "getChainStartIndices", value: function(n) {
          var i = 0, a = new _m(Math.trunc(n.length / 2));
          a.add(i);
          do {
            var c = this.findChainEnd(n, i);
            a.add(c), i = c;
          } while (i < n.length - 1);
          return a.toArray();
        } }, { key: "findChainEnd", value: function(n, i) {
          for (var a = xt.quadrant(n[i], n[i + 1]), c = i + 1; c < n.length && xt.quadrant(n[c - 1], n[c]) === a; )
            c++;
          return c - 1;
        } }, { key: "OLDgetChainStartIndices", value: function(n) {
          var i = 0, a = new pe();
          a.add(i);
          do {
            var c = this.findChainEnd(n, i);
            a.add(c), i = c;
          } while (i < n.length - 1);
          return o.toIntArray(a);
        } }], [{ key: "toIntArray", value: function(n) {
          for (var i = new Array(n.size()).fill(null), a = 0; a < i.length; a++) i[a] = n.get(a).intValue();
          return i;
        } }]);
      })(), xm = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "getMaxX", value: function(o) {
          var n = this.pts[this.startIndex[o]].x, i = this.pts[this.startIndex[o + 1]].x;
          return n > i ? n : i;
        } }, { key: "getMinX", value: function(o) {
          var n = this.pts[this.startIndex[o]].x, i = this.pts[this.startIndex[o + 1]].x;
          return n < i ? n : i;
        } }, { key: "computeIntersectsForChain", value: function() {
          if (arguments.length === 4) {
            var o = arguments[0], n = arguments[1], i = arguments[2], a = arguments[3];
            this.computeIntersectsForChain(this.startIndex[o], this.startIndex[o + 1], n, n.startIndex[i], n.startIndex[i + 1], a);
          } else if (arguments.length === 6) {
            var c = arguments[0], g = arguments[1], m = arguments[2], y = arguments[3], w = arguments[4], A = arguments[5];
            if (g - c == 1 && w - y == 1) return A.addIntersections(this.e, c, m.e, y), null;
            if (!this.overlaps(c, g, m, y, w)) return null;
            var z = Math.trunc((c + g) / 2), V = Math.trunc((y + w) / 2);
            c < z && (y < V && this.computeIntersectsForChain(c, z, m, y, V, A), V < w && this.computeIntersectsForChain(c, z, m, V, w, A)), z < g && (y < V && this.computeIntersectsForChain(z, g, m, y, V, A), V < w && this.computeIntersectsForChain(z, g, m, V, w, A));
          }
        } }, { key: "overlaps", value: function(o, n, i, a, c) {
          return Ie.intersects(this.pts[o], this.pts[n], i.pts[a], i.pts[c]);
        } }, { key: "getStartIndexes", value: function() {
          return this.startIndex;
        } }, { key: "computeIntersects", value: function(o, n) {
          for (var i = 0; i < this.startIndex.length - 1; i++) for (var a = 0; a < o.startIndex.length - 1; a++) this.computeIntersectsForChain(i, o, a, n);
        } }], [{ key: "constructor_", value: function() {
          this.e = null, this.pts = null, this.startIndex = null;
          var o = arguments[0];
          this.e = o, this.pts = o.getCoordinates();
          var n = new Em();
          this.startIndex = n.getChainStartIndices(this.pts);
        } }]);
      })(), Lc = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "getDepth", value: function(n, i) {
          return this._depth[n][i];
        } }, { key: "setDepth", value: function(n, i, a) {
          this._depth[n][i] = a;
        } }, { key: "isNull", value: function() {
          if (arguments.length === 0) {
            for (var n = 0; n < 2; n++) for (var i = 0; i < 3; i++) if (this._depth[n][i] !== o.NULL_VALUE) return false;
            return true;
          }
          if (arguments.length === 1) {
            var a = arguments[0];
            return this._depth[a][1] === o.NULL_VALUE;
          }
          if (arguments.length === 2) {
            var c = arguments[0], g = arguments[1];
            return this._depth[c][g] === o.NULL_VALUE;
          }
        } }, { key: "normalize", value: function() {
          for (var n = 0; n < 2; n++) if (!this.isNull(n)) {
            var i = this._depth[n][1];
            this._depth[n][2] < i && (i = this._depth[n][2]), i < 0 && (i = 0);
            for (var a = 1; a < 3; a++) {
              var c = 0;
              this._depth[n][a] > i && (c = 1), this._depth[n][a] = c;
            }
          }
        } }, { key: "getDelta", value: function(n) {
          return this._depth[n][re.RIGHT] - this._depth[n][re.LEFT];
        } }, { key: "getLocation", value: function(n, i) {
          return this._depth[n][i] <= 0 ? N.EXTERIOR : N.INTERIOR;
        } }, { key: "toString", value: function() {
          return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
        } }, { key: "add", value: function() {
          if (arguments.length === 1) for (var n = arguments[0], i = 0; i < 2; i++) for (var a = 1; a < 3; a++) {
            var c = n.getLocation(i, a);
            c !== N.EXTERIOR && c !== N.INTERIOR || (this.isNull(i, a) ? this._depth[i][a] = o.depthAtLocation(c) : this._depth[i][a] += o.depthAtLocation(c));
          }
          else if (arguments.length === 3) {
            var g = arguments[0], m = arguments[1];
            arguments[2] === N.INTERIOR && this._depth[g][m]++;
          }
        } }], [{ key: "constructor_", value: function() {
          this._depth = Array(2).fill().map((function() {
            return Array(3);
          }));
          for (var n = 0; n < 2; n++) for (var i = 0; i < 3; i++) this._depth[n][i] = o.NULL_VALUE;
        } }, { key: "depthAtLocation", value: function(n) {
          return n === N.EXTERIOR ? 0 : n === N.INTERIOR ? 1 : o.NULL_VALUE;
        } }]);
      })();
      Lc.NULL_VALUE = -1;
      var Tc = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "getDepth", value: function() {
          return this._depth;
        } }, { key: "getCollapsedEdge", value: function() {
          var i = new Array(2).fill(null);
          return i[0] = this.pts[0], i[1] = this.pts[1], new n(i, Xt.toLineLabel(this._label));
        } }, { key: "isIsolated", value: function() {
          return this._isIsolated;
        } }, { key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "setIsolated", value: function(i) {
          this._isIsolated = i;
        } }, { key: "setName", value: function(i) {
          this._name = i;
        } }, { key: "equals", value: function(i) {
          if (!(i instanceof n)) return false;
          var a = i;
          if (this.pts.length !== a.pts.length) return false;
          for (var c = true, g = true, m = this.pts.length, y = 0; y < this.pts.length; y++) if (this.pts[y].equals2D(a.pts[y]) || (c = false), this.pts[y].equals2D(a.pts[--m]) || (g = false), !c && !g) return false;
          return true;
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 0) return this.pts.length > 0 ? this.pts[0] : null;
          if (arguments.length === 1) {
            var i = arguments[0];
            return this.pts[i];
          }
        } }, { key: "print", value: function(i) {
          i.print("edge " + this._name + ": "), i.print("LINESTRING (");
          for (var a = 0; a < this.pts.length; a++) a > 0 && i.print(","), i.print(this.pts[a].x + " " + this.pts[a].y);
          i.print(")  " + this._label + " " + this._depthDelta);
        } }, { key: "computeIM", value: function(i) {
          n.updateIM(this._label, i);
        } }, { key: "isCollapsed", value: function() {
          return !!this._label.isArea() && this.pts.length === 3 && !!this.pts[0].equals(this.pts[2]);
        } }, { key: "isClosed", value: function() {
          return this.pts[0].equals(this.pts[this.pts.length - 1]);
        } }, { key: "getMaximumSegmentIndex", value: function() {
          return this.pts.length - 1;
        } }, { key: "getDepthDelta", value: function() {
          return this._depthDelta;
        } }, { key: "getNumPoints", value: function() {
          return this.pts.length;
        } }, { key: "printReverse", value: function(i) {
          i.print("edge " + this._name + ": ");
          for (var a = this.pts.length - 1; a >= 0; a--) i.print(this.pts[a] + " ");
          i.println("");
        } }, { key: "getMonotoneChainEdge", value: function() {
          return this._mce === null && (this._mce = new xm(this)), this._mce;
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            this._env = new Ie();
            for (var i = 0; i < this.pts.length; i++) this._env.expandToInclude(this.pts[i]);
          }
          return this._env;
        } }, { key: "addIntersection", value: function(i, a, c, g) {
          var m = new H(i.getIntersection(g)), y = a, w = i.getEdgeDistance(c, g), A = y + 1;
          if (A < this.pts.length) {
            var z = this.pts[A];
            m.equals2D(z) && (y = A, w = 0);
          }
          this.eiList.add(m, y, w);
        } }, { key: "toString", value: function() {
          var i = new Qe();
          i.append("edge " + this._name + ": "), i.append("LINESTRING (");
          for (var a = 0; a < this.pts.length; a++) a > 0 && i.append(","), i.append(this.pts[a].x + " " + this.pts[a].y);
          return i.append(")  " + this._label + " " + this._depthDelta), i.toString();
        } }, { key: "isPointwiseEqual", value: function(i) {
          if (this.pts.length !== i.pts.length) return false;
          for (var a = 0; a < this.pts.length; a++) if (!this.pts[a].equals2D(i.pts[a])) return false;
          return true;
        } }, { key: "setDepthDelta", value: function(i) {
          this._depthDelta = i;
        } }, { key: "getEdgeIntersectionList", value: function() {
          return this.eiList;
        } }, { key: "addIntersections", value: function(i, a, c) {
          for (var g = 0; g < i.getIntersectionNum(); g++) this.addIntersection(i, a, c, g);
        } }], [{ key: "constructor_", value: function() {
          if (this.pts = null, this._env = null, this.eiList = new vm(this), this._name = null, this._mce = null, this._isIsolated = true, this._depth = new Lc(), this._depthDelta = 0, arguments.length === 1) {
            var i = arguments[0];
            n.constructor_.call(this, i, null);
          } else if (arguments.length === 2) {
            var a = arguments[0], c = arguments[1];
            this.pts = a, this._label = c;
          }
        } }, { key: "updateIM", value: function() {
          if (!(arguments.length === 2 && arguments[1] instanceof ym && arguments[0] instanceof Xt)) return I(n, "updateIM", this).apply(this, arguments);
          var i = arguments[0], a = arguments[1];
          a.setAtLeastIfValid(i.getLocation(0, re.ON), i.getLocation(1, re.ON), 1), i.isArea() && (a.setAtLeastIfValid(i.getLocation(0, re.LEFT), i.getLocation(1, re.LEFT), 2), a.setAtLeastIfValid(i.getLocation(0, re.RIGHT), i.getLocation(1, re.RIGHT), 2));
        } }]);
      })(cc), Cc = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "setWorkingPrecisionModel", value: function(n) {
          this._workingPrecisionModel = n;
        } }, { key: "insertUniqueEdge", value: function(n) {
          var i = this._edgeList.findEqualEdge(n);
          if (i !== null) {
            var a = i.getLabel(), c = n.getLabel();
            i.isPointwiseEqual(n) || (c = new Xt(n.getLabel())).flip(), a.merge(c);
            var g = o.depthDelta(c), m = i.getDepthDelta() + g;
            i.setDepthDelta(m);
          } else this._edgeList.add(n), n.setDepthDelta(o.depthDelta(n.getLabel()));
        } }, { key: "buildSubgraphs", value: function(n, i) {
          for (var a = new pe(), c = n.iterator(); c.hasNext(); ) {
            var g = c.next(), m = g.getRightmostCoordinate(), y = new Sc(a).getDepth(m);
            g.computeDepth(y), g.findResultEdges(), a.add(g), i.add(g.getDirectedEdges(), g.getNodes());
          }
        } }, { key: "createSubgraphs", value: function(n) {
          for (var i = new pe(), a = n.getNodes().iterator(); a.hasNext(); ) {
            var c = a.next();
            if (!c.isVisited()) {
              var g = new is();
              g.create(c), i.add(g);
            }
          }
          return xi.sort(i, xi.reverseOrder()), i;
        } }, { key: "createEmptyResultGeometry", value: function() {
          return this._geomFact.createPolygon();
        } }, { key: "getNoder", value: function(n) {
          if (this._workingNoder !== null) return this._workingNoder;
          var i = new zo(), a = new Yr();
          return a.setPrecisionModel(n), i.setSegmentIntersector(new pm(a)), i;
        } }, { key: "buffer", value: function(n, i) {
          var a = this._workingPrecisionModel;
          a === null && (a = n.getPrecisionModel()), this._geomFact = n.getFactory();
          var c = new sm(a, this._bufParams), g = new om(n, i, c).getCurves();
          if (g.size() <= 0) return this.createEmptyResultGeometry();
          this.computeNodedEdges(g, a), this._graph = new mc(new gm()), this._graph.addEdges(this._edgeList.getEdges());
          var m = this.createSubgraphs(this._graph), y = new $p(this._geomFact);
          this.buildSubgraphs(m, y);
          var w = y.getPolygons();
          return w.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(w);
        } }, { key: "computeNodedEdges", value: function(n, i) {
          var a = this.getNoder(i);
          a.computeNodes(n);
          for (var c = a.getNodedSubstrings().iterator(); c.hasNext(); ) {
            var g = c.next(), m = g.getCoordinates();
            if (m.length !== 2 || !m[0].equals2D(m[1])) {
              var y = g.getData(), w = new Tc(g.getCoordinates(), new Xt(y));
              this.insertUniqueEdge(w);
            }
          }
        } }, { key: "setNoder", value: function(n) {
          this._workingNoder = n;
        } }], [{ key: "constructor_", value: function() {
          this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new dm();
          var n = arguments[0];
          this._bufParams = n;
        } }, { key: "depthDelta", value: function(n) {
          var i = n.getLocation(0, re.LEFT), a = n.getLocation(0, re.RIGHT);
          return i === N.INTERIOR && a === N.EXTERIOR ? 1 : i === N.EXTERIOR && a === N.INTERIOR ? -1 : 0;
        } }, { key: "convertSegStrings", value: function(n) {
          for (var i = new _i4(), a = new pe(); n.hasNext(); ) {
            var c = n.next(), g = i.createLineString(c.getCoordinates());
            a.add(g);
          }
          return i.buildGeometry(a);
        } }]);
      })(), wm = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "rescale", value: function() {
          if (Ee(arguments[0], Ce)) for (var n = arguments[0].iterator(); n.hasNext(); ) {
            var i = n.next();
            this.rescale(i.getCoordinates());
          }
          else if (arguments[0] instanceof Array) {
            for (var a = arguments[0], c = 0; c < a.length; c++) a[c].x = a[c].x / this._scaleFactor + this._offsetX, a[c].y = a[c].y / this._scaleFactor + this._offsetY;
            a.length === 2 && a[0].equals2D(a[1]) && Pt.out.println(a);
          }
        } }, { key: "scale", value: function() {
          if (Ee(arguments[0], Ce)) {
            for (var n = arguments[0], i = new pe(n.size()), a = n.iterator(); a.hasNext(); ) {
              var c = a.next();
              i.add(new Hr(this.scale(c.getCoordinates()), c.getData()));
            }
            return i;
          }
          if (arguments[0] instanceof Array) {
            for (var g = arguments[0], m = new Array(g.length).fill(null), y = 0; y < g.length; y++) m[y] = new H(Math.round((g[y].x - this._offsetX) * this._scaleFactor), Math.round((g[y].y - this._offsetY) * this._scaleFactor), g[y].getZ());
            return Q.removeRepeatedPoints(m);
          }
        } }, { key: "isIntegerPrecision", value: function() {
          return this._scaleFactor === 1;
        } }, { key: "getNodedSubstrings", value: function() {
          var n = this._noder.getNodedSubstrings();
          return this._isScaled && this.rescale(n), n;
        } }, { key: "computeNodes", value: function(n) {
          var i = n;
          this._isScaled && (i = this.scale(n)), this._noder.computeNodes(i);
        } }, { key: "interfaces_", get: function() {
          return [Uo];
        } }], [{ key: "constructor_", value: function() {
          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = false, arguments.length === 2) {
            var n = arguments[0], i = arguments[1];
            o.constructor_.call(this, n, i, 0, 0);
          } else if (arguments.length === 4) {
            var a = arguments[0], c = arguments[1];
            this._noder = a, this._scaleFactor = c, this._isScaled = !this.isIntegerPrecision();
          }
        } }]);
      })(), Nc = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "checkEndPtVertexIntersections", value: function() {
          if (arguments.length === 0) for (var n = this._segStrings.iterator(); n.hasNext(); ) {
            var i = n.next().getCoordinates();
            this.checkEndPtVertexIntersections(i[0], this._segStrings), this.checkEndPtVertexIntersections(i[i.length - 1], this._segStrings);
          }
          else if (arguments.length === 2) {
            for (var a = arguments[0], c = arguments[1].iterator(); c.hasNext(); ) for (var g = c.next().getCoordinates(), m = 1; m < g.length - 1; m++) if (g[m].equals(a)) throw new ge("found endpt/interior pt intersection at index " + m + " :pt " + a);
          }
        } }, { key: "checkInteriorIntersections", value: function() {
          if (arguments.length === 0) for (var n = this._segStrings.iterator(); n.hasNext(); ) for (var i = n.next(), a = this._segStrings.iterator(); a.hasNext(); ) {
            var c = a.next();
            this.checkInteriorIntersections(i, c);
          }
          else if (arguments.length === 2) for (var g = arguments[0], m = arguments[1], y = g.getCoordinates(), w = m.getCoordinates(), A = 0; A < y.length - 1; A++) for (var z = 0; z < w.length - 1; z++) this.checkInteriorIntersections(g, A, m, z);
          else if (arguments.length === 4) {
            var V = arguments[0], ee = arguments[1], ue = arguments[2], fe = arguments[3];
            if (V === ue && ee === fe) return null;
            var me = V.getCoordinates()[ee], Ae = V.getCoordinates()[ee + 1], be = ue.getCoordinates()[fe], Ge = ue.getCoordinates()[fe + 1];
            if (this._li.computeIntersection(me, Ae, be, Ge), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, me, Ae) || this.hasInteriorIntersection(this._li, be, Ge))) throw new ge("found non-noded intersection at " + me + "-" + Ae + " and " + be + "-" + Ge);
          }
        } }, { key: "checkValid", value: function() {
          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
        } }, { key: "checkCollapses", value: function() {
          if (arguments.length === 0) for (var n = this._segStrings.iterator(); n.hasNext(); ) {
            var i = n.next();
            this.checkCollapses(i);
          }
          else if (arguments.length === 1) for (var a = arguments[0].getCoordinates(), c = 0; c < a.length - 2; c++) this.checkCollapse(a[c], a[c + 1], a[c + 2]);
        } }, { key: "hasInteriorIntersection", value: function(n, i, a) {
          for (var c = 0; c < n.getIntersectionNum(); c++) {
            var g = n.getIntersection(c);
            if (!g.equals(i) && !g.equals(a)) return true;
          }
          return false;
        } }, { key: "checkCollapse", value: function(n, i, a) {
          if (n.equals(a)) throw new ge("found non-noded collapse at " + o.fact.createLineString([n, i, a]));
        } }], [{ key: "constructor_", value: function() {
          this._li = new Yr(), this._segStrings = null;
          var n = arguments[0];
          this._segStrings = n;
        } }]);
      })();
      Nc.fact = new _i4();
      var Yo = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "intersectsScaled", value: function(n, i) {
          var a = Math.min(n.x, i.x), c = Math.max(n.x, i.x), g = Math.min(n.y, i.y), m = Math.max(n.y, i.y), y = this._maxx < a || this._minx > c || this._maxy < g || this._miny > m;
          if (y) return false;
          var w = this.intersectsToleranceSquare(n, i);
          return ae.isTrue(!(y && w), "Found bad envelope test"), w;
        } }, { key: "initCorners", value: function(n) {
          var i = 0.5;
          this._minx = n.x - i, this._maxx = n.x + i, this._miny = n.y - i, this._maxy = n.y + i, this._corner[0] = new H(this._maxx, this._maxy), this._corner[1] = new H(this._minx, this._maxy), this._corner[2] = new H(this._minx, this._miny), this._corner[3] = new H(this._maxx, this._miny);
        } }, { key: "intersects", value: function(n, i) {
          return this._scaleFactor === 1 ? this.intersectsScaled(n, i) : (this.copyScaled(n, this._p0Scaled), this.copyScaled(i, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
        } }, { key: "scale", value: function(n) {
          return Math.round(n * this._scaleFactor);
        } }, { key: "getCoordinate", value: function() {
          return this._originalPt;
        } }, { key: "copyScaled", value: function(n, i) {
          i.x = this.scale(n.x), i.y = this.scale(n.y);
        } }, { key: "getSafeEnvelope", value: function() {
          if (this._safeEnv === null) {
            var n = o.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new Ie(this._originalPt.x - n, this._originalPt.x + n, this._originalPt.y - n, this._originalPt.y + n);
          }
          return this._safeEnv;
        } }, { key: "intersectsPixelClosure", value: function(n, i) {
          return this._li.computeIntersection(n, i, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(n, i, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(n, i, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(n, i, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
        } }, { key: "intersectsToleranceSquare", value: function(n, i) {
          var a = false, c = false;
          return this._li.computeIntersection(n, i, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(n, i, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (a = true), this._li.computeIntersection(n, i, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (c = true), this._li.computeIntersection(n, i, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!a || !c) || !!n.equals(this._pt) || !!i.equals(this._pt))));
        } }, { key: "addSnappedNode", value: function(n, i) {
          var a = n.getCoordinate(i), c = n.getCoordinate(i + 1);
          return !!this.intersects(a, c) && (n.addIntersection(this.getCoordinate(), i), true);
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
          var n = arguments[0], i = arguments[1], a = arguments[2];
          if (this._originalPt = n, this._pt = n, this._scaleFactor = i, this._li = a, i <= 0) throw new $("Scale factor must be non-zero");
          i !== 1 && (this._pt = new H(this.scale(n.x), this.scale(n.y)), this._p0Scaled = new H(), this._p1Scaled = new H()), this.initCorners(this._pt);
        } }]);
      })();
      Yo.SAFE_ENV_EXPANSION_FACTOR = 0.75;
      var km = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "select", value: function() {
          if (arguments.length !== 1) {
            if (arguments.length === 2) {
              var o = arguments[1];
              arguments[0].getLineSegment(o, this.selectedSegment), this.select(this.selectedSegment);
            }
          }
        } }], [{ key: "constructor_", value: function() {
          this.selectedSegment = new Bt();
        } }]);
      })(), Pc = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "snap", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return this.snap(o, null, -1);
          }
          if (arguments.length === 3) {
            var n = arguments[0], i = arguments[1], a = arguments[2], c = n.getSafeEnvelope(), g = new Oc(n, i, a);
            return this._index.query(c, new ((function() {
              return h((function m() {
                u(this, m);
              }), [{ key: "interfaces_", get: function() {
                return [yc];
              } }, { key: "visitItem", value: function(m) {
                m.select(c, g);
              } }]);
            })())()), g.isNodeAdded();
          }
        } }], [{ key: "constructor_", value: function() {
          this._index = null;
          var o = arguments[0];
          this._index = o;
        } }]);
      })(), Oc = (function(o) {
        function n() {
          var i;
          return u(this, n), i = s(this, n), n.constructor_.apply(i, arguments), i;
        }
        return _(n, o), h(n, [{ key: "isNodeAdded", value: function() {
          return this._isNodeAdded;
        } }, { key: "select", value: function() {
          if (!(arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof Ec)) return I(n, "select", this, 1).apply(this, arguments);
          var i = arguments[1], a = arguments[0].getContext();
          if (this._parentEdge === a && (i === this._hotPixelVertexIndex || i + 1 === this._hotPixelVertexIndex)) return null;
          this._isNodeAdded |= this._hotPixel.addSnappedNode(a, i);
        } }], [{ key: "constructor_", value: function() {
          this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = false;
          var i = arguments[0], a = arguments[1], c = arguments[2];
          this._hotPixel = i, this._parentEdge = a, this._hotPixelVertexIndex = c;
        } }]);
      })(km);
      Pc.HotPixelSnapAction = Oc;
      var Sm = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "processIntersections", value: function(o, n, i, a) {
          if (o === i && n === a) return null;
          var c = o.getCoordinates()[n], g = o.getCoordinates()[n + 1], m = i.getCoordinates()[a], y = i.getCoordinates()[a + 1];
          if (this._li.computeIntersection(c, g, m, y), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var w = 0; w < this._li.getIntersectionNum(); w++) this._interiorIntersections.add(this._li.getIntersection(w));
            o.addIntersections(this._li, n, 0), i.addIntersections(this._li, a, 1);
          }
        } }, { key: "isDone", value: function() {
          return false;
        } }, { key: "getInteriorIntersections", value: function() {
          return this._interiorIntersections;
        } }, { key: "interfaces_", get: function() {
          return [Ac];
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._interiorIntersections = null;
          var o = arguments[0];
          this._li = o, this._interiorIntersections = new pe();
        } }]);
      })(), Mm = (function() {
        return h((function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }), [{ key: "checkCorrectness", value: function(o) {
          var n = Hr.getNodedSubstrings(o), i = new Nc(n);
          try {
            i.checkValid();
          } catch (a) {
            if (!(a instanceof X)) throw a;
            a.printStackTrace();
          }
        } }, { key: "getNodedSubstrings", value: function() {
          return Hr.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "snapRound", value: function(o, n) {
          var i = this.findInteriorIntersections(o, n);
          this.computeIntersectionSnaps(i), this.computeVertexSnaps(o);
        } }, { key: "findInteriorIntersections", value: function(o, n) {
          var i = new Sm(n);
          return this._noder.setSegmentIntersector(i), this._noder.computeNodes(o), i.getInteriorIntersections();
        } }, { key: "computeVertexSnaps", value: function() {
          if (Ee(arguments[0], Ce)) for (var o = arguments[0].iterator(); o.hasNext(); ) {
            var n = o.next();
            this.computeVertexSnaps(n);
          }
          else if (arguments[0] instanceof Hr) for (var i = arguments[0], a = i.getCoordinates(), c = 0; c < a.length; c++) {
            var g = new Yo(a[c], this._scaleFactor, this._li);
            this._pointSnapper.snap(g, i, c) && i.addIntersection(a[c], c);
          }
        } }, { key: "computeNodes", value: function(o) {
          this._nodedSegStrings = o, this._noder = new zo(), this._pointSnapper = new Pc(this._noder.getIndex()), this.snapRound(o, this._li);
        } }, { key: "computeIntersectionSnaps", value: function(o) {
          for (var n = o.iterator(); n.hasNext(); ) {
            var i = n.next(), a = new Yo(i, this._scaleFactor, this._li);
            this._pointSnapper.snap(a);
          }
        } }, { key: "interfaces_", get: function() {
          return [Uo];
        } }], [{ key: "constructor_", value: function() {
          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
          var o = arguments[0];
          this._pm = o, this._li = new Yr(), this._li.setPrecisionModel(o), this._scaleFactor = o.getScale();
        } }]);
      })(), Si = (function() {
        function o() {
          u(this, o), o.constructor_.apply(this, arguments);
        }
        return h(o, [{ key: "bufferFixedPrecision", value: function(n) {
          var i = new wm(new Mm(new Re(1)), n.getScale()), a = new Cc(this._bufParams);
          a.setWorkingPrecisionModel(n), a.setNoder(i), this._resultGeometry = a.buffer(this._argGeom, this._distance);
        } }, { key: "bufferReducedPrecision", value: function() {
          if (arguments.length === 0) {
            for (var n = o.MAX_PRECISION_DIGITS; n >= 0; n--) {
              try {
                this.bufferReducedPrecision(n);
              } catch (g) {
                if (!(g instanceof Nt)) throw g;
                this._saveException = g;
              }
              if (this._resultGeometry !== null) return null;
            }
            throw this._saveException;
          }
          if (arguments.length === 1) {
            var i = arguments[0], a = o.precisionScaleFactor(this._argGeom, this._distance, i), c = new Re(a);
            this.bufferFixedPrecision(c);
          }
        } }, { key: "computeGeometry", value: function() {
          if (this.bufferOriginalPrecision(), this._resultGeometry !== null) return null;
          var n = this._argGeom.getFactory().getPrecisionModel();
          n.getType() === Re.FIXED ? this.bufferFixedPrecision(n) : this.bufferReducedPrecision();
        } }, { key: "setQuadrantSegments", value: function(n) {
          this._bufParams.setQuadrantSegments(n);
        } }, { key: "bufferOriginalPrecision", value: function() {
          try {
            var n = new Cc(this._bufParams);
            this._resultGeometry = n.buffer(this._argGeom, this._distance);
          } catch (i) {
            if (!(i instanceof ge)) throw i;
            this._saveException = i;
          }
        } }, { key: "getResultGeometry", value: function(n) {
          return this._distance = n, this.computeGeometry(), this._resultGeometry;
        } }, { key: "setEndCapStyle", value: function(n) {
          this._bufParams.setEndCapStyle(n);
        } }], [{ key: "constructor_", value: function() {
          if (this._argGeom = null, this._distance = null, this._bufParams = new J(), this._resultGeometry = null, this._saveException = null, arguments.length === 1) {
            var n = arguments[0];
            this._argGeom = n;
          } else if (arguments.length === 2) {
            var i = arguments[0], a = arguments[1];
            this._argGeom = i, this._bufParams = a;
          }
        } }, { key: "bufferOp", value: function() {
          if (arguments.length === 2) {
            var n = arguments[1];
            return new o(arguments[0]).getResultGeometry(n);
          }
          if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof ce && typeof arguments[1] == "number") {
              var i = arguments[1], a = arguments[2], c = new o(arguments[0]);
              return c.setQuadrantSegments(a), c.getResultGeometry(i);
            }
            if (arguments[2] instanceof J && arguments[0] instanceof ce && typeof arguments[1] == "number") {
              var g = arguments[1];
              return new o(arguments[0], arguments[2]).getResultGeometry(g);
            }
          } else if (arguments.length === 4) {
            var m = arguments[1], y = arguments[2], w = arguments[3], A = new o(arguments[0]);
            return A.setQuadrantSegments(y), A.setEndCapStyle(w), A.getResultGeometry(m);
          }
        } }, { key: "precisionScaleFactor", value: function(n, i, a) {
          var c = n.getEnvelopeInternal(), g = Ln.max(Math.abs(c.getMaxX()), Math.abs(c.getMaxY()), Math.abs(c.getMinX()), Math.abs(c.getMinY())) + 2 * (i > 0 ? i : 0), m = a - Math.trunc(Math.log(g) / Math.log(10) + 1);
          return Math.pow(10, m);
        } }]);
      })();
      Si.CAP_ROUND = J.CAP_ROUND, Si.CAP_BUTT = J.CAP_FLAT, Si.CAP_FLAT = J.CAP_FLAT, Si.CAP_SQUARE = J.CAP_SQUARE, Si.MAX_PRECISION_DIGITS = 12;
      var Im = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Rc = (function() {
        return h((function o(n) {
          u(this, o), this.geometryFactory = n || new _i4();
        }), [{ key: "read", value: function(o) {
          var n, i = (n = typeof o == "string" ? JSON.parse(o) : o).type;
          if (!jt[i]) throw new Error("Unknown GeoJSON type: " + n.type);
          return Im.indexOf(i) !== -1 ? jt[i].call(this, n.coordinates) : i === "GeometryCollection" ? jt[i].call(this, n.geometries) : jt[i].call(this, n);
        } }, { key: "write", value: function(o) {
          var n = o.getGeometryType();
          if (!Dn[n]) throw new Error("Geometry is not supported");
          return Dn[n].call(this, o);
        } }]);
      })(), jt = { Feature: function(o) {
        var n = {};
        for (var i in o) n[i] = o[i];
        if (o.geometry) {
          var a = o.geometry.type;
          if (!jt[a]) throw new Error("Unknown GeoJSON type: " + o.type);
          n.geometry = this.read(o.geometry);
        }
        return o.bbox && (n.bbox = jt.bbox.call(this, o.bbox)), n;
      }, FeatureCollection: function(o) {
        var n = {};
        if (o.features) {
          n.features = [];
          for (var i = 0; i < o.features.length; ++i) n.features.push(this.read(o.features[i]));
        }
        return o.bbox && (n.bbox = this.parse.bbox.call(this, o.bbox)), n;
      }, coordinates: function(o) {
        for (var n = [], i = 0; i < o.length; ++i) {
          var a = o[i];
          n.push(l(H, D(a)));
        }
        return n;
      }, bbox: function(o) {
        return this.geometryFactory.createLinearRing([new H(o[0], o[1]), new H(o[2], o[1]), new H(o[2], o[3]), new H(o[0], o[3]), new H(o[0], o[1])]);
      }, Point: function(o) {
        var n = l(H, D(o));
        return this.geometryFactory.createPoint(n);
      }, MultiPoint: function(o) {
        for (var n = [], i = 0; i < o.length; ++i) n.push(jt.Point.call(this, o[i]));
        return this.geometryFactory.createMultiPoint(n);
      }, LineString: function(o) {
        var n = jt.coordinates.call(this, o);
        return this.geometryFactory.createLineString(n);
      }, MultiLineString: function(o) {
        for (var n = [], i = 0; i < o.length; ++i) n.push(jt.LineString.call(this, o[i]));
        return this.geometryFactory.createMultiLineString(n);
      }, Polygon: function(o) {
        for (var n = jt.coordinates.call(this, o[0]), i = this.geometryFactory.createLinearRing(n), a = [], c = 1; c < o.length; ++c) {
          var g = o[c], m = jt.coordinates.call(this, g), y = this.geometryFactory.createLinearRing(m);
          a.push(y);
        }
        return this.geometryFactory.createPolygon(i, a);
      }, MultiPolygon: function(o) {
        for (var n = [], i = 0; i < o.length; ++i) {
          var a = o[i];
          n.push(jt.Polygon.call(this, a));
        }
        return this.geometryFactory.createMultiPolygon(n);
      }, GeometryCollection: function(o) {
        for (var n = [], i = 0; i < o.length; ++i) {
          var a = o[i];
          n.push(this.read(a));
        }
        return this.geometryFactory.createGeometryCollection(n);
      } }, Dn = { coordinate: function(o) {
        var n = [o.x, o.y];
        return o.z && n.push(o.z), o.m && n.push(o.m), n;
      }, Point: function(o) {
        return { type: "Point", coordinates: Dn.coordinate.call(this, o.getCoordinate()) };
      }, MultiPoint: function(o) {
        for (var n = [], i = 0; i < o._geometries.length; ++i) {
          var a = o._geometries[i], c = Dn.Point.call(this, a);
          n.push(c.coordinates);
        }
        return { type: "MultiPoint", coordinates: n };
      }, LineString: function(o) {
        for (var n = [], i = o.getCoordinates(), a = 0; a < i.length; ++a) {
          var c = i[a];
          n.push(Dn.coordinate.call(this, c));
        }
        return { type: "LineString", coordinates: n };
      }, MultiLineString: function(o) {
        for (var n = [], i = 0; i < o._geometries.length; ++i) {
          var a = o._geometries[i], c = Dn.LineString.call(this, a);
          n.push(c.coordinates);
        }
        return { type: "MultiLineString", coordinates: n };
      }, Polygon: function(o) {
        var n = [], i = Dn.LineString.call(this, o._shell);
        n.push(i.coordinates);
        for (var a = 0; a < o._holes.length; ++a) {
          var c = o._holes[a], g = Dn.LineString.call(this, c);
          n.push(g.coordinates);
        }
        return { type: "Polygon", coordinates: n };
      }, MultiPolygon: function(o) {
        for (var n = [], i = 0; i < o._geometries.length; ++i) {
          var a = o._geometries[i], c = Dn.Polygon.call(this, a);
          n.push(c.coordinates);
        }
        return { type: "MultiPolygon", coordinates: n };
      }, GeometryCollection: function(o) {
        for (var n = [], i = 0; i < o._geometries.length; ++i) {
          var a = o._geometries[i], c = a.getGeometryType();
          n.push(Dn[c].call(this, a));
        }
        return { type: "GeometryCollection", geometries: n };
      } };
      return { BufferOp: Si, GeoJSONReader: (function() {
        return h((function o(n) {
          u(this, o), this.parser = new Rc(n || new _i4());
        }), [{ key: "read", value: function(o) {
          return this.parser.read(o);
        } }]);
      })(), GeoJSONWriter: (function() {
        return h((function o() {
          u(this, o), this.parser = new Rc(this.geometryFactory);
        }), [{ key: "write", value: function(o) {
          return this.parser.write(o);
        } }]);
      })() };
    }));
  })(Ha)), Ha.exports;
}
var Y2 = q2();
var H2 = Lg(Y2);
function Fr() {
  return new ao();
}
function ao() {
  this.reset();
}
ao.prototype = {
  constructor: ao,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(t) {
    ff(ba, t, this.t), ff(this, ba.s, this.s), this.s ? this.t += ba.t : this.s = ba.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var ba = new ao();
function ff(t, e, r) {
  var s = t.s = e + r, u = s - e, l = s - u;
  t.t = e - l + (r - u);
}
var He = 1e-6;
var Ne = Math.PI;
var Yn = Ne / 2;
var gf = Ne / 4;
var Wn = Ne * 2;
var Sr = 180 / Ne;
var rn = Ne / 180;
var ct = Math.abs;
var J2 = Math.atan;
var Ji = Math.atan2;
var je = Math.cos;
var Ze = Math.sin;
var ns = Math.sqrt;
function ip(t) {
  return t > 1 ? 0 : t < -1 ? Ne : Math.acos(t);
}
function si(t) {
  return t > 1 ? Yn : t < -1 ? -Yn : Math.asin(t);
}
function As() {
}
function oo(t, e) {
  t && pf.hasOwnProperty(t.type) && pf[t.type](t, e);
}
var df = {
  Feature: function(t, e) {
    oo(t.geometry, e);
  },
  FeatureCollection: function(t, e) {
    for (var r = t.features, s = -1, u = r.length; ++s < u; ) oo(r[s].geometry, e);
  }
};
var pf = {
  Sphere: function(t, e) {
    e.sphere();
  },
  Point: function(t, e) {
    t = t.coordinates, e.point(t[0], t[1], t[2]);
  },
  MultiPoint: function(t, e) {
    for (var r = t.coordinates, s = -1, u = r.length; ++s < u; ) t = r[s], e.point(t[0], t[1], t[2]);
  },
  LineString: function(t, e) {
    Qu(t.coordinates, e, 0);
  },
  MultiLineString: function(t, e) {
    for (var r = t.coordinates, s = -1, u = r.length; ++s < u; ) Qu(r[s], e, 0);
  },
  Polygon: function(t, e) {
    mf(t.coordinates, e);
  },
  MultiPolygon: function(t, e) {
    for (var r = t.coordinates, s = -1, u = r.length; ++s < u; ) mf(r[s], e);
  },
  GeometryCollection: function(t, e) {
    for (var r = t.geometries, s = -1, u = r.length; ++s < u; ) oo(r[s], e);
  }
};
function Qu(t, e, r) {
  var s = -1, u = t.length - r, l;
  for (e.lineStart(); ++s < u; ) l = t[s], e.point(l[0], l[1], l[2]);
  e.lineEnd();
}
function mf(t, e) {
  var r = -1, s = t.length;
  for (e.polygonStart(); ++r < s; ) Qu(t[r], e, 1);
  e.polygonEnd();
}
function $2(t, e) {
  t && df.hasOwnProperty(t.type) ? df[t.type](t, e) : oo(t, e);
}
Fr();
Fr();
function el(t) {
  return [Ji(t[1], t[0]), si(t[2])];
}
function $i(t) {
  var e = t[0], r = t[1], s = je(r);
  return [s * je(e), s * Ze(e), Ze(r)];
}
function Aa(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
}
function uo(t, e) {
  return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]];
}
function pu(t, e) {
  t[0] += e[0], t[1] += e[1], t[2] += e[2];
}
function La(t, e) {
  return [t[0] * e, t[1] * e, t[2] * e];
}
function tl(t) {
  var e = ns(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
  t[0] /= e, t[1] /= e, t[2] /= e;
}
Fr();
function sp(t, e) {
  function r(s, u) {
    return s = t(s, u), e(s[0], s[1]);
  }
  return t.invert && e.invert && (r.invert = function(s, u) {
    return s = e.invert(s, u), s && t.invert(s[0], s[1]);
  }), r;
}
function nl(t, e) {
  return [t > Ne ? t - Wn : t < -Ne ? t + Wn : t, e];
}
nl.invert = nl;
function V2(t, e, r) {
  return (t %= Wn) ? e || r ? sp(yf(t), _f2(e, r)) : yf(t) : e || r ? _f2(e, r) : nl;
}
function vf(t) {
  return function(e, r) {
    return e += t, [e > Ne ? e - Wn : e < -Ne ? e + Wn : e, r];
  };
}
function yf(t) {
  var e = vf(t);
  return e.invert = vf(-t), e;
}
function _f2(t, e) {
  var r = je(t), s = Ze(t), u = je(e), l = Ze(e);
  function f(h, p) {
    var d = je(p), v = je(h) * d, _ = Ze(h) * d, E = Ze(p), S = E * r + v * s;
    return [
      Ji(_ * u - S * l, v * r - E * s),
      si(S * u + _ * l)
    ];
  }
  return f.invert = function(h, p) {
    var d = je(p), v = je(h) * d, _ = Ze(h) * d, E = Ze(p), S = E * u - _ * l;
    return [
      Ji(_ * u + E * l, v * r + S * s),
      si(S * r - v * s)
    ];
  }, f;
}
function X2(t, e, r, s, u, l) {
  if (r) {
    var f = je(e), h = Ze(e), p = s * r;
    u == null ? (u = e + s * Wn, l = e - p / 2) : (u = Ef(f, u), l = Ef(f, l), (s > 0 ? u < l : u > l) && (u += s * Wn));
    for (var d, v = u; s > 0 ? v > l : v < l; v -= p)
      d = el([f, -h * je(v), -h * Ze(v)]), t.point(d[0], d[1]);
  }
}
function Ef(t, e) {
  e = $i(e), e[0] -= t, tl(e);
  var r = ip(-e[1]);
  return ((-e[2] < 0 ? -r : r) + Wn - He) % Wn;
}
function ap() {
  var t = [], e;
  return {
    point: function(r, s) {
      e.push([r, s]);
    },
    lineStart: function() {
      t.push(e = []);
    },
    lineEnd: As,
    rejoin: function() {
      t.length > 1 && t.push(t.pop().concat(t.shift()));
    },
    result: function() {
      var r = t;
      return t = [], e = null, r;
    }
  };
}
function W2(t, e, r, s, u, l) {
  var f = t[0], h = t[1], p = e[0], d = e[1], v = 0, _ = 1, E = p - f, S = d - h, I;
  if (I = r - f, !(!E && I > 0)) {
    if (I /= E, E < 0) {
      if (I < v) return;
      I < _ && (_ = I);
    } else if (E > 0) {
      if (I > _) return;
      I > v && (v = I);
    }
    if (I = u - f, !(!E && I < 0)) {
      if (I /= E, E < 0) {
        if (I > _) return;
        I > v && (v = I);
      } else if (E > 0) {
        if (I < v) return;
        I < _ && (_ = I);
      }
      if (I = s - h, !(!S && I > 0)) {
        if (I /= S, S < 0) {
          if (I < v) return;
          I < _ && (_ = I);
        } else if (S > 0) {
          if (I > _) return;
          I > v && (v = I);
        }
        if (I = l - h, !(!S && I < 0)) {
          if (I /= S, S < 0) {
            if (I > _) return;
            I > v && (v = I);
          } else if (S > 0) {
            if (I < v) return;
            I < _ && (_ = I);
          }
          return v > 0 && (t[0] = f + v * E, t[1] = h + v * S), _ < 1 && (e[0] = f + _ * E, e[1] = h + _ * S), true;
        }
      }
    }
  }
}
function Ja(t, e) {
  return ct(t[0] - e[0]) < He && ct(t[1] - e[1]) < He;
}
function Ta(t, e, r, s) {
  this.x = t, this.z = e, this.o = r, this.e = s, this.v = false, this.n = this.p = null;
}
function op(t, e, r, s, u) {
  var l = [], f = [], h, p;
  if (t.forEach(function(I) {
    if (!((D = I.length - 1) <= 0)) {
      var D, O = I[0], T = I[D], M;
      if (Ja(O, T)) {
        for (u.lineStart(), h = 0; h < D; ++h) u.point((O = I[h])[0], O[1]);
        u.lineEnd();
        return;
      }
      l.push(M = new Ta(O, I, null, true)), f.push(M.o = new Ta(O, null, M, false)), l.push(M = new Ta(T, I, null, false)), f.push(M.o = new Ta(T, null, M, true));
    }
  }), !!l.length) {
    for (f.sort(e), xf(l), xf(f), h = 0, p = f.length; h < p; ++h)
      f[h].e = r = !r;
    for (var d = l[0], v, _; ; ) {
      for (var E = d, S = true; E.v; ) if ((E = E.n) === d) return;
      v = E.z, u.lineStart();
      do {
        if (E.v = E.o.v = true, E.e) {
          if (S)
            for (h = 0, p = v.length; h < p; ++h) u.point((_ = v[h])[0], _[1]);
          else
            s(E.x, E.n.x, 1, u);
          E = E.n;
        } else {
          if (S)
            for (v = E.p.z, h = v.length - 1; h >= 0; --h) u.point((_ = v[h])[0], _[1]);
          else
            s(E.x, E.p.x, -1, u);
          E = E.p;
        }
        E = E.o, v = E.z, S = !S;
      } while (!E.v);
      u.lineEnd();
    }
  }
}
function xf(t) {
  if (e = t.length) {
    for (var e, r = 0, s = t[0], u; ++r < e; )
      s.n = u = t[r], u.p = s, s = u;
    s.n = u = t[0], u.p = s;
  }
}
function up(t, e) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function j2(t) {
  return t.length === 1 && (t = Z2(t)), {
    left: function(e, r, s, u) {
      for (s == null && (s = 0), u == null && (u = e.length); s < u; ) {
        var l = s + u >>> 1;
        t(e[l], r) < 0 ? s = l + 1 : u = l;
      }
      return s;
    },
    right: function(e, r, s, u) {
      for (s == null && (s = 0), u == null && (u = e.length); s < u; ) {
        var l = s + u >>> 1;
        t(e[l], r) > 0 ? u = l : s = l + 1;
      }
      return s;
    }
  };
}
function Z2(t) {
  return function(e, r) {
    return up(t(e), r);
  };
}
j2(up);
function lp(t) {
  for (var e = t.length, r, s = -1, u = 0, l, f; ++s < e; ) u += t[s].length;
  for (l = new Array(u); --e >= 0; )
    for (f = t[e], r = f.length; --r >= 0; )
      l[--u] = f[r];
  return l;
}
var Ls = 1e9;
var Ca = -Ls;
function K2(t, e, r, s) {
  function u(d, v) {
    return t <= d && d <= r && e <= v && v <= s;
  }
  function l(d, v, _, E) {
    var S = 0, I = 0;
    if (d == null || (S = f(d, _)) !== (I = f(v, _)) || p(d, v) < 0 ^ _ > 0)
      do
        E.point(S === 0 || S === 3 ? t : r, S > 1 ? s : e);
      while ((S = (S + _ + 4) % 4) !== I);
    else
      E.point(v[0], v[1]);
  }
  function f(d, v) {
    return ct(d[0] - t) < He ? v > 0 ? 0 : 3 : ct(d[0] - r) < He ? v > 0 ? 2 : 1 : ct(d[1] - e) < He ? v > 0 ? 1 : 0 : v > 0 ? 3 : 2;
  }
  function h(d, v) {
    return p(d.x, v.x);
  }
  function p(d, v) {
    var _ = f(d, 1), E = f(v, 1);
    return _ !== E ? _ - E : _ === 0 ? v[1] - d[1] : _ === 1 ? d[0] - v[0] : _ === 2 ? d[1] - v[1] : v[0] - d[0];
  }
  return function(d) {
    var v = d, _ = ap(), E, S, I, D, O, T, M, J, X, $, Y, j = {
      point: x,
      lineStart: C,
      lineEnd: G,
      polygonStart: b,
      polygonEnd: L
    };
    function x(P, F) {
      u(P, F) && v.point(P, F);
    }
    function k() {
      for (var P = 0, F = 0, q = S.length; F < q; ++F)
        for (var U = S[F], W = 1, Z = U.length, ne = U[0], ge, le, ae = ne[0], oe = ne[1]; W < Z; ++W)
          ge = ae, le = oe, ne = U[W], ae = ne[0], oe = ne[1], le <= s ? oe > s && (ae - ge) * (s - le) > (oe - le) * (t - ge) && ++P : oe <= s && (ae - ge) * (s - le) < (oe - le) * (t - ge) && --P;
      return P;
    }
    function b() {
      v = _, E = [], S = [], Y = true;
    }
    function L() {
      var P = k(), F = Y && P, q = (E = lp(E)).length;
      (F || q) && (d.polygonStart(), F && (d.lineStart(), l(null, null, 1, d), d.lineEnd()), q && op(E, h, P, l, d), d.polygonEnd()), v = d, E = S = I = null;
    }
    function C() {
      j.point = R, S && S.push(I = []), $ = true, X = false, M = J = NaN;
    }
    function G() {
      E && (R(D, O), T && X && _.rejoin(), E.push(_.result())), j.point = x, X && v.lineEnd();
    }
    function R(P, F) {
      var q = u(P, F);
      if (S && I.push([P, F]), $)
        D = P, O = F, T = q, $ = false, q && (v.lineStart(), v.point(P, F));
      else if (q && X) v.point(P, F);
      else {
        var U = [M = Math.max(Ca, Math.min(Ls, M)), J = Math.max(Ca, Math.min(Ls, J))], W = [P = Math.max(Ca, Math.min(Ls, P)), F = Math.max(Ca, Math.min(Ls, F))];
        W2(U, W, t, e, r, s) ? (X || (v.lineStart(), v.point(U[0], U[1])), v.point(W[0], W[1]), q || v.lineEnd(), Y = false) : q && (v.lineStart(), v.point(P, F), Y = false);
      }
      M = P, J = F, X = q;
    }
    return j;
  };
}
var mu = Fr();
function Q2(t, e) {
  var r = e[0], s = e[1], u = [Ze(r), -je(r), 0], l = 0, f = 0;
  mu.reset();
  for (var h = 0, p = t.length; h < p; ++h)
    if (v = (d = t[h]).length)
      for (var d, v, _ = d[v - 1], E = _[0], S = _[1] / 2 + gf, I = Ze(S), D = je(S), O = 0; O < v; ++O, E = M, I = X, D = $, _ = T) {
        var T = d[O], M = T[0], J = T[1] / 2 + gf, X = Ze(J), $ = je(J), Y = M - E, j = Y >= 0 ? 1 : -1, x = j * Y, k = x > Ne, b = I * X;
        if (mu.add(Ji(b * j * Ze(x), D * $ + b * je(x))), l += k ? Y + j * Wn : Y, k ^ E >= r ^ M >= r) {
          var L = uo($i(_), $i(T));
          tl(L);
          var C = uo(u, L);
          tl(C);
          var G = (k ^ Y >= 0 ? -1 : 1) * si(C[2]);
          (s > G || s === G && (L[0] || L[1])) && (f += k ^ Y >= 0 ? 1 : -1);
        }
      }
  return (l < -He || l < He && mu < -He) ^ f & 1;
}
Fr();
function wf(t) {
  return t;
}
Fr();
Fr();
var Vi = 1 / 0;
var lo = Vi;
var js = -Vi;
var co = js;
var kf = {
  point: eS,
  lineStart: As,
  lineEnd: As,
  polygonStart: As,
  polygonEnd: As,
  result: function() {
    var t = [[Vi, lo], [js, co]];
    return js = co = -(lo = Vi = 1 / 0), t;
  }
};
function eS(t, e) {
  t < Vi && (Vi = t), t > js && (js = t), e < lo && (lo = e), e > co && (co = e);
}
Fr();
function cp(t, e, r, s) {
  return function(u, l) {
    var f = e(l), h = u.invert(s[0], s[1]), p = ap(), d = e(p), v = false, _, E, S, I = {
      point: D,
      lineStart: T,
      lineEnd: M,
      polygonStart: function() {
        I.point = J, I.lineStart = X, I.lineEnd = $, E = [], _ = [];
      },
      polygonEnd: function() {
        I.point = D, I.lineStart = T, I.lineEnd = M, E = lp(E);
        var Y = Q2(_, h);
        E.length ? (v || (l.polygonStart(), v = true), op(E, nS, Y, r, l)) : Y && (v || (l.polygonStart(), v = true), l.lineStart(), r(null, null, 1, l), l.lineEnd()), v && (l.polygonEnd(), v = false), E = _ = null;
      },
      sphere: function() {
        l.polygonStart(), l.lineStart(), r(null, null, 1, l), l.lineEnd(), l.polygonEnd();
      }
    };
    function D(Y, j) {
      var x = u(Y, j);
      t(Y = x[0], j = x[1]) && l.point(Y, j);
    }
    function O(Y, j) {
      var x = u(Y, j);
      f.point(x[0], x[1]);
    }
    function T() {
      I.point = O, f.lineStart();
    }
    function M() {
      I.point = D, f.lineEnd();
    }
    function J(Y, j) {
      S.push([Y, j]);
      var x = u(Y, j);
      d.point(x[0], x[1]);
    }
    function X() {
      d.lineStart(), S = [];
    }
    function $() {
      J(S[0][0], S[0][1]), d.lineEnd();
      var Y = d.clean(), j = p.result(), x, k = j.length, b, L, C;
      if (S.pop(), _.push(S), S = null, !!k) {
        if (Y & 1) {
          if (L = j[0], (b = L.length - 1) > 0) {
            for (v || (l.polygonStart(), v = true), l.lineStart(), x = 0; x < b; ++x) l.point((C = L[x])[0], C[1]);
            l.lineEnd();
          }
          return;
        }
        k > 1 && Y & 2 && j.push(j.pop().concat(j.shift())), E.push(j.filter(tS));
      }
    }
    return I;
  };
}
function tS(t) {
  return t.length > 1;
}
function nS(t, e) {
  return ((t = t.x)[0] < 0 ? t[1] - Yn - He : Yn - t[1]) - ((e = e.x)[0] < 0 ? e[1] - Yn - He : Yn - e[1]);
}
var Sf = cp(
  function() {
    return true;
  },
  rS,
  sS,
  [-Ne, -Yn]
);
function rS(t) {
  var e = NaN, r = NaN, s = NaN, u;
  return {
    lineStart: function() {
      t.lineStart(), u = 1;
    },
    point: function(l, f) {
      var h = l > 0 ? Ne : -Ne, p = ct(l - e);
      ct(p - Ne) < He ? (t.point(e, r = (r + f) / 2 > 0 ? Yn : -Yn), t.point(s, r), t.lineEnd(), t.lineStart(), t.point(h, r), t.point(l, r), u = 0) : s !== h && p >= Ne && (ct(e - s) < He && (e -= s * He), ct(l - h) < He && (l -= h * He), r = iS(e, r, l, f), t.point(s, r), t.lineEnd(), t.lineStart(), t.point(h, r), u = 0), t.point(e = l, r = f), s = h;
    },
    lineEnd: function() {
      t.lineEnd(), e = r = NaN;
    },
    clean: function() {
      return 2 - u;
    }
  };
}
function iS(t, e, r, s) {
  var u, l, f = Ze(t - r);
  return ct(f) > He ? J2((Ze(e) * (l = je(s)) * Ze(r) - Ze(s) * (u = je(e)) * Ze(t)) / (u * l * f)) : (e + s) / 2;
}
function sS(t, e, r, s) {
  var u;
  if (t == null)
    u = r * Yn, s.point(-Ne, u), s.point(0, u), s.point(Ne, u), s.point(Ne, 0), s.point(Ne, -u), s.point(0, -u), s.point(-Ne, -u), s.point(-Ne, 0), s.point(-Ne, u);
  else if (ct(t[0] - e[0]) > He) {
    var l = t[0] < e[0] ? Ne : -Ne;
    u = r * l / 2, s.point(-l, u), s.point(0, u), s.point(l, u);
  } else
    s.point(e[0], e[1]);
}
function aS(t, e) {
  var r = je(t), s = r > 0, u = ct(r) > He;
  function l(v, _, E, S) {
    X2(S, t, e, E, v, _);
  }
  function f(v, _) {
    return je(v) * je(_) > r;
  }
  function h(v) {
    var _, E, S, I, D;
    return {
      lineStart: function() {
        I = S = false, D = 1;
      },
      point: function(O, T) {
        var M = [O, T], J, X = f(O, T), $ = s ? X ? 0 : d(O, T) : X ? d(O + (O < 0 ? Ne : -Ne), T) : 0;
        if (!_ && (I = S = X) && v.lineStart(), X !== S && (J = p(_, M), (!J || Ja(_, J) || Ja(M, J)) && (M[0] += He, M[1] += He, X = f(M[0], M[1]))), X !== S)
          D = 0, X ? (v.lineStart(), J = p(M, _), v.point(J[0], J[1])) : (J = p(_, M), v.point(J[0], J[1]), v.lineEnd()), _ = J;
        else if (u && _ && s ^ X) {
          var Y;
          !($ & E) && (Y = p(M, _, true)) && (D = 0, s ? (v.lineStart(), v.point(Y[0][0], Y[0][1]), v.point(Y[1][0], Y[1][1]), v.lineEnd()) : (v.point(Y[1][0], Y[1][1]), v.lineEnd(), v.lineStart(), v.point(Y[0][0], Y[0][1])));
        }
        X && (!_ || !Ja(_, M)) && v.point(M[0], M[1]), _ = M, S = X, E = $;
      },
      lineEnd: function() {
        S && v.lineEnd(), _ = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return D | (I && S) << 1;
      }
    };
  }
  function p(v, _, E) {
    var S = $i(v), I = $i(_), D = [1, 0, 0], O = uo(S, I), T = Aa(O, O), M = O[0], J = T - M * M;
    if (!J) return !E && v;
    var X = r * T / J, $ = -r * M / J, Y = uo(D, O), j = La(D, X), x = La(O, $);
    pu(j, x);
    var k = Y, b = Aa(j, k), L = Aa(k, k), C = b * b - L * (Aa(j, j) - 1);
    if (!(C < 0)) {
      var G = ns(C), R = La(k, (-b - G) / L);
      if (pu(R, j), R = el(R), !E) return R;
      var P = v[0], F = _[0], q = v[1], U = _[1], W;
      F < P && (W = P, P = F, F = W);
      var Z = F - P, ne = ct(Z - Ne) < He, ge = ne || Z < He;
      if (!ne && U < q && (W = q, q = U, U = W), ge ? ne ? q + U > 0 ^ R[1] < (ct(R[0] - P) < He ? q : U) : q <= R[1] && R[1] <= U : Z > Ne ^ (P <= R[0] && R[0] <= F)) {
        var le = La(k, (-b + G) / L);
        return pu(le, j), [R, el(le)];
      }
    }
  }
  function d(v, _) {
    var E = s ? t : Ne - t, S = 0;
    return v < -E ? S |= 1 : v > E && (S |= 2), _ < -E ? S |= 4 : _ > E && (S |= 8), S;
  }
  return cp(f, h, l, s ? [0, -t] : [-Ne, t - Ne]);
}
function hp(t) {
  return function(e) {
    var r = new rl();
    for (var s in t) r[s] = t[s];
    return r.stream = e, r;
  };
}
function rl() {
}
rl.prototype = {
  constructor: rl,
  point: function(t, e) {
    this.stream.point(t, e);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function fp(t, e, r) {
  var s = e[1][0] - e[0][0], u = e[1][1] - e[0][1], l = t.clipExtent && t.clipExtent();
  t.scale(150).translate([0, 0]), l != null && t.clipExtent(null), $2(r, t.stream(kf));
  var f = kf.result(), h = Math.min(s / (f[1][0] - f[0][0]), u / (f[1][1] - f[0][1])), p = +e[0][0] + (s - h * (f[1][0] + f[0][0])) / 2, d = +e[0][1] + (u - h * (f[1][1] + f[0][1])) / 2;
  return l != null && t.clipExtent(l), t.scale(h * 150).translate([p, d]);
}
function oS(t, e, r) {
  return fp(t, [[0, 0], e], r);
}
var Mf = 16;
var uS = je(30 * rn);
function If(t, e) {
  return +e ? cS(t, e) : lS(t);
}
function lS(t) {
  return hp({
    point: function(e, r) {
      e = t(e, r), this.stream.point(e[0], e[1]);
    }
  });
}
function cS(t, e) {
  function r(s, u, l, f, h, p, d, v, _, E, S, I, D, O) {
    var T = d - s, M = v - u, J = T * T + M * M;
    if (J > 4 * e && D--) {
      var X = f + E, $ = h + S, Y = p + I, j = ns(X * X + $ * $ + Y * Y), x = si(Y /= j), k = ct(ct(Y) - 1) < He || ct(l - _) < He ? (l + _) / 2 : Ji($, X), b = t(k, x), L = b[0], C = b[1], G = L - s, R = C - u, P = M * G - T * R;
      (P * P / J > e || ct((T * G + M * R) / J - 0.5) > 0.3 || f * E + h * S + p * I < uS) && (r(s, u, l, f, h, p, L, C, k, X /= j, $ /= j, Y, D, O), O.point(L, C), r(L, C, k, X, $, Y, d, v, _, E, S, I, D, O));
    }
  }
  return function(s) {
    var u, l, f, h, p, d, v, _, E, S, I, D, O = {
      point: T,
      lineStart: M,
      lineEnd: X,
      polygonStart: function() {
        s.polygonStart(), O.lineStart = $;
      },
      polygonEnd: function() {
        s.polygonEnd(), O.lineStart = M;
      }
    };
    function T(x, k) {
      x = t(x, k), s.point(x[0], x[1]);
    }
    function M() {
      _ = NaN, O.point = J, s.lineStart();
    }
    function J(x, k) {
      var b = $i([x, k]), L = t(x, k);
      r(_, E, v, S, I, D, _ = L[0], E = L[1], v = x, S = b[0], I = b[1], D = b[2], Mf, s), s.point(_, E);
    }
    function X() {
      O.point = T, s.lineEnd();
    }
    function $() {
      M(), O.point = Y, O.lineEnd = j;
    }
    function Y(x, k) {
      J(u = x, k), l = _, f = E, h = S, p = I, d = D, O.point = J;
    }
    function j() {
      r(_, E, v, S, I, D, l, f, u, h, p, d, Mf, s), O.lineEnd = X, X();
    }
    return O;
  };
}
var hS = hp({
  point: function(t, e) {
    this.stream.point(t * rn, e * rn);
  }
});
function fS(t) {
  return gS(function() {
    return t;
  })();
}
function gS(t) {
  var e, r = 150, s = 480, u = 250, l, f, h = 0, p = 0, d = 0, v = 0, _ = 0, E, S, I = null, D = Sf, O = null, T, M, J, X = wf, $ = 0.5, Y = If(L, $), j, x;
  function k(R) {
    return R = S(R[0] * rn, R[1] * rn), [R[0] * r + l, f - R[1] * r];
  }
  function b(R) {
    return R = S.invert((R[0] - l) / r, (f - R[1]) / r), R && [R[0] * Sr, R[1] * Sr];
  }
  function L(R, P) {
    return R = e(R, P), [R[0] * r + l, f - R[1] * r];
  }
  k.stream = function(R) {
    return j && x === R ? j : j = hS(D(E, Y(X(x = R))));
  }, k.clipAngle = function(R) {
    return arguments.length ? (D = +R ? aS(I = R * rn, 6 * rn) : (I = null, Sf), G()) : I * Sr;
  }, k.clipExtent = function(R) {
    return arguments.length ? (X = R == null ? (O = T = M = J = null, wf) : K2(O = +R[0][0], T = +R[0][1], M = +R[1][0], J = +R[1][1]), G()) : O == null ? null : [[O, T], [M, J]];
  }, k.scale = function(R) {
    return arguments.length ? (r = +R, C()) : r;
  }, k.translate = function(R) {
    return arguments.length ? (s = +R[0], u = +R[1], C()) : [s, u];
  }, k.center = function(R) {
    return arguments.length ? (h = R[0] % 360 * rn, p = R[1] % 360 * rn, C()) : [h * Sr, p * Sr];
  }, k.rotate = function(R) {
    return arguments.length ? (d = R[0] % 360 * rn, v = R[1] % 360 * rn, _ = R.length > 2 ? R[2] % 360 * rn : 0, C()) : [d * Sr, v * Sr, _ * Sr];
  }, k.precision = function(R) {
    return arguments.length ? (Y = If(L, $ = R * R), G()) : ns($);
  }, k.fitExtent = function(R, P) {
    return fp(k, R, P);
  }, k.fitSize = function(R, P) {
    return oS(k, R, P);
  };
  function C() {
    S = sp(E = V2(d, v, _), e);
    var R = e(h, p);
    return l = s - R[0] * r, f = u + R[1] * r, G();
  }
  function G() {
    return j = x = null, k;
  }
  return function() {
    return e = t.apply(this, arguments), k.invert = e.invert && b, C();
  };
}
function gp(t) {
  return function(e, r) {
    var s = je(e), u = je(r), l = t(s * u);
    return [
      l * u * Ze(e),
      l * Ze(r)
    ];
  };
}
function dp(t) {
  return function(e, r) {
    var s = ns(e * e + r * r), u = t(s), l = Ze(u), f = je(u);
    return [
      Ji(e * l, s * f),
      si(s && r * l / s)
    ];
  };
}
var dS = gp(function(t) {
  return ns(2 / (1 + t));
});
dS.invert = dp(function(t) {
  return 2 * si(t / 2);
});
var pp = gp(function(t) {
  return (t = ip(t)) && t / Ze(t);
});
pp.invert = dp(function(t) {
  return t;
});
function pS() {
  return fS(pp).scale(79.4188).clipAngle(180 - 1e-3);
}
function bf(t, e) {
  return [t, e];
}
bf.invert = bf;
var { BufferOp: mS, GeoJSONReader: vS, GeoJSONWriter: yS } = H2;
function _S(t, e, r) {
  r = r || {};
  var s = r.units || "kilometers", u = r.steps || 8;
  if (!t) throw new Error("geojson is required");
  if (typeof r != "object") throw new Error("options must be an object");
  if (typeof u != "number") throw new Error("steps must be an number");
  if (e === void 0) throw new Error("radius is required");
  if (u <= 0) throw new Error("steps must be greater than 0");
  var l = [];
  switch (t.type) {
    case "GeometryCollection":
      return Rr(t, function(f) {
        var h = $a(f, e, s, u);
        h && l.push(h);
      }), nt(l);
    case "FeatureCollection":
      return Xn(t, function(f) {
        var h = $a(f, e, s, u);
        h && Xn(h, function(p) {
          p && l.push(p);
        });
      }), nt(l);
  }
  return $a(t, e, s, u);
}
function $a(t, e, r, s) {
  var u = t.properties || {}, l = t.type === "Feature" ? t.geometry : t;
  if (l.type === "GeometryCollection") {
    var f = [];
    return Rr(t, function(D) {
      var O = $a(D, e, r, s);
      O && f.push(O);
    }), nt(f);
  }
  var h = ES(l), p = {
    type: l.type,
    coordinates: vp(l.coordinates, h)
  }, d = new vS(), v = d.read(p), _ = Ul(zl(e, r), "meters"), E = mS.bufferOp(v, _, s), S = new yS();
  if (E = S.write(E), !mp(E.coordinates)) {
    var I = {
      type: E.type,
      coordinates: yp(E.coordinates, h)
    };
    return Mn(I, u);
  }
}
function mp(t) {
  return Array.isArray(t[0]) ? mp(t[0]) : isNaN(t[0]);
}
function vp(t, e) {
  return typeof t[0] != "object" ? e(t) : t.map(function(r) {
    return vp(r, e);
  });
}
function yp(t, e) {
  return typeof t[0] != "object" ? e.invert(t) : t.map(function(r) {
    return yp(r, e);
  });
}
function ES(t) {
  var e = U2(t).geometry.coordinates, r = [-e[0], -e[1]];
  return pS().rotate(r).scale(ot);
}
var xS = _S;
var _p = class {
  constructor(e = [], r = wS) {
    if (this.data = e, this.length = this.data.length, this.compare = r, this.length > 0)
      for (let s = (this.length >> 1) - 1; s >= 0; s--) this._down(s);
  }
  push(e) {
    this.data.push(e), this.length++, this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return;
    const e = this.data[0], r = this.data.pop();
    return this.length--, this.length > 0 && (this.data[0] = r, this._down(0)), e;
  }
  peek() {
    return this.data[0];
  }
  _up(e) {
    const { data: r, compare: s } = this, u = r[e];
    for (; e > 0; ) {
      const l = e - 1 >> 1, f = r[l];
      if (s(u, f) >= 0) break;
      r[e] = f, e = l;
    }
    r[e] = u;
  }
  _down(e) {
    const { data: r, compare: s } = this, u = this.length >> 1, l = r[e];
    for (; e < u; ) {
      let f = (e << 1) + 1, h = r[f];
      const p = f + 1;
      if (p < this.length && s(r[p], h) < 0 && (f = p, h = r[p]), s(h, l) >= 0) break;
      r[e] = h, e = f;
    }
    r[e] = l;
  }
};
function wS(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function Ep(t, e) {
  return t.p.x > e.p.x ? 1 : t.p.x < e.p.x ? -1 : t.p.y !== e.p.y ? t.p.y > e.p.y ? 1 : -1 : 1;
}
function kS(t, e) {
  return t.rightSweepEvent.p.x > e.rightSweepEvent.p.x ? 1 : t.rightSweepEvent.p.x < e.rightSweepEvent.p.x ? -1 : t.rightSweepEvent.p.y !== e.rightSweepEvent.p.y ? t.rightSweepEvent.p.y < e.rightSweepEvent.p.y ? 1 : -1 : 1;
}
var Af = class {
  constructor(e, r, s, u) {
    this.p = {
      x: e[0],
      y: e[1]
    }, this.featureId = r, this.ringId = s, this.eventId = u, this.otherEvent = null, this.isLeftEndpoint = null;
  }
  isSamePoint(e) {
    return this.p.x === e.p.x && this.p.y === e.p.y;
  }
};
function SS(t, e) {
  if (t.type === "FeatureCollection") {
    const r = t.features;
    for (let s = 0; s < r.length; s++)
      Lf(r[s], e);
  } else
    Lf(t, e);
}
var Na = 0;
var Pa = 0;
var Oa = 0;
function Lf(t, e) {
  const r = t.type === "Feature" ? t.geometry : t;
  let s = r.coordinates;
  (r.type === "Polygon" || r.type === "MultiLineString") && (s = [s]), r.type === "LineString" && (s = [[s]]);
  for (let u = 0; u < s.length; u++)
    for (let l = 0; l < s[u].length; l++) {
      let f = s[u][l][0], h = null;
      Pa = Pa + 1;
      for (let p = 0; p < s[u][l].length - 1; p++) {
        h = s[u][l][p + 1];
        const d = new Af(f, Na, Pa, Oa), v = new Af(h, Na, Pa, Oa + 1);
        d.otherEvent = v, v.otherEvent = d, Ep(d, v) > 0 ? (v.isLeftEndpoint = true, d.isLeftEndpoint = false) : (d.isLeftEndpoint = true, v.isLeftEndpoint = false), e.push(d), e.push(v), f = h, Oa = Oa + 1;
      }
    }
  Na = Na + 1;
}
var MS = class {
  constructor(e) {
    this.leftSweepEvent = e, this.rightSweepEvent = e.otherEvent;
  }
};
function IS(t, e) {
  if (t === null || e === null || t.leftSweepEvent.ringId === e.leftSweepEvent.ringId && (t.rightSweepEvent.isSamePoint(e.leftSweepEvent) || t.rightSweepEvent.isSamePoint(e.leftSweepEvent) || t.rightSweepEvent.isSamePoint(e.rightSweepEvent) || t.leftSweepEvent.isSamePoint(e.leftSweepEvent) || t.leftSweepEvent.isSamePoint(e.rightSweepEvent))) return false;
  const r = t.leftSweepEvent.p.x, s = t.leftSweepEvent.p.y, u = t.rightSweepEvent.p.x, l = t.rightSweepEvent.p.y, f = e.leftSweepEvent.p.x, h = e.leftSweepEvent.p.y, p = e.rightSweepEvent.p.x, d = e.rightSweepEvent.p.y, v = (d - h) * (u - r) - (p - f) * (l - s), _ = (p - f) * (s - h) - (d - h) * (r - f), E = (u - r) * (s - h) - (l - s) * (r - f);
  if (v === 0)
    return false;
  const S = _ / v, I = E / v;
  if (S >= 0 && S <= 1 && I >= 0 && I <= 1) {
    const D = r + S * (u - r), O = s + S * (l - s);
    return [D, O];
  }
  return false;
}
function bS(t, e) {
  e = e || false;
  const r = [], s = new _p([], kS);
  for (; t.length; ) {
    const u = t.pop();
    if (u.isLeftEndpoint) {
      const l = new MS(u);
      for (let f = 0; f < s.data.length; f++) {
        const h = s.data[f];
        if (e && h.leftSweepEvent.featureId === u.featureId)
          continue;
        const p = IS(l, h);
        p !== false && r.push(p);
      }
      s.push(l);
    } else u.isLeftEndpoint === false && s.pop();
  }
  return r;
}
function AS(t, e) {
  const r = new _p([], Ep);
  return SS(t, r), bS(r, e);
}
var LS = AS;
function ua(t, e, r = {}) {
  const { removeDuplicates: s = true, ignoreSelfIntersections: u = true } = r;
  let l = [];
  t.type === "FeatureCollection" ? l = l.concat(t.features) : t.type === "Feature" ? l.push(t) : (t.type === "LineString" || t.type === "Polygon" || t.type === "MultiLineString" || t.type === "MultiPolygon") && l.push(Mn(t)), e.type === "FeatureCollection" ? l = l.concat(e.features) : e.type === "Feature" ? l.push(e) : (e.type === "LineString" || e.type === "Polygon" || e.type === "MultiLineString" || e.type === "MultiPolygon") && l.push(Mn(e));
  const f = LS(
    nt(l),
    u
  );
  let h = [];
  if (s) {
    const p = {};
    f.forEach((d) => {
      const v = d.join(",");
      p[v] || (p[v] = true, h.push(d));
    });
  } else
    h = f;
  return nt(h.map((p) => En(p)));
}
var TS = ua;
function il(t) {
  const e = Ht(t);
  let r = 0, s = 1, u, l;
  for (; s < e.length; )
    u = l || e[0], l = e[s], r += (l[0] - u[0]) * (l[1] + u[1]), s++;
  return r > 0;
}
function CS(t, e = {}) {
  var r, s;
  if (e = e || {}, !Lo(e)) throw new Error("options is invalid");
  const u = (r = e.mutate) != null ? r : false, l = (s = e.reverse) != null ? s : false;
  if (!t) throw new Error("<geojson> is required");
  if (typeof l != "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof u != "boolean")
    throw new Error("<mutate> must be a boolean");
  !u && t.type !== "Point" && t.type !== "MultiPoint" && (t = To(t));
  const f = [];
  switch (t.type) {
    case "GeometryCollection":
      return Rr(t, function(h) {
        Va(h, l);
      }), t;
    case "FeatureCollection":
      return Xn(t, function(h) {
        const p = Va(h, l);
        Xn(p, function(d) {
          f.push(d);
        });
      }), nt(f);
  }
  return Va(t, l);
}
function Va(t, e) {
  switch (t.type === "Feature" ? t.geometry.type : t.type) {
    case "GeometryCollection":
      return Rr(t, function(s) {
        Va(s, e);
      }), t;
    case "LineString":
      return Tf(Ht(t), e), t;
    case "Polygon":
      return Cf(Ht(t), e), t;
    case "MultiLineString":
      return Ht(t).forEach(function(s) {
        Tf(s, e);
      }), t;
    case "MultiPolygon":
      return Ht(t).forEach(function(s) {
        Cf(s, e);
      }), t;
    case "Point":
    case "MultiPoint":
      return t;
  }
}
function Tf(t, e) {
  il(t) === e && t.reverse();
}
function Cf(t, e) {
  il(t[0]) !== e && t[0].reverse();
  for (let r = 1; r < t.length; r++)
    il(t[r]) === e && t[r].reverse();
}
var NS = CS;
var PS = ["Point", "MultiPoint"];
var OS = [
  "LineString",
  "MultiLineString",
  "Polygon",
  "MultiPolygon"
];
var xp = (t) => PS.includes(t.geometry.type);
var sl = (t) => OS.includes(t.geometry.type);
var RS = (t, e) => (aa(t, (r) => {
  const s = r.coordinate;
  s[0] += e.lng, s[1] += e.lat;
}), t);
var DS = (t, e) => {
  const s = t.getBounds(), u = Vd(s[0], s[1], { units: "meters" });
  return xS(e, u * 1e-4, { units: "meters" }) || null;
};
var wp = (t, e) => {
  const r = $t(t.getGeoJson());
  return RS(r, e), r;
};
var EI = (t, e) => {
  const r = wp(t, e), s = t.getShapeProperty("center");
  s && (t.setShapeProperty("center", s[0] + e.lng), t.setShapeProperty("center", s[1] + e.lat)), t.updateGeoJsonGeometry(r.geometry);
};
var FS = (t, e) => {
  try {
    aa(t, (r) => {
      if (!ii(r.coordinate, e))
        throw new Error("stop");
    });
  } catch {
    return false;
  }
  return true;
};
var Ra = (t, e) => {
  const r = FS(t, e);
  return xp(t) ? r : r && sl(t) ? !TS(t, e, { ignoreSelfIntersections: true }).features.length : false;
};
var tc = (t) => {
  const e = t.getGeoJson();
  return typeof e != "object" ? null : Zd(e);
};
var GS = (t) => {
  if (sl(t)) {
    const e = NS(t, { mutate: false });
    if (e.type === "Feature" && sl(e))
      return {
        ...e,
        properties: t.properties || {}
      };
  }
  return xp(t) ? t : null;
};
var BS = (t, e) => {
  var _a6;
  const r = (_a6 = t.properties) == null ? void 0 : _a6[e];
  return typeof r == "string" || typeof r == "number" ? r : null;
};
var nc = class extends ts {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "drag");
    __publicField(this, "previousLngLat", null);
    __publicField(this, "pointBasedShapes", ["marker", "circle_marker", "text_marker"]);
    __publicField(this, "throttledMethods", ci(
      {
        onMouseMove: this.onMouseMove
      },
      this,
      this.gm.options.settings.throttlingDelay
    ));
    __publicField(this, "eventHandlers", {
      [`${se}:edit`]: this.handleGmEdit.bind(this),
      mousedown: this.onMouseDown.bind(this),
      touchstart: this.onMouseDown.bind(this),
      mousemove: this.throttledMethods.onMouseMove.bind(this),
      touchmove: this.throttledMethods.onMouseMove.bind(this),
      mouseup: this.onMouseUp.bind(this),
      touchend: this.onMouseUp.bind(this)
    });
    __publicField(this, "getUpdatedGeoJsonHandlers", {
      marker: this.moveSource.bind(this),
      ellipse: this.moveEllipse.bind(this),
      circle: this.moveCircle.bind(this),
      circle_marker: this.moveSource.bind(this),
      text_marker: this.moveSource.bind(this),
      line: this.moveSource.bind(this),
      rectangle: this.moveSource.bind(this),
      polygon: this.moveSource.bind(this)
    });
  }
  onMouseDown(e) {
    var _a6;
    if (!Ke(e))
      return { next: true };
    const r = this.getFeatureByMouseEvent({ event: e, sourceNames: [K.main] });
    return r && this.getUpdatedGeoJsonHandlers[r.shape] ? (this.featureData = r, this.featureData.changeSource({ sourceName: K.temporary, atomic: true }), this.gm.mapAdapter.setDragPan(false), (_a6 = this.snappingHelper) == null ? void 0 : _a6.addExcludedFeature(this.featureData), this.fireFeatureEditStartEvent({ feature: this.featureData, forceMode: "drag" }), this.flags.actionInProgress = true, this.isPointBasedShape() && this.alignShapeCenterWithControlMarker(this.featureData, e), { next: false }) : { next: true };
  }
  onMouseUp(e) {
    var _a6;
    return !this.featureData || !Ke(e, { warning: true }) ? { next: true } : ((_a6 = this.snappingHelper) == null ? void 0 : _a6.clearExcludedFeatures(), this.featureData.changeSource({ sourceName: K.main, atomic: true }), this.previousLngLat = null, this.gm.mapAdapter.setDragPan(true), this.fireFeatureEditEndEvent({ feature: this.featureData, forceMode: "drag" }), this.flags.actionInProgress = false, this.featureData = null, { next: true });
  }
  onMouseMove(e) {
    var _a6;
    if (!this.flags.actionInProgress || !Ke(e, { warning: true }))
      return { next: true };
    if (this.featureData) {
      const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e.lngLat.toArray();
      this.moveFeature(this.featureData, r);
    }
    return { next: false };
  }
  isPointBasedShape() {
    return !!this.featureData && this.pointBasedShapes.includes(this.featureData.shape);
  }
  alignShapeCenterWithControlMarker(e, r) {
    var _a6;
    const s = tc(e);
    s && ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.setLngLat(s), this.onMouseMove(r));
  }
  moveFeature(e, r) {
    if (!this.flags.actionInProgress)
      return;
    if (!this.previousLngLat) {
      this.previousLngLat = r;
      return;
    }
    const s = this.getUpdatedGeoJsonHandlers[e.shape];
    if (s) {
      const u = s(e, this.previousLngLat, r);
      if (!u) {
        te.error("BaseDrag.moveFeature: invalid updatedGeoJson", e);
        return;
      }
      this.fireBeforeFeatureUpdate({
        features: [e],
        geoJsonFeatures: [u],
        forceMode: "drag"
      });
      const l = this.updateFeatureGeoJson({
        featureData: e,
        featureGeoJson: u,
        forceMode: "drag"
      });
      Wi(e.getGeoJson().properties, u.properties) || e._updateAllProperties(u.properties), l && (this.previousLngLat = r);
    }
  }
  moveSource(e, r, s) {
    const u = lu(r, s);
    return wp(e, u);
  }
  moveEllipse(e, r, s) {
    if (e.shape !== "ellipse")
      return te.error("BaseDrag.moveCircle: invalid shape type", e), null;
    const u = e.getShapeProperty("center"), l = e.getShapeProperty("xSemiAxis"), f = e.getShapeProperty("ySemiAxis"), h = e.getShapeProperty("angle");
    if (!Array.isArray(u) || typeof l != "number" || typeof f != "number" || typeof h != "number")
      return te.error(
        "BaseDrag.moveEllipse: missing center, xSemiAxis, ySemiAxis or angle in the featureData",
        e
      ), null;
    const p = lu(r, s), d = [
      u[0] + p.lng,
      u[1] + p.lat
    ];
    return No({
      center: d,
      xSemiAxis: l,
      ySemiAxis: f,
      angle: h
    });
  }
  moveCircle(e, r, s) {
    if (e.shape !== "circle")
      return te.error("BaseDrag.moveCircle: invalid shape type", e), null;
    const u = e.getShapeProperty("center");
    if (!Array.isArray(u))
      return te.error("BaseDrag.moveCircle: missing center in the featureData", e), null;
    const l = e.getGeoJson(), f = lu(r, s), h = Zd(l);
    if (!h)
      return te.error("BaseDrag.moveCircle: missing center circleRimLngLat"), null;
    const p = [
      u[0] + f.lng,
      u[1] + f.lat
    ];
    e.setShapeProperty("center", p);
    const d = Xl({
      center: p,
      radius: this.gm.mapAdapter.getDistance(u, h)
    });
    return {
      type: "Feature",
      properties: {
        shape: "circle"
      },
      geometry: d.geometry
    };
  }
};
var US = {
  imperial: "en-US",
  metric: "nb-NO"
};
var kp = {
  distance: {
    metric: [
      { range: [0, 1], unit: "cm", factor: 100 },
      { range: [1, 1e4], unit: "m", factor: 1 },
      { range: [1e4, 1 / 0], unit: "km", factor: 1e-3 }
    ],
    imperial: [
      { range: [0, 0.3048], factor: 39.3701, unit: "in" },
      { range: [0.3048, 1609.344], factor: 3.28084, unit: "ft" },
      { range: [1609.344, 1 / 0], factor: 621371e-9, unit: "mi" }
    ]
  },
  area: {
    metric: [
      { range: [0, 1], unit: "cm", factor: 1e4 },
      { range: [1, 1e4], unit: "m", factor: 1 },
      { range: [1e5, 1 / 0], unit: "km", factor: 1e-6 }
    ],
    imperial: [
      { range: [0, 0.092903], factor: 1550.0031, unit: "in" },
      { range: [0.092903, 4046.856], factor: 10.7639, unit: "ft" },
      { range: [4046.856, 2589988], factor: 247105e-9, unit: "ac" },
      { range: [2589988, 1 / 0], factor: 3861e-10, unit: "mi" }
    ]
  }
};
var zS = (t, e) => (t % e + e) % e;
var ho = (t, e) => new Intl.NumberFormat(US[e.units], {
  minimumFractionDigits: e.minimumFractionDigits ?? 0,
  maximumFractionDigits: e.maximumFractionDigits ?? 2
}).format(t);
var xI = (t, e) => {
  const s = kp.distance[e.units].find((u) => t >= u.range[0] && t < u.range[1]);
  return s ? `${ho(t * s.factor, e)} ${s.unit}` : ho(t, e);
};
var wI = (t, e) => {
  const s = kp.area[e.units].find((u) => t >= u.range[0] && t < u.range[1]);
  return s ? `${ho(t * s.factor, e)} ${s.unit}` : ho(t, e);
};
var qS = class extends nc {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "change");
    __publicField(this, "cutVertexShapeTypes", ["line", "polygon", "rectangle"]);
    __publicField(this, "markerData", null);
    __publicField(this, "shapeUpdateHandlers", {
      marker: this.updateSingleVertex.bind(this),
      circle: this.updateCircle.bind(this),
      circle_marker: this.updateSingleVertex.bind(this),
      ellipse: this.updateEllipse.bind(this),
      text_marker: this.updateSingleVertex.bind(this),
      line: this.updateSingleVertex.bind(this),
      rectangle: this.updateRectangle.bind(this),
      polygon: this.updateSingleVertex.bind(this)
    });
  }
  get snapGuidesInstance() {
    const e = this.gm.actionInstances.helper__snap_guides;
    return np(e) ? e : null;
  }
  onStartAction() {
  }
  onEndAction() {
    var _a6;
    (_a6 = this.snapGuidesInstance) == null ? void 0 : _a6.removeSnapGuides();
  }
  handleGmEdit(e) {
    var _a6;
    if (!es(e))
      return { next: true };
    if (e.action === "marker_move" && e.lngLatStart && e.markerData) {
      if (e.markerData.type === "vertex")
        return this.moveVertex(e), { next: false };
      if (e.lngLatEnd)
        return this.moveSource(e.featureData, e.lngLatStart, e.lngLatEnd), { next: false };
    }
    return e.action === "marker_right_click" ? (this.cutVertex(e), this.fireFeatureEditEndEvent({ feature: e.featureData })) : e.action === "edge_marker_click" ? this.insertVertex(e) : e.action === "marker_captured" ? (this.setCursorToPointer(), e.featureData.changeSource({ sourceName: K.temporary, atomic: true }), this.flags.actionInProgress = true, this.fireFeatureEditStartEvent({ feature: e.featureData })) : e.action === "marker_released" && (this.markerData = null, (_a6 = this.snapGuidesInstance) == null ? void 0 : _a6.removeSnapGuides(), e.featureData.changeSource({ sourceName: K.main, atomic: true }), this.fireFeatureEditEndEvent({ feature: e.featureData }), this.flags.actionInProgress = false), { next: true };
  }
  moveVertex(e) {
    var _a6, _b2, _c2;
    this.markerData || (this.markerData = e.markerData || null, (_a6 = this.snapGuidesInstance) == null ? void 0 : _a6.updateSnapGuides(e.featureData.getGeoJson(), e.lngLatStart));
    const r = e.featureData, s = r.shape, u = ((_c2 = (_b2 = this.shapeUpdateHandlers)[s]) == null ? void 0 : _c2.call(_b2, e)) || null;
    u ? (this.fireBeforeFeatureUpdate({
      features: [r],
      geoJsonFeatures: [u]
    }), this.updateFeatureGeoJson({ featureData: r, featureGeoJson: u })) : te.error("EditChange.moveVertex: invalid geojson", u, e);
  }
  cutVertex(e) {
    const r = e.featureData;
    if (e.markerData.type !== "vertex" || !this.cutVertexShapeTypes.includes(r.shape))
      return;
    let s = false;
    const u = r.getGeoJson(), l = e.markerData.instance;
    if (Gs(u)) {
      if (cu(u) <= 2) {
        this.gm.features.delete(r);
        return;
      }
    } else if (Hl(u)) {
      if (cu(u) <= 3) {
        this.gm.features.delete(r);
        return;
      }
    } else if (Yl(u) && cu(u) <= 3) {
      this.gm.features.delete(r);
      return;
    }
    const f = tc(l);
    f && (s = Fk(u, f)), s ? (r.convertToPolygon(), r.updateGeoJsonGeometry(u.geometry), this.fireFeatureUpdatedEvent({
      sourceFeatures: [r],
      targetFeatures: [r],
      markerData: e.markerData
    })) : te.error("EditChange.cutVertex: feature not updated", e);
  }
  insertVertex(e) {
    if (e.markerData.type !== "edge")
      return;
    const r = e.featureData.getGeoJson(), s = e.markerData.segment.end.path, u = s.pop(), l = Ui(r, s);
    typeof u == "number" && (l.splice(u, 0, [...e.markerData.position.coordinate]), e.featureData.updateGeoJsonGeometry(r.geometry), e.featureData.convertToPolygon(), this.fireFeatureUpdatedEvent({
      sourceFeatures: [e.featureData],
      targetFeatures: [e.featureData],
      markerData: e.markerData
    }));
  }
  updateSingleVertex({ featureData: e, lngLatEnd: r, markerData: s }) {
    const u = $t(e.getGeoJson()), l = $t(s.position.path), f = l.pop(), h = Ui(u, l);
    return Array.isArray(h) && typeof f == "number" ? (h[f] = [...r], f === 0 && e.shape === "polygon" && (h[h.length - 1] = [...r])) : te.error("BaseDrag.moveSingleVertex: invalid coordinates", u, l), u;
  }
  updateCircle({ featureData: e, lngLatEnd: r }) {
    const s = e.getShapeProperty("center");
    if (e.shape !== "circle" || !s)
      return te.error("BaseDrag.moveCircle: invalid shape type / missing center", e), null;
    const u = Xl({
      center: s,
      radius: this.gm.mapAdapter.getDistance(s, r)
    });
    return {
      type: "Feature",
      properties: {
        shape: "circle"
      },
      geometry: u.geometry
    };
  }
  updateEllipse(e) {
    const { featureData: r, lngLatEnd: s, markerData: u } = e;
    if (r.shape !== "ellipse")
      return te.error("EditChange.updateEllipse: invalid shape type", r), null;
    const l = r.getShapeProperty("center");
    let f = r.getShapeProperty("xSemiAxis"), h = r.getShapeProperty("ySemiAxis");
    const p = r.getShapeProperty("angle");
    if (!Array.isArray(l) || typeof f != "number" || typeof h != "number" || typeof p != "number")
      return te.error(
        "updateEllipse: missing center, xSemiAxis, ySemiAxis or angle in the featureData",
        r
      ), null;
    const d = this.gm.mapAdapter.getDistance(l, s), v = u.position.path[3], _ = Math.floor(v / Kd * 4);
    return (_ === 0 || _ === 2 ? "x" : "y") === "x" ? f = d : h = d, No({
      center: l,
      xSemiAxis: f,
      ySemiAxis: h,
      angle: p
    });
  }
  updateRectangle({ featureData: e, lngLatStart: r, lngLatEnd: s }) {
    const l = e.getGeoJson(), f = l.geometry.coordinates[0], { absCoordIndex: h } = Co(l, r);
    if (h === -1)
      return te.error("EditChange.updateRectangle: start vertex not found", e), null;
    const p = zS(h - 2, 4), d = f[p];
    return ju(s, d);
  }
};
function YS(t, e, {
  ignoreSelfIntersections: r = true
} = { ignoreSelfIntersections: true }) {
  let s = true;
  return Pr(t, (u) => {
    Pr(e, (l) => {
      if (s === false)
        return false;
      s = HS(
        u.geometry,
        l.geometry,
        r
      );
    });
  }), s;
}
function HS(t, e, r) {
  switch (t.type) {
    case "Point":
      switch (e.type) {
        case "Point":
          return !XS(t.coordinates, e.coordinates);
        case "LineString":
          return !Nf(e, t);
        case "Polygon":
          return !ii(t, e);
      }
      break;
    case "LineString":
      switch (e.type) {
        case "Point":
          return !Nf(t, e);
        case "LineString":
          return !JS(t, e, r);
        case "Polygon":
          return !Pf(e, t, r);
      }
      break;
    case "Polygon":
      switch (e.type) {
        case "Point":
          return !ii(e, t);
        case "LineString":
          return !Pf(t, e, r);
        case "Polygon":
          return !$S(e, t, r);
      }
  }
  return false;
}
function Nf(t, e) {
  for (let r = 0; r < t.coordinates.length - 1; r++)
    if (VS(
      t.coordinates[r],
      t.coordinates[r + 1],
      e.coordinates
    ))
      return true;
  return false;
}
function JS(t, e, r) {
  return ua(t, e, {
    ignoreSelfIntersections: r
  }).features.length > 0;
}
function Pf(t, e, r) {
  for (const u of e.coordinates)
    if (ii(u, t))
      return true;
  return ua(e, Wu(t), {
    ignoreSelfIntersections: r
  }).features.length > 0;
}
function $S(t, e, r) {
  for (const u of t.coordinates[0])
    if (ii(u, e))
      return true;
  for (const u of e.coordinates[0])
    if (ii(u, t))
      return true;
  return ua(
    Wu(t),
    Wu(e),
    { ignoreSelfIntersections: r }
  ).features.length > 0;
}
function VS(t, e, r) {
  const s = r[0] - t[0], u = r[1] - t[1], l = e[0] - t[0], f = e[1] - t[1];
  return s * f - u * l !== 0 ? false : Math.abs(l) >= Math.abs(f) ? l > 0 ? t[0] <= r[0] && r[0] <= e[0] : e[0] <= r[0] && r[0] <= t[0] : f > 0 ? t[1] <= r[1] && r[1] <= e[1] : e[1] <= r[1] && r[1] <= t[1];
}
function XS(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}
function WS(t, e, {
  ignoreSelfIntersections: r = true
} = {}) {
  let s = false;
  return Pr(t, (u) => {
    Pr(e, (l) => {
      if (s === true)
        return true;
      s = !YS(u.geometry, l.geometry, {
        ignoreSelfIntersections: r
      });
    });
  }), s;
}
var Sp = WS;
var jS = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var vu = Math.ceil;
var Qt = Math.floor;
var Ot = "[BigNumber Error] ";
var Of = Ot + "Number primitive has more than 15 significant digits: ";
var gn = 1e14;
var we = 14;
var yu = 9007199254740991;
var _u4 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var Mr = 1e7;
var st = 1e9;
function Mp(t) {
  var e, r, s, u = M.prototype = { constructor: M, toString: null, valueOf: null }, l = new M(1), f = 20, h = 4, p = -7, d = 21, v = -1e7, _ = 1e7, E = false, S = 1, I = 0, D = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, O = "0123456789abcdefghijklmnopqrstuvwxyz", T = true;
  function M(x, k) {
    var b, L, C, G, R, P, F, q, U = this;
    if (!(U instanceof M)) return new M(x, k);
    if (k == null) {
      if (x && x._isBigNumber === true) {
        U.s = x.s, !x.c || x.e > _ ? U.c = U.e = null : x.e < v ? U.c = [U.e = 0] : (U.e = x.e, U.c = x.c.slice());
        return;
      }
      if ((P = typeof x == "number") && x * 0 == 0) {
        if (U.s = 1 / x < 0 ? (x = -x, -1) : 1, x === ~~x) {
          for (G = 0, R = x; R >= 10; R /= 10, G++) ;
          G > _ ? U.c = U.e = null : (U.e = G, U.c = [x]);
          return;
        }
        q = String(x);
      } else {
        if (!jS.test(q = String(x))) return s(U, q, P);
        U.s = q.charCodeAt(0) == 45 ? (q = q.slice(1), -1) : 1;
      }
      (G = q.indexOf(".")) > -1 && (q = q.replace(".", "")), (R = q.search(/e/i)) > 0 ? (G < 0 && (G = R), G += +q.slice(R + 1), q = q.substring(0, R)) : G < 0 && (G = q.length);
    } else {
      if (Xe(k, 2, O.length, "Base"), k == 10 && T)
        return U = new M(x), Y(U, f + U.e + 1, h);
      if (q = String(x), P = typeof x == "number") {
        if (x * 0 != 0) return s(U, q, P, k);
        if (U.s = 1 / x < 0 ? (q = q.slice(1), -1) : 1, M.DEBUG && q.replace(/^0\.0*|\./, "").length > 15)
          throw Error(Of + x);
      } else
        U.s = q.charCodeAt(0) === 45 ? (q = q.slice(1), -1) : 1;
      for (b = O.slice(0, k), G = R = 0, F = q.length; R < F; R++)
        if (b.indexOf(L = q.charAt(R)) < 0) {
          if (L == ".") {
            if (R > G) {
              G = F;
              continue;
            }
          } else if (!C && (q == q.toUpperCase() && (q = q.toLowerCase()) || q == q.toLowerCase() && (q = q.toUpperCase()))) {
            C = true, R = -1, G = 0;
            continue;
          }
          return s(U, String(x), P, k);
        }
      P = false, q = r(q, k, 10, U.s), (G = q.indexOf(".")) > -1 ? q = q.replace(".", "") : G = q.length;
    }
    for (R = 0; q.charCodeAt(R) === 48; R++) ;
    for (F = q.length; q.charCodeAt(--F) === 48; ) ;
    if (q = q.slice(R, ++F)) {
      if (F -= R, P && M.DEBUG && F > 15 && (x > yu || x !== Qt(x)))
        throw Error(Of + U.s * x);
      if ((G = G - R - 1) > _)
        U.c = U.e = null;
      else if (G < v)
        U.c = [U.e = 0];
      else {
        if (U.e = G, U.c = [], R = (G + 1) % we, G < 0 && (R += we), R < F) {
          for (R && U.c.push(+q.slice(0, R)), F -= we; R < F; )
            U.c.push(+q.slice(R, R += we));
          R = we - (q = q.slice(R)).length;
        } else
          R -= F;
        for (; R--; q += "0") ;
        U.c.push(+q);
      }
    } else
      U.c = [U.e = 0];
  }
  M.clone = Mp, M.ROUND_UP = 0, M.ROUND_DOWN = 1, M.ROUND_CEIL = 2, M.ROUND_FLOOR = 3, M.ROUND_HALF_UP = 4, M.ROUND_HALF_DOWN = 5, M.ROUND_HALF_EVEN = 6, M.ROUND_HALF_CEIL = 7, M.ROUND_HALF_FLOOR = 8, M.EUCLID = 9, M.config = M.set = function(x) {
    var k, b;
    if (x != null)
      if (typeof x == "object") {
        if (x.hasOwnProperty(k = "DECIMAL_PLACES") && (b = x[k], Xe(b, 0, st, k), f = b), x.hasOwnProperty(k = "ROUNDING_MODE") && (b = x[k], Xe(b, 0, 8, k), h = b), x.hasOwnProperty(k = "EXPONENTIAL_AT") && (b = x[k], b && b.pop ? (Xe(b[0], -st, 0, k), Xe(b[1], 0, st, k), p = b[0], d = b[1]) : (Xe(b, -st, st, k), p = -(d = b < 0 ? -b : b))), x.hasOwnProperty(k = "RANGE"))
          if (b = x[k], b && b.pop)
            Xe(b[0], -st, -1, k), Xe(b[1], 1, st, k), v = b[0], _ = b[1];
          else if (Xe(b, -st, st, k), b)
            v = -(_ = b < 0 ? -b : b);
          else
            throw Error(Ot + k + " cannot be zero: " + b);
        if (x.hasOwnProperty(k = "CRYPTO"))
          if (b = x[k], b === !!b)
            if (b)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                E = b;
              else
                throw E = !b, Error(Ot + "crypto unavailable");
            else
              E = b;
          else
            throw Error(Ot + k + " not true or false: " + b);
        if (x.hasOwnProperty(k = "MODULO_MODE") && (b = x[k], Xe(b, 0, 9, k), S = b), x.hasOwnProperty(k = "POW_PRECISION") && (b = x[k], Xe(b, 0, st, k), I = b), x.hasOwnProperty(k = "FORMAT"))
          if (b = x[k], typeof b == "object") D = b;
          else throw Error(Ot + k + " not an object: " + b);
        if (x.hasOwnProperty(k = "ALPHABET"))
          if (b = x[k], typeof b == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(b))
            T = b.slice(0, 10) == "0123456789", O = b;
          else
            throw Error(Ot + k + " invalid: " + b);
      } else
        throw Error(Ot + "Object expected: " + x);
    return {
      DECIMAL_PLACES: f,
      ROUNDING_MODE: h,
      EXPONENTIAL_AT: [p, d],
      RANGE: [v, _],
      CRYPTO: E,
      MODULO_MODE: S,
      POW_PRECISION: I,
      FORMAT: D,
      ALPHABET: O
    };
  }, M.isBigNumber = function(x) {
    if (!x || x._isBigNumber !== true) return false;
    if (!M.DEBUG) return true;
    var k, b, L = x.c, C = x.e, G = x.s;
    e: if ({}.toString.call(L) == "[object Array]") {
      if ((G === 1 || G === -1) && C >= -st && C <= st && C === Qt(C)) {
        if (L[0] === 0) {
          if (C === 0 && L.length === 1) return true;
          break e;
        }
        if (k = (C + 1) % we, k < 1 && (k += we), String(L[0]).length == k) {
          for (k = 0; k < L.length; k++)
            if (b = L[k], b < 0 || b >= gn || b !== Qt(b)) break e;
          if (b !== 0) return true;
        }
      }
    } else if (L === null && C === null && (G === null || G === 1 || G === -1))
      return true;
    throw Error(Ot + "Invalid BigNumber: " + x);
  }, M.maximum = M.max = function() {
    return X(arguments, -1);
  }, M.minimum = M.min = function() {
    return X(arguments, 1);
  }, M.random = (function() {
    var x = 9007199254740992, k = Math.random() * x & 2097151 ? function() {
      return Qt(Math.random() * x);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(b) {
      var L, C, G, R, P, F = 0, q = [], U = new M(l);
      if (b == null ? b = f : Xe(b, 0, st), R = vu(b / we), E)
        if (crypto.getRandomValues) {
          for (L = crypto.getRandomValues(new Uint32Array(R *= 2)); F < R; )
            P = L[F] * 131072 + (L[F + 1] >>> 11), P >= 9e15 ? (C = crypto.getRandomValues(new Uint32Array(2)), L[F] = C[0], L[F + 1] = C[1]) : (q.push(P % 1e14), F += 2);
          F = R / 2;
        } else if (crypto.randomBytes) {
          for (L = crypto.randomBytes(R *= 7); F < R; )
            P = (L[F] & 31) * 281474976710656 + L[F + 1] * 1099511627776 + L[F + 2] * 4294967296 + L[F + 3] * 16777216 + (L[F + 4] << 16) + (L[F + 5] << 8) + L[F + 6], P >= 9e15 ? crypto.randomBytes(7).copy(L, F) : (q.push(P % 1e14), F += 7);
          F = R / 7;
        } else
          throw E = false, Error(Ot + "crypto unavailable");
      if (!E)
        for (; F < R; )
          P = k(), P < 9e15 && (q[F++] = P % 1e14);
      for (R = q[--F], b %= we, R && b && (P = _u4[we - b], q[F] = Qt(R / P) * P); q[F] === 0; q.pop(), F--) ;
      if (F < 0)
        q = [G = 0];
      else {
        for (G = -1; q[0] === 0; q.splice(0, 1), G -= we) ;
        for (F = 1, P = q[0]; P >= 10; P /= 10, F++) ;
        F < we && (G -= we - F);
      }
      return U.e = G, U.c = q, U;
    };
  })(), M.sum = function() {
    for (var x = 1, k = arguments, b = new M(k[0]); x < k.length; ) b = b.plus(k[x++]);
    return b;
  }, r = /* @__PURE__ */ (function() {
    var x = "0123456789";
    function k(b, L, C, G) {
      for (var R, P = [0], F, q = 0, U = b.length; q < U; ) {
        for (F = P.length; F--; P[F] *= L) ;
        for (P[0] += G.indexOf(b.charAt(q++)), R = 0; R < P.length; R++)
          P[R] > C - 1 && (P[R + 1] == null && (P[R + 1] = 0), P[R + 1] += P[R] / C | 0, P[R] %= C);
      }
      return P.reverse();
    }
    return function(b, L, C, G, R) {
      var P, F, q, U, W, Z, ne, ge, le = b.indexOf("."), ae = f, oe = h;
      for (le >= 0 && (U = I, I = 0, b = b.replace(".", ""), ge = new M(L), Z = ge.pow(b.length - le), I = U, ge.c = k(
        nr(Kt(Z.c), Z.e, "0"),
        10,
        C,
        x
      ), ge.e = ge.c.length), ne = k(b, L, C, R ? (P = O, x) : (P = x, O)), q = U = ne.length; ne[--U] == 0; ne.pop()) ;
      if (!ne[0]) return P.charAt(0);
      if (le < 0 ? --q : (Z.c = ne, Z.e = q, Z.s = G, Z = e(Z, ge, ae, oe, C), ne = Z.c, W = Z.r, q = Z.e), F = q + ae + 1, le = ne[F], U = C / 2, W = W || F < 0 || ne[F + 1] != null, W = oe < 4 ? (le != null || W) && (oe == 0 || oe == (Z.s < 0 ? 3 : 2)) : le > U || le == U && (oe == 4 || W || oe == 6 && ne[F - 1] & 1 || oe == (Z.s < 0 ? 8 : 7)), F < 1 || !ne[0])
        b = W ? nr(P.charAt(1), -ae, P.charAt(0)) : P.charAt(0);
      else {
        if (ne.length = F, W)
          for (--C; ++ne[--F] > C; )
            ne[F] = 0, F || (++q, ne = [1].concat(ne));
        for (U = ne.length; !ne[--U]; ) ;
        for (le = 0, b = ""; le <= U; b += P.charAt(ne[le++])) ;
        b = nr(b, q, P.charAt(0));
      }
      return b;
    };
  })(), e = /* @__PURE__ */ (function() {
    function x(L, C, G) {
      var R, P, F, q, U = 0, W = L.length, Z = C % Mr, ne = C / Mr | 0;
      for (L = L.slice(); W--; )
        F = L[W] % Mr, q = L[W] / Mr | 0, R = ne * F + q * Z, P = Z * F + R % Mr * Mr + U, U = (P / G | 0) + (R / Mr | 0) + ne * q, L[W] = P % G;
      return U && (L = [U].concat(L)), L;
    }
    function k(L, C, G, R) {
      var P, F;
      if (G != R)
        F = G > R ? 1 : -1;
      else
        for (P = F = 0; P < G; P++)
          if (L[P] != C[P]) {
            F = L[P] > C[P] ? 1 : -1;
            break;
          }
      return F;
    }
    function b(L, C, G, R) {
      for (var P = 0; G--; )
        L[G] -= P, P = L[G] < C[G] ? 1 : 0, L[G] = P * R + L[G] - C[G];
      for (; !L[0] && L.length > 1; L.splice(0, 1)) ;
    }
    return function(L, C, G, R, P) {
      var F, q, U, W, Z, ne, ge, le, ae, oe, xe, Te, H, bn, Ie, ce, N, Ce = L.s == C.s ? 1 : -1, De = L.c, ke = C.c;
      if (!De || !De[0] || !ke || !ke[0])
        return new M(
          // Return NaN if either NaN, or both Infinity or 0.
          !L.s || !C.s || (De ? ke && De[0] == ke[0] : !ke) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            De && De[0] == 0 || !ke ? Ce * 0 : Ce / 0
          )
        );
      for (le = new M(Ce), ae = le.c = [], q = L.e - C.e, Ce = G + q + 1, P || (P = gn, q = en(L.e / we) - en(C.e / we), Ce = Ce / we | 0), U = 0; ke[U] == (De[U] || 0); U++) ;
      if (ke[U] > (De[U] || 0) && q--, Ce < 0)
        ae.push(1), W = true;
      else {
        for (bn = De.length, ce = ke.length, U = 0, Ce += 2, Z = Qt(P / (ke[0] + 1)), Z > 1 && (ke = x(ke, Z, P), De = x(De, Z, P), ce = ke.length, bn = De.length), H = ce, oe = De.slice(0, ce), xe = oe.length; xe < ce; oe[xe++] = 0) ;
        N = ke.slice(), N = [0].concat(N), Ie = ke[0], ke[1] >= P / 2 && Ie++;
        do {
          if (Z = 0, F = k(ke, oe, ce, xe), F < 0) {
            if (Te = oe[0], ce != xe && (Te = Te * P + (oe[1] || 0)), Z = Qt(Te / Ie), Z > 1)
              for (Z >= P && (Z = P - 1), ne = x(ke, Z, P), ge = ne.length, xe = oe.length; k(ne, oe, ge, xe) == 1; )
                Z--, b(ne, ce < ge ? N : ke, ge, P), ge = ne.length, F = 1;
            else
              Z == 0 && (F = Z = 1), ne = ke.slice(), ge = ne.length;
            if (ge < xe && (ne = [0].concat(ne)), b(oe, ne, xe, P), xe = oe.length, F == -1)
              for (; k(ke, oe, ce, xe) < 1; )
                Z++, b(oe, ce < xe ? N : ke, xe, P), xe = oe.length;
          } else F === 0 && (Z++, oe = [0]);
          ae[U++] = Z, oe[0] ? oe[xe++] = De[H] || 0 : (oe = [De[H]], xe = 1);
        } while ((H++ < bn || oe[0] != null) && Ce--);
        W = oe[0] != null, ae[0] || ae.splice(0, 1);
      }
      if (P == gn) {
        for (U = 1, Ce = ae[0]; Ce >= 10; Ce /= 10, U++) ;
        Y(le, G + (le.e = U + q * we - 1) + 1, R, W);
      } else
        le.e = q, le.r = +W;
      return le;
    };
  })();
  function J(x, k, b, L) {
    var C, G, R, P, F;
    if (b == null ? b = h : Xe(b, 0, 8), !x.c) return x.toString();
    if (C = x.c[0], R = x.e, k == null)
      F = Kt(x.c), F = L == 1 || L == 2 && (R <= p || R >= d) ? Fa(F, R) : nr(F, R, "0");
    else if (x = Y(new M(x), k, b), G = x.e, F = Kt(x.c), P = F.length, L == 1 || L == 2 && (k <= G || G <= p)) {
      for (; P < k; F += "0", P++) ;
      F = Fa(F, G);
    } else if (k -= R + (L === 2 && G > R), F = nr(F, G, "0"), G + 1 > P) {
      if (--k > 0) for (F += "."; k--; F += "0") ;
    } else if (k += G - P, k > 0)
      for (G + 1 == P && (F += "."); k--; F += "0") ;
    return x.s < 0 && C ? "-" + F : F;
  }
  function X(x, k) {
    for (var b, L, C = 1, G = new M(x[0]); C < x.length; C++)
      L = new M(x[C]), (!L.s || (b = $r(G, L)) === k || b === 0 && G.s === k) && (G = L);
    return G;
  }
  function $(x, k, b) {
    for (var L = 1, C = k.length; !k[--C]; k.pop()) ;
    for (C = k[0]; C >= 10; C /= 10, L++) ;
    return (b = L + b * we - 1) > _ ? x.c = x.e = null : b < v ? x.c = [x.e = 0] : (x.e = b, x.c = k), x;
  }
  s = /* @__PURE__ */ (function() {
    var x = /^(-?)0([xbo])(?=\w[\w.]*$)/i, k = /^([^.]+)\.$/, b = /^\.([^.]+)$/, L = /^-?(Infinity|NaN)$/, C = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(G, R, P, F) {
      var q, U = P ? R : R.replace(C, "");
      if (L.test(U))
        G.s = isNaN(U) ? null : U < 0 ? -1 : 1;
      else {
        if (!P && (U = U.replace(x, function(W, Z, ne) {
          return q = (ne = ne.toLowerCase()) == "x" ? 16 : ne == "b" ? 2 : 8, !F || F == q ? Z : W;
        }), F && (q = F, U = U.replace(k, "$1").replace(b, "0.$1")), R != U))
          return new M(U, q);
        if (M.DEBUG)
          throw Error(Ot + "Not a" + (F ? " base " + F : "") + " number: " + R);
        G.s = null;
      }
      G.c = G.e = null;
    };
  })();
  function Y(x, k, b, L) {
    var C, G, R, P, F, q, U, W = x.c, Z = _u4;
    if (W) {
      e: {
        for (C = 1, P = W[0]; P >= 10; P /= 10, C++) ;
        if (G = k - C, G < 0)
          G += we, R = k, F = W[q = 0], U = Qt(F / Z[C - R - 1] % 10);
        else if (q = vu((G + 1) / we), q >= W.length)
          if (L) {
            for (; W.length <= q; W.push(0)) ;
            F = U = 0, C = 1, G %= we, R = G - we + 1;
          } else
            break e;
        else {
          for (F = P = W[q], C = 1; P >= 10; P /= 10, C++) ;
          G %= we, R = G - we + C, U = R < 0 ? 0 : Qt(F / Z[C - R - 1] % 10);
        }
        if (L = L || k < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        W[q + 1] != null || (R < 0 ? F : F % Z[C - R - 1]), L = b < 4 ? (U || L) && (b == 0 || b == (x.s < 0 ? 3 : 2)) : U > 5 || U == 5 && (b == 4 || L || b == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (G > 0 ? R > 0 ? F / Z[C - R] : 0 : W[q - 1]) % 10 & 1 || b == (x.s < 0 ? 8 : 7)), k < 1 || !W[0])
          return W.length = 0, L ? (k -= x.e + 1, W[0] = Z[(we - k % we) % we], x.e = -k || 0) : W[0] = x.e = 0, x;
        if (G == 0 ? (W.length = q, P = 1, q--) : (W.length = q + 1, P = Z[we - G], W[q] = R > 0 ? Qt(F / Z[C - R] % Z[R]) * P : 0), L)
          for (; ; )
            if (q == 0) {
              for (G = 1, R = W[0]; R >= 10; R /= 10, G++) ;
              for (R = W[0] += P, P = 1; R >= 10; R /= 10, P++) ;
              G != P && (x.e++, W[0] == gn && (W[0] = 1));
              break;
            } else {
              if (W[q] += P, W[q] != gn) break;
              W[q--] = 0, P = 1;
            }
        for (G = W.length; W[--G] === 0; W.pop()) ;
      }
      x.e > _ ? x.c = x.e = null : x.e < v && (x.c = [x.e = 0]);
    }
    return x;
  }
  function j(x) {
    var k, b = x.e;
    return b === null ? x.toString() : (k = Kt(x.c), k = b <= p || b >= d ? Fa(k, b) : nr(k, b, "0"), x.s < 0 ? "-" + k : k);
  }
  return u.absoluteValue = u.abs = function() {
    var x = new M(this);
    return x.s < 0 && (x.s = 1), x;
  }, u.comparedTo = function(x, k) {
    return $r(this, new M(x, k));
  }, u.decimalPlaces = u.dp = function(x, k) {
    var b, L, C, G = this;
    if (x != null)
      return Xe(x, 0, st), k == null ? k = h : Xe(k, 0, 8), Y(new M(G), x + G.e + 1, k);
    if (!(b = G.c)) return null;
    if (L = ((C = b.length - 1) - en(this.e / we)) * we, C = b[C]) for (; C % 10 == 0; C /= 10, L--) ;
    return L < 0 && (L = 0), L;
  }, u.dividedBy = u.div = function(x, k) {
    return e(this, new M(x, k), f, h);
  }, u.dividedToIntegerBy = u.idiv = function(x, k) {
    return e(this, new M(x, k), 0, 1);
  }, u.exponentiatedBy = u.pow = function(x, k) {
    var b, L, C, G, R, P, F, q, U, W = this;
    if (x = new M(x), x.c && !x.isInteger())
      throw Error(Ot + "Exponent not an integer: " + j(x));
    if (k != null && (k = new M(k)), P = x.e > 14, !W.c || !W.c[0] || W.c[0] == 1 && !W.e && W.c.length == 1 || !x.c || !x.c[0])
      return U = new M(Math.pow(+j(W), P ? x.s * (2 - Da(x)) : +j(x))), k ? U.mod(k) : U;
    if (F = x.s < 0, k) {
      if (k.c ? !k.c[0] : !k.s) return new M(NaN);
      L = !F && W.isInteger() && k.isInteger(), L && (W = W.mod(k));
    } else {
      if (x.e > 9 && (W.e > 0 || W.e < -1 || (W.e == 0 ? W.c[0] > 1 || P && W.c[1] >= 24e7 : W.c[0] < 8e13 || P && W.c[0] <= 9999975e7)))
        return G = W.s < 0 && Da(x) ? -0 : 0, W.e > -1 && (G = 1 / G), new M(F ? 1 / G : G);
      I && (G = vu(I / we + 2));
    }
    for (P ? (b = new M(0.5), F && (x.s = 1), q = Da(x)) : (C = Math.abs(+j(x)), q = C % 2), U = new M(l); ; ) {
      if (q) {
        if (U = U.times(W), !U.c) break;
        G ? U.c.length > G && (U.c.length = G) : L && (U = U.mod(k));
      }
      if (C) {
        if (C = Qt(C / 2), C === 0) break;
        q = C % 2;
      } else if (x = x.times(b), Y(x, x.e + 1, 1), x.e > 14)
        q = Da(x);
      else {
        if (C = +j(x), C === 0) break;
        q = C % 2;
      }
      W = W.times(W), G ? W.c && W.c.length > G && (W.c.length = G) : L && (W = W.mod(k));
    }
    return L ? U : (F && (U = l.div(U)), k ? U.mod(k) : G ? Y(U, I, h, R) : U);
  }, u.integerValue = function(x) {
    var k = new M(this);
    return x == null ? x = h : Xe(x, 0, 8), Y(k, k.e + 1, x);
  }, u.isEqualTo = u.eq = function(x, k) {
    return $r(this, new M(x, k)) === 0;
  }, u.isFinite = function() {
    return !!this.c;
  }, u.isGreaterThan = u.gt = function(x, k) {
    return $r(this, new M(x, k)) > 0;
  }, u.isGreaterThanOrEqualTo = u.gte = function(x, k) {
    return (k = $r(this, new M(x, k))) === 1 || k === 0;
  }, u.isInteger = function() {
    return !!this.c && en(this.e / we) > this.c.length - 2;
  }, u.isLessThan = u.lt = function(x, k) {
    return $r(this, new M(x, k)) < 0;
  }, u.isLessThanOrEqualTo = u.lte = function(x, k) {
    return (k = $r(this, new M(x, k))) === -1 || k === 0;
  }, u.isNaN = function() {
    return !this.s;
  }, u.isNegative = function() {
    return this.s < 0;
  }, u.isPositive = function() {
    return this.s > 0;
  }, u.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, u.minus = function(x, k) {
    var b, L, C, G, R = this, P = R.s;
    if (x = new M(x, k), k = x.s, !P || !k) return new M(NaN);
    if (P != k)
      return x.s = -k, R.plus(x);
    var F = R.e / we, q = x.e / we, U = R.c, W = x.c;
    if (!F || !q) {
      if (!U || !W) return U ? (x.s = -k, x) : new M(W ? R : NaN);
      if (!U[0] || !W[0])
        return W[0] ? (x.s = -k, x) : new M(U[0] ? R : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          h == 3 ? -0 : 0
        ));
    }
    if (F = en(F), q = en(q), U = U.slice(), P = F - q) {
      for ((G = P < 0) ? (P = -P, C = U) : (q = F, C = W), C.reverse(), k = P; k--; C.push(0)) ;
      C.reverse();
    } else
      for (L = (G = (P = U.length) < (k = W.length)) ? P : k, P = k = 0; k < L; k++)
        if (U[k] != W[k]) {
          G = U[k] < W[k];
          break;
        }
    if (G && (C = U, U = W, W = C, x.s = -x.s), k = (L = W.length) - (b = U.length), k > 0) for (; k--; U[b++] = 0) ;
    for (k = gn - 1; L > P; ) {
      if (U[--L] < W[L]) {
        for (b = L; b && !U[--b]; U[b] = k) ;
        --U[b], U[L] += gn;
      }
      U[L] -= W[L];
    }
    for (; U[0] == 0; U.splice(0, 1), --q) ;
    return U[0] ? $(x, U, q) : (x.s = h == 3 ? -1 : 1, x.c = [x.e = 0], x);
  }, u.modulo = u.mod = function(x, k) {
    var b, L, C = this;
    return x = new M(x, k), !C.c || !x.s || x.c && !x.c[0] ? new M(NaN) : !x.c || C.c && !C.c[0] ? new M(C) : (S == 9 ? (L = x.s, x.s = 1, b = e(C, x, 0, 3), x.s = L, b.s *= L) : b = e(C, x, 0, S), x = C.minus(b.times(x)), !x.c[0] && S == 1 && (x.s = C.s), x);
  }, u.multipliedBy = u.times = function(x, k) {
    var b, L, C, G, R, P, F, q, U, W, Z, ne, ge, le, ae, oe = this, xe = oe.c, Te = (x = new M(x, k)).c;
    if (!xe || !Te || !xe[0] || !Te[0])
      return !oe.s || !x.s || xe && !xe[0] && !Te || Te && !Te[0] && !xe ? x.c = x.e = x.s = null : (x.s *= oe.s, !xe || !Te ? x.c = x.e = null : (x.c = [0], x.e = 0)), x;
    for (L = en(oe.e / we) + en(x.e / we), x.s *= oe.s, F = xe.length, W = Te.length, F < W && (ge = xe, xe = Te, Te = ge, C = F, F = W, W = C), C = F + W, ge = []; C--; ge.push(0)) ;
    for (le = gn, ae = Mr, C = W; --C >= 0; ) {
      for (b = 0, Z = Te[C] % ae, ne = Te[C] / ae | 0, R = F, G = C + R; G > C; )
        q = xe[--R] % ae, U = xe[R] / ae | 0, P = ne * q + U * Z, q = Z * q + P % ae * ae + ge[G] + b, b = (q / le | 0) + (P / ae | 0) + ne * U, ge[G--] = q % le;
      ge[G] = b;
    }
    return b ? ++L : ge.splice(0, 1), $(x, ge, L);
  }, u.negated = function() {
    var x = new M(this);
    return x.s = -x.s || null, x;
  }, u.plus = function(x, k) {
    var b, L = this, C = L.s;
    if (x = new M(x, k), k = x.s, !C || !k) return new M(NaN);
    if (C != k)
      return x.s = -k, L.minus(x);
    var G = L.e / we, R = x.e / we, P = L.c, F = x.c;
    if (!G || !R) {
      if (!P || !F) return new M(C / 0);
      if (!P[0] || !F[0]) return F[0] ? x : new M(P[0] ? L : C * 0);
    }
    if (G = en(G), R = en(R), P = P.slice(), C = G - R) {
      for (C > 0 ? (R = G, b = F) : (C = -C, b = P), b.reverse(); C--; b.push(0)) ;
      b.reverse();
    }
    for (C = P.length, k = F.length, C - k < 0 && (b = F, F = P, P = b, k = C), C = 0; k; )
      C = (P[--k] = P[k] + F[k] + C) / gn | 0, P[k] = gn === P[k] ? 0 : P[k] % gn;
    return C && (P = [C].concat(P), ++R), $(x, P, R);
  }, u.precision = u.sd = function(x, k) {
    var b, L, C, G = this;
    if (x != null && x !== !!x)
      return Xe(x, 1, st), k == null ? k = h : Xe(k, 0, 8), Y(new M(G), x, k);
    if (!(b = G.c)) return null;
    if (C = b.length - 1, L = C * we + 1, C = b[C]) {
      for (; C % 10 == 0; C /= 10, L--) ;
      for (C = b[0]; C >= 10; C /= 10, L++) ;
    }
    return x && G.e + 1 > L && (L = G.e + 1), L;
  }, u.shiftedBy = function(x) {
    return Xe(x, -yu, yu), this.times("1e" + x);
  }, u.squareRoot = u.sqrt = function() {
    var x, k, b, L, C, G = this, R = G.c, P = G.s, F = G.e, q = f + 4, U = new M("0.5");
    if (P !== 1 || !R || !R[0])
      return new M(!P || P < 0 && (!R || R[0]) ? NaN : R ? G : 1 / 0);
    if (P = Math.sqrt(+j(G)), P == 0 || P == 1 / 0 ? (k = Kt(R), (k.length + F) % 2 == 0 && (k += "0"), P = Math.sqrt(+k), F = en((F + 1) / 2) - (F < 0 || F % 2), P == 1 / 0 ? k = "5e" + F : (k = P.toExponential(), k = k.slice(0, k.indexOf("e") + 1) + F), b = new M(k)) : b = new M(P + ""), b.c[0]) {
      for (F = b.e, P = F + q, P < 3 && (P = 0); ; )
        if (C = b, b = U.times(C.plus(e(G, C, q, 1))), Kt(C.c).slice(0, P) === (k = Kt(b.c)).slice(0, P))
          if (b.e < F && --P, k = k.slice(P - 3, P + 1), k == "9999" || !L && k == "4999") {
            if (!L && (Y(C, C.e + f + 2, 0), C.times(C).eq(G))) {
              b = C;
              break;
            }
            q += 4, P += 4, L = 1;
          } else {
            (!+k || !+k.slice(1) && k.charAt(0) == "5") && (Y(b, b.e + f + 2, 1), x = !b.times(b).eq(G));
            break;
          }
    }
    return Y(b, b.e + f + 1, h, x);
  }, u.toExponential = function(x, k) {
    return x != null && (Xe(x, 0, st), x++), J(this, x, k, 1);
  }, u.toFixed = function(x, k) {
    return x != null && (Xe(x, 0, st), x = x + this.e + 1), J(this, x, k);
  }, u.toFormat = function(x, k, b) {
    var L, C = this;
    if (b == null)
      x != null && k && typeof k == "object" ? (b = k, k = null) : x && typeof x == "object" ? (b = x, x = k = null) : b = D;
    else if (typeof b != "object")
      throw Error(Ot + "Argument not an object: " + b);
    if (L = C.toFixed(x, k), C.c) {
      var G, R = L.split("."), P = +b.groupSize, F = +b.secondaryGroupSize, q = b.groupSeparator || "", U = R[0], W = R[1], Z = C.s < 0, ne = Z ? U.slice(1) : U, ge = ne.length;
      if (F && (G = P, P = F, F = G, ge -= G), P > 0 && ge > 0) {
        for (G = ge % P || P, U = ne.substr(0, G); G < ge; G += P) U += q + ne.substr(G, P);
        F > 0 && (U += q + ne.slice(G)), Z && (U = "-" + U);
      }
      L = W ? U + (b.decimalSeparator || "") + ((F = +b.fractionGroupSize) ? W.replace(
        new RegExp("\\d{" + F + "}\\B", "g"),
        "$&" + (b.fractionGroupSeparator || "")
      ) : W) : U;
    }
    return (b.prefix || "") + L + (b.suffix || "");
  }, u.toFraction = function(x) {
    var k, b, L, C, G, R, P, F, q, U, W, Z, ne = this, ge = ne.c;
    if (x != null && (P = new M(x), !P.isInteger() && (P.c || P.s !== 1) || P.lt(l)))
      throw Error(Ot + "Argument " + (P.isInteger() ? "out of range: " : "not an integer: ") + j(P));
    if (!ge) return new M(ne);
    for (k = new M(l), q = b = new M(l), L = F = new M(l), Z = Kt(ge), G = k.e = Z.length - ne.e - 1, k.c[0] = _u4[(R = G % we) < 0 ? we + R : R], x = !x || P.comparedTo(k) > 0 ? G > 0 ? k : q : P, R = _, _ = 1 / 0, P = new M(Z), F.c[0] = 0; U = e(P, k, 0, 1), C = b.plus(U.times(L)), C.comparedTo(x) != 1; )
      b = L, L = C, q = F.plus(U.times(C = q)), F = C, k = P.minus(U.times(C = k)), P = C;
    return C = e(x.minus(b), L, 0, 1), F = F.plus(C.times(q)), b = b.plus(C.times(L)), F.s = q.s = ne.s, G = G * 2, W = e(q, L, G, h).minus(ne).abs().comparedTo(
      e(F, b, G, h).minus(ne).abs()
    ) < 1 ? [q, L] : [F, b], _ = R, W;
  }, u.toNumber = function() {
    return +j(this);
  }, u.toPrecision = function(x, k) {
    return x != null && Xe(x, 1, st), J(this, x, k, 2);
  }, u.toString = function(x) {
    var k, b = this, L = b.s, C = b.e;
    return C === null ? L ? (k = "Infinity", L < 0 && (k = "-" + k)) : k = "NaN" : (x == null ? k = C <= p || C >= d ? Fa(Kt(b.c), C) : nr(Kt(b.c), C, "0") : x === 10 && T ? (b = Y(new M(b), f + C + 1, h), k = nr(Kt(b.c), b.e, "0")) : (Xe(x, 2, O.length, "Base"), k = r(nr(Kt(b.c), C, "0"), 10, x, L, true)), L < 0 && b.c[0] && (k = "-" + k)), k;
  }, u.valueOf = u.toJSON = function() {
    return j(this);
  }, u._isBigNumber = true, u[Symbol.toStringTag] = "BigNumber", u[Symbol.for("nodejs.util.inspect.custom")] = u.valueOf, t != null && M.set(t), M;
}
function en(t) {
  var e = t | 0;
  return t > 0 || t === e ? e : e - 1;
}
function Kt(t) {
  for (var e, r, s = 1, u = t.length, l = t[0] + ""; s < u; ) {
    for (e = t[s++] + "", r = we - e.length; r--; e = "0" + e) ;
    l += e;
  }
  for (u = l.length; l.charCodeAt(--u) === 48; ) ;
  return l.slice(0, u + 1 || 1);
}
function $r(t, e) {
  var r, s, u = t.c, l = e.c, f = t.s, h = e.s, p = t.e, d = e.e;
  if (!f || !h) return null;
  if (r = u && !u[0], s = l && !l[0], r || s) return r ? s ? 0 : -h : f;
  if (f != h) return f;
  if (r = f < 0, s = p == d, !u || !l) return s ? 0 : !u ^ r ? 1 : -1;
  if (!s) return p > d ^ r ? 1 : -1;
  for (h = (p = u.length) < (d = l.length) ? p : d, f = 0; f < h; f++) if (u[f] != l[f]) return u[f] > l[f] ^ r ? 1 : -1;
  return p == d ? 0 : p > d ^ r ? 1 : -1;
}
function Xe(t, e, r, s) {
  if (t < e || t > r || t !== Qt(t))
    throw Error(Ot + (s || "Argument") + (typeof t == "number" ? t < e || t > r ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(t));
}
function Da(t) {
  var e = t.c.length - 1;
  return en(t.e / we) == e && t.c[e] % 2 != 0;
}
function Fa(t, e) {
  return (t.length > 1 ? t.charAt(0) + "." + t.slice(1) : t) + (e < 0 ? "e" : "e+") + e;
}
function nr(t, e, r) {
  var s, u;
  if (e < 0) {
    for (u = r + "."; ++e; u += r) ;
    t = u + t;
  } else if (s = t.length, ++e > s) {
    for (u = r, e -= s; --e; u += r) ;
    t += u;
  } else e < s && (t = t.slice(0, e) + "." + t.slice(e));
  return t;
}
var Hn = Mp();
var ZS = class {
  constructor(t) {
    __publicField(this, "key");
    __publicField(this, "left", null);
    __publicField(this, "right", null);
    this.key = t;
  }
};
var _s4 = class extends ZS {
  constructor(t) {
    super(t);
  }
};
var KS = class {
  constructor() {
    __publicField(this, "size", 0);
    __publicField(this, "modificationCount", 0);
    __publicField(this, "splayCount", 0);
  }
  splay(t) {
    const e = this.root;
    if (e == null)
      return this.compare(t, t), -1;
    let r = null, s = null, u = null, l = null, f = e;
    const h = this.compare;
    let p;
    for (; ; )
      if (p = h(f.key, t), p > 0) {
        let d = f.left;
        if (d == null || (p = h(d.key, t), p > 0 && (f.left = d.right, d.right = f, f = d, d = f.left, d == null)))
          break;
        r == null ? s = f : r.left = f, r = f, f = d;
      } else if (p < 0) {
        let d = f.right;
        if (d == null || (p = h(d.key, t), p < 0 && (f.right = d.left, d.left = f, f = d, d = f.right, d == null)))
          break;
        u == null ? l = f : u.right = f, u = f, f = d;
      } else
        break;
    return u != null && (u.right = f.left, f.left = l), r != null && (r.left = f.right, f.right = s), this.root !== f && (this.root = f, this.splayCount++), p;
  }
  splayMin(t) {
    let e = t, r = e.left;
    for (; r != null; ) {
      const s = r;
      e.left = s.right, s.right = e, e = s, r = e.left;
    }
    return e;
  }
  splayMax(t) {
    let e = t, r = e.right;
    for (; r != null; ) {
      const s = r;
      e.right = s.left, s.left = e, e = s, r = e.right;
    }
    return e;
  }
  _delete(t) {
    if (this.root == null || this.splay(t) != 0) return null;
    let r = this.root;
    const s = r, u = r.left;
    if (this.size--, u == null)
      this.root = r.right;
    else {
      const l = r.right;
      r = this.splayMax(u), r.right = l, this.root = r;
    }
    return this.modificationCount++, s;
  }
  addNewRoot(t, e) {
    this.size++, this.modificationCount++;
    const r = this.root;
    if (r == null) {
      this.root = t;
      return;
    }
    e < 0 ? (t.left = r, t.right = r.right, r.right = null) : (t.right = r, t.left = r.left, r.left = null), this.root = t;
  }
  _first() {
    const t = this.root;
    return t == null ? null : (this.root = this.splayMin(t), this.root);
  }
  _last() {
    const t = this.root;
    return t == null ? null : (this.root = this.splayMax(t), this.root);
  }
  clear() {
    this.root = null, this.size = 0, this.modificationCount++;
  }
  has(t) {
    return this.validKey(t) && this.splay(t) == 0;
  }
  defaultCompare() {
    return (t, e) => t < e ? -1 : t > e ? 1 : 0;
  }
  wrap() {
    return {
      getRoot: () => this.root,
      setRoot: (t) => {
        this.root = t;
      },
      getSize: () => this.size,
      getModificationCount: () => this.modificationCount,
      getSplayCount: () => this.splayCount,
      setSplayCount: (t) => {
        this.splayCount = t;
      },
      splay: (t) => this.splay(t),
      has: (t) => this.has(t)
    };
  }
};
var _a4, _b;
var fo = class Ts extends KS {
  constructor(e, r) {
    super();
    __publicField(this, "root", null);
    __publicField(this, "compare");
    __publicField(this, "validKey");
    __publicField(this, _a4, "[object Set]");
    this.compare = e ?? this.defaultCompare(), this.validKey = r ?? ((s) => s != null && s != null);
  }
  delete(e) {
    return this.validKey(e) ? this._delete(e) != null : false;
  }
  deleteAll(e) {
    for (const r of e)
      this.delete(r);
  }
  forEach(e) {
    const r = this[Symbol.iterator]();
    let s;
    for (; s = r.next(), !s.done; )
      e(s.value, s.value, this);
  }
  add(e) {
    const r = this.splay(e);
    return r != 0 && this.addNewRoot(new _s4(e), r), this;
  }
  addAndReturn(e) {
    const r = this.splay(e);
    return r != 0 && this.addNewRoot(new _s4(e), r), this.root.key;
  }
  addAll(e) {
    for (const r of e)
      this.add(r);
  }
  isEmpty() {
    return this.root == null;
  }
  isNotEmpty() {
    return this.root != null;
  }
  single() {
    if (this.size == 0) throw "Bad state: No element";
    if (this.size > 1) throw "Bad state: Too many element";
    return this.root.key;
  }
  first() {
    if (this.size == 0) throw "Bad state: No element";
    return this._first().key;
  }
  last() {
    if (this.size == 0) throw "Bad state: No element";
    return this._last().key;
  }
  lastBefore(e) {
    if (e == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(e) < 0) return this.root.key;
    let s = this.root.left;
    if (s == null) return null;
    let u = s.right;
    for (; u != null; )
      s = u, u = s.right;
    return s.key;
  }
  firstAfter(e) {
    if (e == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(e) > 0) return this.root.key;
    let s = this.root.right;
    if (s == null) return null;
    let u = s.left;
    for (; u != null; )
      s = u, u = s.left;
    return s.key;
  }
  retainAll(e) {
    const r = new Ts(this.compare, this.validKey), s = this.modificationCount;
    for (const u of e) {
      if (s != this.modificationCount)
        throw "Concurrent modification during iteration.";
      this.validKey(u) && this.splay(u) == 0 && r.add(this.root.key);
    }
    r.size != this.size && (this.root = r.root, this.size = r.size, this.modificationCount++);
  }
  lookup(e) {
    return !this.validKey(e) || this.splay(e) != 0 ? null : this.root.key;
  }
  intersection(e) {
    const r = new Ts(this.compare, this.validKey);
    for (const s of this)
      e.has(s) && r.add(s);
    return r;
  }
  difference(e) {
    const r = new Ts(this.compare, this.validKey);
    for (const s of this)
      e.has(s) || r.add(s);
    return r;
  }
  union(e) {
    const r = this.clone();
    return r.addAll(e), r;
  }
  clone() {
    const e = new Ts(this.compare, this.validKey);
    return e.size = this.size, e.root = this.copyNode(this.root), e;
  }
  copyNode(e) {
    if (e == null) return null;
    function r(u, l) {
      let f, h;
      do {
        if (f = u.left, h = u.right, f != null) {
          const p = new _s4(f.key);
          l.left = p, r(f, p);
        }
        if (h != null) {
          const p = new _s4(h.key);
          l.right = p, u = h, l = p;
        }
      } while (h != null);
    }
    const s = new _s4(e.key);
    return r(e, s), s;
  }
  toSet() {
    return this.clone();
  }
  entries() {
    return new eM(this.wrap());
  }
  keys() {
    return this[Symbol.iterator]();
  }
  values() {
    return this[Symbol.iterator]();
  }
  [(_b = Symbol.iterator, _a4 = Symbol.toStringTag, _b)]() {
    return new QS(this.wrap());
  }
};
var Ip = class {
  constructor(t) {
    __publicField(this, "tree");
    __publicField(this, "path", new Array());
    __publicField(this, "modificationCount", null);
    __publicField(this, "splayCount");
    this.tree = t, this.splayCount = t.getSplayCount();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    return this.moveNext() ? { done: false, value: this.current() } : { done: true, value: null };
  }
  current() {
    if (!this.path.length) return null;
    const t = this.path[this.path.length - 1];
    return this.getValue(t);
  }
  rebuildPath(t) {
    this.path.splice(0, this.path.length), this.tree.splay(t), this.path.push(this.tree.getRoot()), this.splayCount = this.tree.getSplayCount();
  }
  findLeftMostDescendent(t) {
    for (; t != null; )
      this.path.push(t), t = t.left;
  }
  moveNext() {
    if (this.modificationCount != this.tree.getModificationCount()) {
      if (this.modificationCount == null) {
        this.modificationCount = this.tree.getModificationCount();
        let r = this.tree.getRoot();
        for (; r != null; )
          this.path.push(r), r = r.left;
        return this.path.length > 0;
      }
      throw "Concurrent modification during iteration.";
    }
    if (!this.path.length) return false;
    this.splayCount != this.tree.getSplayCount() && this.rebuildPath(this.path[this.path.length - 1].key);
    let t = this.path[this.path.length - 1], e = t.right;
    if (e != null) {
      for (; e != null; )
        this.path.push(e), e = e.left;
      return true;
    }
    for (this.path.pop(); this.path.length && this.path[this.path.length - 1].right === t; )
      t = this.path.pop();
    return this.path.length > 0;
  }
};
var QS = class extends Ip {
  getValue(t) {
    return t.key;
  }
};
var eM = class extends Ip {
  getValue(t) {
    return [t.key, t.key];
  }
};
var bp = (t) => () => t;
var al = (t) => {
  const e = t ? (r, s) => s.minus(r).abs().isLessThanOrEqualTo(t) : bp(false);
  return (r, s) => e(r, s) ? 0 : r.comparedTo(s);
};
function tM(t) {
  const e = t ? (r, s, u, l, f) => r.exponentiatedBy(2).isLessThanOrEqualTo(
    l.minus(s).exponentiatedBy(2).plus(f.minus(u).exponentiatedBy(2)).times(t)
  ) : bp(false);
  return (r, s, u) => {
    const l = r.x, f = r.y, h = u.x, p = u.y, d = f.minus(p).times(s.x.minus(h)).minus(l.minus(h).times(s.y.minus(p)));
    return e(d, l, f, h, p) ? 0 : d.comparedTo(0);
  };
}
var nM = (t) => t;
var rM = (t) => {
  if (t) {
    const e = new fo(al(t)), r = new fo(al(t)), s = (l, f) => f.addAndReturn(l), u = (l) => ({
      x: s(l.x, e),
      y: s(l.y, r)
    });
    return u({ x: new Hn(0), y: new Hn(0) }), u;
  }
  return nM;
};
var ol = (t) => ({
  set: (e) => {
    gr = ol(e);
  },
  reset: () => ol(t),
  compare: al(t),
  snap: rM(t),
  orient: tM(t)
});
var gr = ol();
var Es = (t, e) => t.ll.x.isLessThanOrEqualTo(e.x) && e.x.isLessThanOrEqualTo(t.ur.x) && t.ll.y.isLessThanOrEqualTo(e.y) && e.y.isLessThanOrEqualTo(t.ur.y);
var ul = (t, e) => {
  if (e.ur.x.isLessThan(t.ll.x) || t.ur.x.isLessThan(e.ll.x) || e.ur.y.isLessThan(t.ll.y) || t.ur.y.isLessThan(e.ll.y))
    return null;
  const r = t.ll.x.isLessThan(e.ll.x) ? e.ll.x : t.ll.x, s = t.ur.x.isLessThan(e.ur.x) ? t.ur.x : e.ur.x, u = t.ll.y.isLessThan(e.ll.y) ? e.ll.y : t.ll.y, l = t.ur.y.isLessThan(e.ur.y) ? t.ur.y : e.ur.y;
  return { ll: { x: r, y: u }, ur: { x: s, y: l } };
};
var Xa = (t, e) => t.x.times(e.y).minus(t.y.times(e.x));
var Ap = (t, e) => t.x.times(e.x).plus(t.y.times(e.y));
var go = (t) => Ap(t, t).sqrt();
var iM = (t, e, r) => {
  const s = { x: e.x.minus(t.x), y: e.y.minus(t.y) }, u = { x: r.x.minus(t.x), y: r.y.minus(t.y) };
  return Xa(u, s).div(go(u)).div(go(s));
};
var sM = (t, e, r) => {
  const s = { x: e.x.minus(t.x), y: e.y.minus(t.y) }, u = { x: r.x.minus(t.x), y: r.y.minus(t.y) };
  return Ap(u, s).div(go(u)).div(go(s));
};
var Rf = (t, e, r) => e.y.isZero() ? null : { x: t.x.plus(e.x.div(e.y).times(r.minus(t.y))), y: r };
var Df = (t, e, r) => e.x.isZero() ? null : { x: r, y: t.y.plus(e.y.div(e.x).times(r.minus(t.x))) };
var aM = (t, e, r, s) => {
  if (e.x.isZero()) return Df(r, s, t.x);
  if (s.x.isZero()) return Df(t, e, r.x);
  if (e.y.isZero()) return Rf(r, s, t.y);
  if (s.y.isZero()) return Rf(t, e, r.y);
  const u = Xa(e, s);
  if (u.isZero()) return null;
  const l = { x: r.x.minus(t.x), y: r.y.minus(t.y) }, f = Xa(l, e).div(u), h = Xa(l, s).div(u), p = t.x.plus(h.times(e.x)), d = r.x.plus(f.times(s.x)), v = t.y.plus(h.times(e.y)), _ = r.y.plus(f.times(s.y)), E = p.plus(d).div(2), S = v.plus(_).div(2);
  return { x: E, y: S };
};
var Un = class Lp {
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(e, r) {
    __publicField(this, "point");
    __publicField(this, "isLeft");
    __publicField(this, "segment");
    __publicField(this, "otherSE");
    __publicField(this, "consumedBy");
    e.events === void 0 ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = r;
  }
  // for ordering sweep events in the sweep event queue
  static compare(e, r) {
    const s = Lp.comparePoints(e.point, r.point);
    return s !== 0 ? s : (e.point !== r.point && e.link(r), e.isLeft !== r.isLeft ? e.isLeft ? 1 : -1 : mo.compare(e.segment, r.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(e, r) {
    return e.x.isLessThan(r.x) ? -1 : e.x.isGreaterThan(r.x) ? 1 : e.y.isLessThan(r.y) ? -1 : e.y.isGreaterThan(r.y) ? 1 : 0;
  }
  link(e) {
    if (e.point === this.point)
      throw new Error("Tried to link already linked events");
    const r = e.point.events;
    for (let s = 0, u = r.length; s < u; s++) {
      const l = r[s];
      this.point.events.push(l), l.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const e = this.point.events.length;
    for (let r = 0; r < e; r++) {
      const s = this.point.events[r];
      if (s.segment.consumedBy === void 0)
        for (let u = r + 1; u < e; u++) {
          const l = this.point.events[u];
          l.consumedBy === void 0 && s.otherSE.point.events === l.otherSE.point.events && s.segment.consume(l.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const e = [];
    for (let r = 0, s = this.point.events.length; r < s; r++) {
      const u = this.point.events[r];
      u !== this && !u.segment.ringOut && u.segment.isInResult() && e.push(u);
    }
    return e;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(e) {
    const r = /* @__PURE__ */ new Map(), s = (u) => {
      const l = u.otherSE;
      r.set(u, {
        sine: iM(this.point, e.point, l.point),
        cosine: sM(this.point, e.point, l.point)
      });
    };
    return (u, l) => {
      r.has(u) || s(u), r.has(l) || s(l);
      const { sine: f, cosine: h } = r.get(u), { sine: p, cosine: d } = r.get(l);
      return f.isGreaterThanOrEqualTo(0) && p.isGreaterThanOrEqualTo(0) ? h.isLessThan(d) ? 1 : h.isGreaterThan(d) ? -1 : 0 : f.isLessThan(0) && p.isLessThan(0) ? h.isLessThan(d) ? -1 : h.isGreaterThan(d) ? 1 : 0 : p.isLessThan(f) ? -1 : p.isGreaterThan(f) ? 1 : 0;
    };
  }
};
var oM = class ll {
  constructor(e) {
    __publicField(this, "events");
    __publicField(this, "poly");
    __publicField(this, "_isExteriorRing");
    __publicField(this, "_enclosingRing");
    this.events = e;
    for (let r = 0, s = e.length; r < s; r++)
      e[r].segment.ringOut = this;
    this.poly = null;
  }
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(e) {
    const r = [];
    for (let s = 0, u = e.length; s < u; s++) {
      const l = e[s];
      if (!l.isInResult() || l.ringOut) continue;
      let f = null, h = l.leftSE, p = l.rightSE;
      const d = [h], v = h.point, _ = [];
      for (; f = h, h = p, d.push(h), h.point !== v; )
        for (; ; ) {
          const E = h.getAvailableLinkedEvents();
          if (E.length === 0) {
            const D = d[0].point, O = d[d.length - 1].point;
            throw new Error(
              `Unable to complete output ring starting at [${D.x}, ${D.y}]. Last matching segment found ends at [${O.x}, ${O.y}].`
            );
          }
          if (E.length === 1) {
            p = E[0].otherSE;
            break;
          }
          let S = null;
          for (let D = 0, O = _.length; D < O; D++)
            if (_[D].point === h.point) {
              S = D;
              break;
            }
          if (S !== null) {
            const D = _.splice(S)[0], O = d.splice(D.index);
            O.unshift(O[0].otherSE), r.push(new ll(O.reverse()));
            continue;
          }
          _.push({
            index: d.length,
            point: h.point
          });
          const I = h.getLeftmostComparator(f);
          p = E.sort(I)[0].otherSE;
          break;
        }
      r.push(new ll(d));
    }
    return r;
  }
  getGeom() {
    let e = this.events[0].point;
    const r = [e];
    for (let d = 1, v = this.events.length - 1; d < v; d++) {
      const _ = this.events[d].point, E = this.events[d + 1].point;
      gr.orient(_, e, E) !== 0 && (r.push(_), e = _);
    }
    if (r.length === 1) return null;
    const s = r[0], u = r[1];
    gr.orient(s, e, u) === 0 && r.shift(), r.push(r[0]);
    const l = this.isExteriorRing() ? 1 : -1, f = this.isExteriorRing() ? 0 : r.length - 1, h = this.isExteriorRing() ? r.length : -1, p = [];
    for (let d = f; d != h; d += l)
      p.push([r[d].x.toNumber(), r[d].y.toNumber()]);
    return p;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const e = this.enclosingRing();
      this._isExteriorRing = e ? !e.isExteriorRing() : true;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    var _a6, _b2;
    let e = this.events[0];
    for (let u = 1, l = this.events.length; u < l; u++) {
      const f = this.events[u];
      Un.compare(e, f) > 0 && (e = f);
    }
    let r = e.segment.prevInResult(), s = r ? r.prevInResult() : null;
    for (; ; ) {
      if (!r) return null;
      if (!s) return r.ringOut;
      if (s.ringOut !== r.ringOut)
        return ((_a6 = s.ringOut) == null ? void 0 : _a6.enclosingRing()) !== r.ringOut ? r.ringOut : (_b2 = r.ringOut) == null ? void 0 : _b2.enclosingRing();
      r = s.prevInResult(), s = r ? r.prevInResult() : null;
    }
  }
};
var Ff = class {
  constructor(t) {
    __publicField(this, "exteriorRing");
    __publicField(this, "interiorRings");
    this.exteriorRing = t, t.poly = this, this.interiorRings = [];
  }
  addInterior(t) {
    this.interiorRings.push(t), t.poly = this;
  }
  getGeom() {
    const t = this.exteriorRing.getGeom();
    if (t === null) return null;
    const e = [t];
    for (let r = 0, s = this.interiorRings.length; r < s; r++) {
      const u = this.interiorRings[r].getGeom();
      u !== null && e.push(u);
    }
    return e;
  }
};
var uM = class {
  constructor(t) {
    __publicField(this, "rings");
    __publicField(this, "polys");
    this.rings = t, this.polys = this._composePolys(t);
  }
  getGeom() {
    const t = [];
    for (let e = 0, r = this.polys.length; e < r; e++) {
      const s = this.polys[e].getGeom();
      s !== null && t.push(s);
    }
    return t;
  }
  _composePolys(t) {
    var _a6;
    const e = [];
    for (let r = 0, s = t.length; r < s; r++) {
      const u = t[r];
      if (!u.poly)
        if (u.isExteriorRing()) e.push(new Ff(u));
        else {
          const l = u.enclosingRing();
          (l == null ? void 0 : l.poly) || e.push(new Ff(l)), (_a6 = l == null ? void 0 : l.poly) == null ? void 0 : _a6.addInterior(u);
        }
    }
    return e;
  }
};
var lM = class {
  constructor(t, e = mo.compare) {
    __publicField(this, "queue");
    __publicField(this, "tree");
    __publicField(this, "segments");
    this.queue = t, this.tree = new fo(e), this.segments = [];
  }
  process(t) {
    const e = t.segment, r = [];
    if (t.consumedBy)
      return t.isLeft ? this.queue.delete(t.otherSE) : this.tree.delete(e), r;
    t.isLeft && this.tree.add(e);
    let s = e, u = e;
    do
      s = this.tree.lastBefore(s);
    while (s != null && s.consumedBy != null);
    do
      u = this.tree.firstAfter(u);
    while (u != null && u.consumedBy != null);
    if (t.isLeft) {
      let l = null;
      if (s) {
        const h = s.getIntersection(e);
        if (h !== null && (e.isAnEndpoint(h) || (l = h), !s.isAnEndpoint(h))) {
          const p = this._splitSafely(s, h);
          for (let d = 0, v = p.length; d < v; d++)
            r.push(p[d]);
        }
      }
      let f = null;
      if (u) {
        const h = u.getIntersection(e);
        if (h !== null && (e.isAnEndpoint(h) || (f = h), !u.isAnEndpoint(h))) {
          const p = this._splitSafely(u, h);
          for (let d = 0, v = p.length; d < v; d++)
            r.push(p[d]);
        }
      }
      if (l !== null || f !== null) {
        let h = null;
        l === null ? h = f : f === null ? h = l : h = Un.comparePoints(
          l,
          f
        ) <= 0 ? l : f, this.queue.delete(e.rightSE), r.push(e.rightSE);
        const p = e.split(h);
        for (let d = 0, v = p.length; d < v; d++)
          r.push(p[d]);
      }
      r.length > 0 ? (this.tree.delete(e), r.push(t)) : (this.segments.push(e), e.prev = s);
    } else {
      if (s && u) {
        const l = s.getIntersection(u);
        if (l !== null) {
          if (!s.isAnEndpoint(l)) {
            const f = this._splitSafely(s, l);
            for (let h = 0, p = f.length; h < p; h++)
              r.push(f[h]);
          }
          if (!u.isAnEndpoint(l)) {
            const f = this._splitSafely(u, l);
            for (let h = 0, p = f.length; h < p; h++)
              r.push(f[h]);
          }
        }
      }
      this.tree.delete(e);
    }
    return r;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(t, e) {
    this.tree.delete(t);
    const r = t.rightSE;
    this.queue.delete(r);
    const s = t.split(e);
    return s.push(r), t.consumedBy === void 0 && this.tree.add(t), s;
  }
};
var cM = class {
  constructor() {
    __publicField(this, "type");
    __publicField(this, "numMultiPolys");
  }
  run(t, e, r) {
    Cs.type = t;
    const s = [new Bf(e, true)];
    for (let d = 0, v = r.length; d < v; d++)
      s.push(new Bf(r[d], false));
    if (Cs.numMultiPolys = s.length, Cs.type === "difference") {
      const d = s[0];
      let v = 1;
      for (; v < s.length; )
        ul(s[v].bbox, d.bbox) !== null ? v++ : s.splice(v, 1);
    }
    if (Cs.type === "intersection")
      for (let d = 0, v = s.length; d < v; d++) {
        const _ = s[d];
        for (let E = d + 1, S = s.length; E < S; E++)
          if (ul(_.bbox, s[E].bbox) === null) return [];
      }
    const u = new fo(Un.compare);
    for (let d = 0, v = s.length; d < v; d++) {
      const _ = s[d].getSweepEvents();
      for (let E = 0, S = _.length; E < S; E++)
        u.add(_[E]);
    }
    const l = new lM(u);
    let f = null;
    for (u.size != 0 && (f = u.first(), u.delete(f)); f; ) {
      const d = l.process(f);
      for (let v = 0, _ = d.length; v < _; v++) {
        const E = d[v];
        E.consumedBy === void 0 && u.add(E);
      }
      u.size != 0 ? (f = u.first(), u.delete(f)) : f = null;
    }
    gr.reset();
    const h = oM.factory(l.segments);
    return new uM(h).getGeom();
  }
};
var Cs = new cM();
var po = Cs;
var hM = 0;
var mo = class Wa {
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(e, r, s, u) {
    __publicField(this, "id");
    __publicField(this, "leftSE");
    __publicField(this, "rightSE");
    __publicField(this, "rings");
    __publicField(this, "windings");
    __publicField(this, "ringOut");
    __publicField(this, "consumedBy");
    __publicField(this, "prev");
    __publicField(this, "_prevInResult");
    __publicField(this, "_beforeState");
    __publicField(this, "_afterState");
    __publicField(this, "_isInResult");
    this.id = ++hM, this.leftSE = e, e.segment = this, e.otherSE = r, this.rightSE = r, r.segment = this, r.otherSE = e, this.rings = s, this.windings = u;
  }
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(e, r) {
    const s = e.leftSE.point.x, u = r.leftSE.point.x, l = e.rightSE.point.x, f = r.rightSE.point.x;
    if (f.isLessThan(s)) return 1;
    if (l.isLessThan(u)) return -1;
    const h = e.leftSE.point.y, p = r.leftSE.point.y, d = e.rightSE.point.y, v = r.rightSE.point.y;
    if (s.isLessThan(u)) {
      if (p.isLessThan(h) && p.isLessThan(d)) return 1;
      if (p.isGreaterThan(h) && p.isGreaterThan(d)) return -1;
      const _ = e.comparePoint(r.leftSE.point);
      if (_ < 0) return 1;
      if (_ > 0) return -1;
      const E = r.comparePoint(e.rightSE.point);
      return E !== 0 ? E : -1;
    }
    if (s.isGreaterThan(u)) {
      if (h.isLessThan(p) && h.isLessThan(v)) return -1;
      if (h.isGreaterThan(p) && h.isGreaterThan(v)) return 1;
      const _ = r.comparePoint(e.leftSE.point);
      if (_ !== 0) return _;
      const E = e.comparePoint(r.rightSE.point);
      return E < 0 ? 1 : E > 0 ? -1 : 1;
    }
    if (h.isLessThan(p)) return -1;
    if (h.isGreaterThan(p)) return 1;
    if (l.isLessThan(f)) {
      const _ = r.comparePoint(e.rightSE.point);
      if (_ !== 0) return _;
    }
    if (l.isGreaterThan(f)) {
      const _ = e.comparePoint(r.rightSE.point);
      if (_ < 0) return 1;
      if (_ > 0) return -1;
    }
    if (!l.eq(f)) {
      const _ = d.minus(h), E = l.minus(s), S = v.minus(p), I = f.minus(u);
      if (_.isGreaterThan(E) && S.isLessThan(I)) return 1;
      if (_.isLessThan(E) && S.isGreaterThan(I)) return -1;
    }
    return l.isGreaterThan(f) ? 1 : l.isLessThan(f) || d.isLessThan(v) ? -1 : d.isGreaterThan(v) ? 1 : e.id < r.id ? -1 : e.id > r.id ? 1 : 0;
  }
  static fromRing(e, r, s) {
    let u, l, f;
    const h = Un.comparePoints(e, r);
    if (h < 0)
      u = e, l = r, f = 1;
    else if (h > 0)
      u = r, l = e, f = -1;
    else
      throw new Error(
        `Tried to create degenerate segment at [${e.x}, ${e.y}]`
      );
    const p = new Un(u, true), d = new Un(l, false);
    return new Wa(p, d, [s], [f]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(e) {
    this.rightSE = e, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const e = this.leftSE.point.y, r = this.rightSE.point.y;
    return {
      ll: { x: this.leftSE.point.x, y: e.isLessThan(r) ? e : r },
      ur: { x: this.rightSE.point.x, y: e.isGreaterThan(r) ? e : r }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x.minus(this.leftSE.point.x),
      y: this.rightSE.point.y.minus(this.leftSE.point.y)
    };
  }
  isAnEndpoint(e) {
    return e.x.eq(this.leftSE.point.x) && e.y.eq(this.leftSE.point.y) || e.x.eq(this.rightSE.point.x) && e.y.eq(this.rightSE.point.y);
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(e) {
    return gr.orient(this.leftSE.point, e, this.rightSE.point);
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(e) {
    const r = this.bbox(), s = e.bbox(), u = ul(r, s);
    if (u === null) return null;
    const l = this.leftSE.point, f = this.rightSE.point, h = e.leftSE.point, p = e.rightSE.point, d = Es(r, h) && this.comparePoint(h) === 0, v = Es(s, l) && e.comparePoint(l) === 0, _ = Es(r, p) && this.comparePoint(p) === 0, E = Es(s, f) && e.comparePoint(f) === 0;
    if (v && d)
      return E && !_ ? f : !E && _ ? p : null;
    if (v)
      return _ && l.x.eq(p.x) && l.y.eq(p.y) ? null : l;
    if (d)
      return E && f.x.eq(h.x) && f.y.eq(h.y) ? null : h;
    if (E && _) return null;
    if (E) return f;
    if (_) return p;
    const S = aM(l, this.vector(), h, e.vector());
    return S === null || !Es(u, S) ? null : gr.snap(S);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(e) {
    const r = [], s = e.events !== void 0, u = new Un(e, true), l = new Un(e, false), f = this.rightSE;
    this.replaceRightSE(l), r.push(l), r.push(u);
    const h = new Wa(
      u,
      f,
      this.rings.slice(),
      this.windings.slice()
    );
    return Un.comparePoints(h.leftSE.point, h.rightSE.point) > 0 && h.swapEvents(), Un.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), s && (u.checkForConsuming(), l.checkForConsuming()), r;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const e = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = e, this.leftSE.isLeft = true, this.rightSE.isLeft = false;
    for (let r = 0, s = this.windings.length; r < s; r++)
      this.windings[r] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(e) {
    let r = this, s = e;
    for (; r.consumedBy; ) r = r.consumedBy;
    for (; s.consumedBy; ) s = s.consumedBy;
    const u = Wa.compare(r, s);
    if (u !== 0) {
      if (u > 0) {
        const l = r;
        r = s, s = l;
      }
      if (r.prev === s) {
        const l = r;
        r = s, s = l;
      }
      for (let l = 0, f = s.rings.length; l < f; l++) {
        const h = s.rings[l], p = s.windings[l], d = r.rings.indexOf(h);
        d === -1 ? (r.rings.push(h), r.windings.push(p)) : r.windings[d] += p;
      }
      s.rings = null, s.windings = null, s.consumedBy = r, s.leftSE.consumedBy = r.leftSE, s.rightSE.consumedBy = r.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev)
      this._beforeState = {
        rings: [],
        windings: [],
        multiPolys: []
      };
    else {
      const e = this.prev.consumedBy || this.prev;
      this._beforeState = e.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const e = this.beforeState();
    this._afterState = {
      rings: e.rings.slice(0),
      windings: e.windings.slice(0),
      multiPolys: []
    };
    const r = this._afterState.rings, s = this._afterState.windings, u = this._afterState.multiPolys;
    for (let h = 0, p = this.rings.length; h < p; h++) {
      const d = this.rings[h], v = this.windings[h], _ = r.indexOf(d);
      _ === -1 ? (r.push(d), s.push(v)) : s[_] += v;
    }
    const l = [], f = [];
    for (let h = 0, p = r.length; h < p; h++) {
      if (s[h] === 0) continue;
      const d = r[h], v = d.poly;
      if (f.indexOf(v) === -1)
        if (d.isExterior) l.push(v);
        else {
          f.indexOf(v) === -1 && f.push(v);
          const _ = l.indexOf(d.poly);
          _ !== -1 && l.splice(_, 1);
        }
    }
    for (let h = 0, p = l.length; h < p; h++) {
      const d = l[h].multiPoly;
      u.indexOf(d) === -1 && u.push(d);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return false;
    if (this._isInResult !== void 0) return this._isInResult;
    const e = this.beforeState().multiPolys, r = this.afterState().multiPolys;
    switch (po.type) {
      case "union": {
        const s = e.length === 0, u = r.length === 0;
        this._isInResult = s !== u;
        break;
      }
      case "intersection": {
        let s, u;
        e.length < r.length ? (s = e.length, u = r.length) : (s = r.length, u = e.length), this._isInResult = u === po.numMultiPolys && s < u;
        break;
      }
      case "xor": {
        const s = Math.abs(e.length - r.length);
        this._isInResult = s % 2 === 1;
        break;
      }
      case "difference": {
        const s = (u) => u.length === 1 && u[0].isSubject;
        this._isInResult = s(e) !== s(r);
        break;
      }
    }
    return this._isInResult;
  }
};
var Gf = class {
  constructor(t, e, r) {
    __publicField(this, "poly");
    __publicField(this, "isExterior");
    __publicField(this, "segments");
    __publicField(this, "bbox");
    if (!Array.isArray(t) || t.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = e, this.isExterior = r, this.segments = [], typeof t[0][0] != "number" || typeof t[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const s = gr.snap({ x: new Hn(t[0][0]), y: new Hn(t[0][1]) });
    this.bbox = {
      ll: { x: s.x, y: s.y },
      ur: { x: s.x, y: s.y }
    };
    let u = s;
    for (let l = 1, f = t.length; l < f; l++) {
      if (typeof t[l][0] != "number" || typeof t[l][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      const h = gr.snap({ x: new Hn(t[l][0]), y: new Hn(t[l][1]) });
      h.x.eq(u.x) && h.y.eq(u.y) || (this.segments.push(mo.fromRing(u, h, this)), h.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = h.x), h.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = h.y), h.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = h.x), h.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = h.y), u = h);
    }
    (!s.x.eq(u.x) || !s.y.eq(u.y)) && this.segments.push(mo.fromRing(u, s, this));
  }
  getSweepEvents() {
    const t = [];
    for (let e = 0, r = this.segments.length; e < r; e++) {
      const s = this.segments[e];
      t.push(s.leftSE), t.push(s.rightSE);
    }
    return t;
  }
};
var fM = class {
  constructor(t, e) {
    __publicField(this, "multiPoly");
    __publicField(this, "exteriorRing");
    __publicField(this, "interiorRings");
    __publicField(this, "bbox");
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new Gf(t[0], this, true), this.bbox = {
      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }
    }, this.interiorRings = [];
    for (let r = 1, s = t.length; r < s; r++) {
      const u = new Gf(t[r], this, false);
      u.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = u.bbox.ll.x), u.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = u.bbox.ll.y), u.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = u.bbox.ur.x), u.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = u.bbox.ur.y), this.interiorRings.push(u);
    }
    this.multiPoly = e;
  }
  getSweepEvents() {
    const t = this.exteriorRing.getSweepEvents();
    for (let e = 0, r = this.interiorRings.length; e < r; e++) {
      const s = this.interiorRings[e].getSweepEvents();
      for (let u = 0, l = s.length; u < l; u++)
        t.push(s[u]);
    }
    return t;
  }
};
var Bf = class {
  constructor(t, e) {
    __publicField(this, "isSubject");
    __publicField(this, "polys");
    __publicField(this, "bbox");
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof t[0][0][0] == "number" && (t = [t]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: { x: new Hn(Number.POSITIVE_INFINITY), y: new Hn(Number.POSITIVE_INFINITY) },
      ur: { x: new Hn(Number.NEGATIVE_INFINITY), y: new Hn(Number.NEGATIVE_INFINITY) }
    };
    for (let r = 0, s = t.length; r < s; r++) {
      const u = new fM(t[r], this);
      u.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = u.bbox.ll.x), u.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = u.bbox.ll.y), u.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = u.bbox.ur.x), u.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = u.bbox.ur.y), this.polys.push(u);
    }
    this.isSubject = e;
  }
  getSweepEvents() {
    const t = [];
    for (let e = 0, r = this.polys.length; e < r; e++) {
      const s = this.polys[e].getSweepEvents();
      for (let u = 0, l = s.length; u < l; u++)
        t.push(s[u]);
    }
    return t;
  }
};
var gM = (t, ...e) => po.run("union", t, e);
var dM = (t, ...e) => po.run("difference", t, e);
gr.set;
function pM(t) {
  const e = [];
  if (Rr(t, (u) => {
    e.push(u.coordinates);
  }), e.length < 2)
    throw new Error("Must have at least two features");
  const r = t.features[0].properties || {}, s = dM(e[0], ...e.slice(1));
  return s.length === 0 ? null : s.length === 1 ? fr(s[0], r) : Bl(s, r);
}
var Tp = pM;
function Cp(t) {
  var e = new tn(t);
  return e.insert = function(r) {
    if (r.type !== "Feature") throw new Error("invalid feature");
    return r.bbox = r.bbox ? r.bbox : ir(r), tn.prototype.insert.call(this, r);
  }, e.load = function(r) {
    var s = [];
    return Array.isArray(r) ? r.forEach(function(u) {
      if (u.type !== "Feature") throw new Error("invalid features");
      u.bbox = u.bbox ? u.bbox : ir(u), s.push(u);
    }) : Xn(r, function(u) {
      if (u.type !== "Feature") throw new Error("invalid features");
      u.bbox = u.bbox ? u.bbox : ir(u), s.push(u);
    }), tn.prototype.load.call(this, s);
  }, e.remove = function(r, s) {
    if (r.type !== "Feature") throw new Error("invalid feature");
    return r.bbox = r.bbox ? r.bbox : ir(r), tn.prototype.remove.call(this, r, s);
  }, e.clear = function() {
    return tn.prototype.clear.call(this);
  }, e.search = function(r) {
    var s = tn.prototype.search.call(this, this.toBBox(r));
    return nt(s);
  }, e.collides = function(r) {
    return tn.prototype.collides.call(this, this.toBBox(r));
  }, e.all = function() {
    var r = tn.prototype.all.call(this);
    return nt(r);
  }, e.toJSON = function() {
    return tn.prototype.toJSON.call(this);
  }, e.fromJSON = function(r) {
    return tn.prototype.fromJSON.call(this, r);
  }, e.toBBox = function(r) {
    var s;
    if (r.bbox) s = r.bbox;
    else if (Array.isArray(r) && r.length === 4) s = r;
    else if (Array.isArray(r) && r.length === 6)
      s = [r[0], r[1], r[3], r[4]];
    else if (r.type === "Feature") s = ir(r);
    else if (r.type === "FeatureCollection") s = ir(r);
    else throw new Error("invalid geojson");
    return {
      minX: s[0],
      minY: s[1],
      maxX: s[2],
      maxY: s[3]
    };
  }, e;
}
function mM(t, e) {
  if (e = e ?? {}, !Lo(e)) throw new Error("options is invalid");
  var r = e.precision, s = e.coordinates, u = e.mutate;
  if (r = r == null || isNaN(r) ? 6 : r, s = s == null || isNaN(s) ? 3 : s, !t) throw new Error("<geojson> is required");
  if (typeof r != "number")
    throw new Error("<precision> must be a number");
  if (typeof s != "number")
    throw new Error("<coordinates> must be a number");
  (u === false || u === void 0) && (t = JSON.parse(JSON.stringify(t)));
  var l = Math.pow(10, r);
  return Or(t, function(f) {
    vM(f, l, s);
  }), t;
}
function vM(t, e, r) {
  t.length > r && t.splice(r, t.length);
  for (var s = 0; s < t.length; s++)
    t[s] = Math.round(t[s] * e) / e;
  return t;
}
function yM(t) {
  if (!t)
    throw new Error("geojson is required");
  const e = [];
  return Pr(t, (r) => {
    _M(r, e);
  }), nt(e);
}
function _M(t, e) {
  let r = [];
  const s = t.geometry;
  if (s !== null) {
    switch (s.type) {
      case "Polygon":
        r = Ht(s);
        break;
      case "LineString":
        r = [Ht(s)];
    }
    r.forEach((u) => {
      EM(u, t.properties).forEach((f) => {
        f.id = e.length, e.push(f);
      });
    });
  }
}
function EM(t, e) {
  const r = [];
  return t.reduce((s, u) => {
    const l = Nr([s, u], e);
    return l.bbox = xM(s, u), r.push(l), u;
  }), r;
}
function xM(t, e) {
  const r = t[0], s = t[1], u = e[0], l = e[1], f = r < u ? r : u, h = s < l ? s : l, p = r > u ? r : u, d = s > l ? s : l;
  return [f, h, p, d];
}
var wM = Object.defineProperty;
var kM = Object.defineProperties;
var SM = Object.getOwnPropertyDescriptors;
var Uf = Object.getOwnPropertySymbols;
var MM = Object.prototype.hasOwnProperty;
var IM = Object.prototype.propertyIsEnumerable;
var zf = (t, e, r) => e in t ? wM(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r;
var qf = (t, e) => {
  for (var r in e || (e = {}))
    MM.call(e, r) && zf(t, r, e[r]);
  if (Uf)
    for (var r of Uf(e))
      IM.call(e, r) && zf(t, r, e[r]);
  return t;
};
var Yf = (t, e) => kM(t, SM(e));
function bM(t, e, r = {}) {
  if (!t || !e)
    throw new Error("lines and pt are required arguments");
  const s = tt(e);
  let u = En([1 / 0, 1 / 0], {
    dist: 1 / 0,
    index: -1,
    multiFeatureIndex: -1,
    location: -1
  }), l = 0;
  return Pr(
    t,
    function(f, h, p) {
      const d = Ht(f);
      for (let v = 0; v < d.length - 1; v++) {
        const _ = En(d[v]), E = tt(_), S = En(d[v + 1]), I = tt(S), D = Zr(_, S, r);
        let O, T;
        I[0] === s[0] && I[1] === s[1] ? [O, T] = [I, true] : E[0] === s[0] && E[1] === s[1] ? [O, T] = [E, false] : [O, T] = TM(
          E,
          I,
          s
        );
        const M = En(O, {
          dist: Zr(e, O, r),
          multiFeatureIndex: p,
          location: l + Zr(_, O, r)
        });
        M.properties.dist < u.properties.dist && (u = Yf(qf({}, M), {
          properties: Yf(qf({}, M.properties), {
            // Legacy behaviour where index progresses to next segment # if we
            // went with the end point this iteration.
            index: T ? v + 1 : v
          })
        })), l += D;
      }
    }
  ), u;
}
function Vr(t, e) {
  const [r, s, u] = t, [l, f, h] = e;
  return r * l + s * f + u * h;
}
function xs(t, e) {
  const [r, s, u] = t, [l, f, h] = e;
  return [s * h - u * f, u * l - r * h, r * f - s * l];
}
function AM(t) {
  return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2));
}
function Hf(t) {
  const e = AM(t);
  return [t[0] / e, t[1] / e, t[2] / e];
}
function Eu(t) {
  const e = lt(t[1]), r = lt(t[0]);
  return [
    Math.cos(e) * Math.cos(r),
    Math.cos(e) * Math.sin(r),
    Math.sin(e)
  ];
}
function LM(t) {
  const [e, r, s] = t, u = Math.min(Math.max(s, -1), 1), l = ri(Math.asin(u));
  return [ri(Math.atan2(r, e)), l];
}
function TM(t, e, r) {
  const s = Eu(t), u = Eu(e), l = Eu(r), f = xs(s, u);
  if (f[0] === 0 && f[1] === 0 && f[2] === 0)
    return Vr(s, u) > 0 ? [[...e], true] : [[...r], false];
  const h = xs(f, l);
  if (h[0] === 0 && h[1] === 0 && h[2] === 0)
    return [[...e], true];
  const p = xs(h, f), d = Hf(p), v = [-d[0], -d[1], -d[2]], _ = Vr(l, d) > Vr(l, v) ? d : v, E = Hf(f), S = Vr(xs(s, _), E), I = Vr(xs(_, u), E);
  return S >= 0 && I >= 0 ? [LM(_), false] : Vr(s, l) > Vr(u, l) ? [[...t], false] : [[...e], true];
}
function CM(t, e) {
  if (!t) throw new Error("line is required");
  if (!e) throw new Error("splitter is required");
  var r = $h(t), s = $h(e);
  if (r !== "LineString") throw new Error("line must be LineString");
  if (s === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (s === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");
  var u = mM(e, { precision: 7 });
  switch (s) {
    case "Point":
      return cl(t, u);
    case "MultiPoint":
      return Jf(t, u);
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return Jf(
        t,
        ua(t, u, {
          ignoreSelfIntersections: true
        })
      );
  }
}
function Jf(t, e) {
  var r = [], s = Cp();
  return Pr(e, function(u) {
    if (r.forEach(function(h, p) {
      h.id = p;
    }), !r.length)
      r = cl(t, u).features, s.load(nt(r));
    else {
      var l = s.search(u);
      if (l.features.length) {
        var f = Np(u, l);
        r = r.filter(function(h) {
          return h.id !== f.id;
        }), s.remove(f), Xn(cl(f, u), function(h) {
          r.push(h), s.insert(h);
        });
      }
    }
  }), nt(r);
}
function cl(t, e) {
  var r = [], s = Ht(t)[0], u = Ht(t)[t.geometry.coordinates.length - 1];
  if (xu(s, tt(e)) || xu(u, tt(e)))
    return nt([t]);
  var l = Cp(), f = yM(t);
  l.load(f);
  var h = l.search(e);
  if (!h.features.length) return nt([t]);
  var p = Np(e, h), d = [s], v = mk(
    f,
    function(_, E, S) {
      var I = Ht(E)[1], D = tt(e);
      return S === p.id ? (_.push(D), r.push(Nr(_)), xu(D, I) ? [D] : [D, I]) : (_.push(I), _);
    },
    d
  );
  return v.length > 1 && r.push(Nr(v)), nt(r);
}
function Np(t, e) {
  if (!e.features.length) throw new Error("lines must contain features");
  if (e.features.length === 1) return e.features[0];
  var r, s = 1 / 0;
  return Xn(e, function(u) {
    var l = bM(u, t), f = l.properties.dist;
    f < s && (r = u, s = f);
  }), r;
}
function xu(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}
var $f = CM;
var NM = class extends ts {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "cut");
    __publicField(this, "lineDrawer", new ec(this.gm, { snappingMarkers: "first", targetShape: "polygon" }));
    __publicField(this, "cutShapesAllowed", ["circle", "ellipse", "line", "rectangle", "polygon"]);
    __publicField(this, "eventHandlers", {
      [`${se}:draw`]: this.forwardLineDrawerEvent.bind(this),
      mousemove: this.onMouseMove.bind(this)
    });
  }
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on("firstMarkerClick", this.cutPolygonFinished.bind(this));
  }
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onMouseMove(e) {
    return Ke(e) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: true }) : { next: true };
  }
  cutPolygonFinished(e) {
    this.lineDrawer.endShape();
    const r = Ql(e.geoJson), s = this.getBBoxFeaturesByPolygon(r);
    this.cutFeaturesByPolygon(s, r);
  }
  getBBoxFeaturesByPolygon(e) {
    const r = $l(e), s = this.gm.mapAdapter.coordBoundsToScreenBounds(r);
    return this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: s,
      sourceNames: [K.main]
    });
  }
  cutFeaturesByPolygon(e, r) {
    e.forEach((s) => {
      if (s.getShapeProperty("disableEdit") !== true) {
        if (Ra(s.getGeoJson(), r)) {
          this.gm.features.delete(s), this.fireFeatureRemovedEvent(s);
          return;
        }
        if (Sp(s.getGeoJson(), r) && this.cutShapesAllowed.includes(s.shape)) {
          if (s.shape === "line") {
            this.cutLineFeatureByPolygon(s, r);
            return;
          }
          this.cutPolygonFeatureByPolygon(s.id, r);
        }
      }
    });
  }
  cutLineFeatureByPolygon(e, r) {
    const s = e.getGeoJson(), u = DS(this.gm.mapAdapter, r);
    let l = false, f = [];
    if (u) {
      if (s.geometry.type === "MultiLineString")
        s.geometry.coordinates.forEach((h) => {
          if (Ra(Nr(h), r))
            return;
          const p = $f(Nr(h), r);
          if (p.features.length === 0) {
            f.push(h);
            return;
          }
          p.features.filter((d) => !Ra(d, u)).forEach((d) => {
            l = true, f.push(d.geometry.coordinates);
          });
        });
      else if (s.geometry.type === "LineString") {
        const h = $f(s, r);
        f = h.features.filter(
          (p) => !Ra(p, u) && p.geometry.type === "LineString"
        ).map((p) => p.geometry.coordinates), h.features.length > 0 && (l = true);
      }
      l && f.length && (f.length === 1 ? e.updateGeoJsonGeometry({ type: "LineString", coordinates: f[0] }) : e.updateGeoJsonGeometry({ type: "MultiLineString", coordinates: f }), this.fireFeatureUpdatedEvent({
        sourceFeatures: [e],
        targetFeatures: [e]
      }));
    }
  }
  cutPolygonFeatureByPolygon(e, r) {
    const s = this.gm.features.get(K.main, e);
    if (!s) {
      te.warn("cutPolygonFeatureByPolygon: featureData not found", e);
      return;
    }
    s.convertToPolygon();
    const u = s.getGeoJson(), l = this.getGeoJsonDifference(u, r);
    l && (s.updateGeoJsonGeometry(l.geometry), this.fireFeatureUpdatedEvent({
      sourceFeatures: [s],
      targetFeatures: [s]
    }));
  }
  getGeoJsonDifference(e, r) {
    const s = nt([e, r]), u = Tp(s);
    return u ? u.type === "Feature" ? u : (u.type === "FeatureCollection" && te.error("getGeoJsonDifference: FeatureCollection detected (not supported)", u), null) : null;
  }
};
var PM = class extends ts {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "delete");
    __publicField(this, "allowedShapes", [...or]);
    __publicField(this, "eventHandlers", {
      click: this.onMouseClick.bind(this)
    });
  }
  onStartAction() {
    this.gm.markerPointer.enable({ invisibleMarker: true }), this.gm.markerPointer.pauseSnapping();
  }
  onEndAction() {
    this.gm.markerPointer.resumeSnapping(), this.gm.markerPointer.disable();
  }
  onMouseClick(e) {
    if (!Ke(e, { warning: true }))
      return { next: false };
    const r = this.getFeatureByMouseEvent({ event: e, sourceNames: [K.main] });
    return r && this.allowedShapes.includes(r.shape) && (this.gm.features.delete(r), this.fireFeatureRemovedEvent(r)), { next: false };
  }
};
var OM = class extends nc {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "drag");
  }
  onStartAction() {
  }
  onEndAction() {
  }
  handleGmEdit(e) {
    return es(e) ? e.action === "marker_move" && e.lngLatStart && e.lngLatEnd ? (this.previousLngLat || (this.previousLngLat = e.lngLatStart), this.moveFeature(e.featureData, e.lngLatEnd), { next: false }) : (e.action === "marker_captured" ? (e.featureData.changeSource({ sourceName: K.temporary, atomic: true }), this.flags.actionInProgress = true, this.fireFeatureEditStartEvent({ feature: e.featureData }), this.setCursorToPointer()) : e.action === "marker_released" && (this.previousLngLat = null, e.featureData.changeSource({ sourceName: K.main, atomic: true }), this.fireFeatureEditEndEvent({ feature: e.featureData }), this.flags.actionInProgress = false), { next: true }) : (te.error("EditDrag.handleGmEdit: not an edit event", e), { next: true });
  }
};
var RM = class extends nc {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "rotate");
    __publicField(this, "allowedShapes", ["line", "rectangle", "polygon", "ellipse"]);
    __publicField(this, "convertFeaturesTypes", ["rectangle"]);
    __publicField(this, "shapeRotateHandlers", {
      marker: this.rotateFeature.bind(this),
      circle: this.rotateFeature.bind(this),
      circle_marker: this.rotateFeature.bind(this),
      text_marker: this.rotateFeature.bind(this),
      line: this.rotateFeature.bind(this),
      rectangle: this.rotateFeature.bind(this),
      polygon: this.rotateFeature.bind(this),
      ellipse: this.rotateEllipse.bind(this)
    });
  }
  onStartAction() {
  }
  onEndAction() {
  }
  handleGmEdit(e) {
    var _a6;
    return es(e) ? this.isFeatureAllowed(e) ? { next: true } : e.action === "marker_move" && e.lngLatStart && e.lngLatEnd ? (((_a6 = e.markerData) == null ? void 0 : _a6.type) === "vertex" ? this.moveVertex(e) : this.moveSource(e.featureData, e.lngLatStart, e.lngLatEnd), { next: false }) : (e.action === "marker_captured" ? (e.featureData.changeSource({ sourceName: K.temporary, atomic: true }), this.setCursorToPointer(), this.flags.actionInProgress = true, this.fireFeatureEditStartEvent({ feature: e.featureData })) : e.action === "marker_released" && (e.featureData.changeSource({ sourceName: K.main, atomic: true }), this.fireFeatureEditEndEvent({ feature: e.featureData }), this.flags.actionInProgress = false), { next: true }) : (te.error("EditChange.handleGmEdit: not an edit event", e), { next: false });
  }
  isFeatureAllowed(e) {
    return "featureData" in e && !this.allowedShapes.includes(e.featureData.shape);
  }
  moveVertex(e) {
    var _a6, _b2;
    const r = e.featureData, s = ((_b2 = (_a6 = this.shapeRotateHandlers)[r.shape]) == null ? void 0 : _b2.call(_a6, e)) || null;
    s ? (this.fireBeforeFeatureUpdate({
      features: [r],
      geoJsonFeatures: [s]
    }), this.updateFeatureGeoJson({ featureData: r, featureGeoJson: s }) && this.convertFeaturesTypes.includes(r.shape) && r.convertToPolygon()) : te.error("EditRotate.moveVertex: invalid geojson", s, e);
  }
  rotateEllipse(e) {
    const { featureData: r } = e;
    if (r.shape !== "ellipse")
      return te.error("EditRotate.rotateEllipse: invalid shape type", r), null;
    const s = r.getShapeProperty("center"), u = r.getShapeProperty("xSemiAxis"), l = r.getShapeProperty("ySemiAxis"), f = r.getShapeProperty("angle");
    if (!Array.isArray(s) || typeof u != "number" || typeof l != "number" || typeof f != "number")
      return te.error(
        "rotateEllipse: missing center, xSemiAxis, ySemiAxis or angle in the featureData",
        r
      ), null;
    const h = this.calculateRotationAngle(
      s,
      e.lngLatStart,
      e.lngLatEnd,
      false
    );
    return No({
      center: s,
      xSemiAxis: u,
      ySemiAxis: l,
      angle: f + h
    });
  }
  rotateFeature(e) {
    const r = e.featureData, s = $t(r.getGeoJson()), u = Zu(Xu(s)), l = this.calculateRotationAngle(u, e.lngLatStart, e.lngLatEnd);
    return s.geometry = bk(s, l, { pivot: u }).geometry, s;
  }
  calculateRotationAngle(e, r, s, u = true) {
    const l = io(e, r), h = io(e, s) - l;
    return u ? (h + 360) % 360 : h;
  }
};
var hl = {
  drag: OM,
  change: qS,
  rotate: RM,
  scale: null,
  copy: null,
  cut: NM,
  split: null,
  union: null,
  difference: null,
  line_simplification: null,
  lasso: null,
  delete: PM
};
var DM = (t, e) => hl[e] ? new hl[e](t) : (te.error(`Edit "${e}" is not available`), null);
var FM = class extends Ao {
  constructor(e, r) {
    super(e);
    __publicField(this, "eventHandlers", {
      [`${se}:edit`]: this.handleEditEvent.bind(this)
    });
    r.attachEvents(this.eventHandlers);
  }
  handleEditEvent(e) {
    if (!es(e))
      return { next: true };
    const r = `${e.actionType}__${e.mode}`;
    return e.action === "mode_start" ? (this.trackExclusiveModes(e), this.start(r, e), this.trackRelatedModes(e)) : e.action === "mode_end" && (this.trackRelatedModes(e), this.end(r)), { next: true };
  }
  start(e, r) {
    if (r.action !== "mode_start")
      return;
    const s = DM(this.gm, r.mode);
    s && (e in this.gm.actionInstances && te.error(`Action instance "${e}" already exists`), this.gm.actionInstances[e] = s, s.startAction());
  }
  end(e) {
    const r = this.gm.actionInstances[e];
    r instanceof ts ? (r.endAction(), delete this.gm.actionInstances[e]) : console.error(
      `Wrong action instance for edit event "${e}": `,
      r
    );
  }
};
var _a5;
var GM = class extends Dr {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "shape_markers");
    __publicField(this, "pinEnabled", ((_a5 = this.gm.options.controls.helper.pin) == null ? void 0 : _a5.active) || false);
    __publicField(this, "previousPosition", null);
    __publicField(this, "activeMarker", null);
    __publicField(this, "activeFeatureData", null);
    __publicField(this, "sharedMarkers", []);
    __publicField(this, "allowedShapes", ["circle", "line", "rectangle", "polygon", "ellipse"]);
    __publicField(this, "edgeMarkersAllowed", false);
    __publicField(this, "edgeMarkerAllowedShapes", ["line", "rectangle", "polygon"]);
    __publicField(this, "shapeMarkerAllowedModes", ["drag", "change", "cut", "split"]);
    __publicField(this, "eventHandlers", {
      [`${se}:draw`]: this.handleGmDraw.bind(this),
      [`${se}:edit`]: this.handleGmEdit.bind(this),
      mousedown: this.onMouseDown.bind(this),
      touchstart: this.onMouseDown.bind(this),
      mouseup: this.onMouseUp.bind(this),
      touchend: this.onMouseUp.bind(this),
      mousemove: this.onMouseMove.bind(this),
      touchmove: this.onMouseMove.bind(this),
      contextmenu: this.onMouseRightButtonClick.bind(this)
    });
    __publicField(this, "throttledMethods", ci(
      {
        sendMarkerMoveEvent: this.sendMarkerMoveEvent,
        sendMarkerRightClickEvent: this.sendMarkerRightClickEvent
      },
      this,
      this.gm.options.settings.throttlingDelay
    ));
    __publicField(this, "debouncedMethods", Yk(
      {
        refreshMarkers: this.refreshMarkers
      },
      this,
      this.gm.options.settings.throttlingDelay * 10
    ));
  }
  get pinHelperInstance() {
    return this.pinEnabled && Object.values(this.gm.actionInstances).find(jk) || null;
  }
  onStartAction() {
    this.isShapeMarkerAllowed() && this.gm.markerPointer.enable({ invisibleMarker: true }), this.edgeMarkersAllowed = this.gm.getActiveEditModes().includes("change"), this.addMarkers();
  }
  onEndAction() {
    this.gm.markerPointer.disable(), this.removeMarkers();
  }
  setPin(e) {
    this.pinEnabled = e;
  }
  onMouseDown(e) {
    var _a6;
    const r = ["mousedown", "touchstart"];
    if (!Ke(e, { warning: true }) || !r.includes(e.type) || $k(e))
      return { next: true };
    if (e.type === "mousedown" && e.originalEvent.button !== 0)
      return { next: true };
    const s = this.getFeatureMarkerByMouseEvent(e);
    return this.activeMarker = s || null, this.activeFeatureData = (s == null ? void 0 : s.instance.parent) || null, this.activeMarker && this.activeFeatureData ? (this.previousPosition = tc(this.activeMarker.instance), this.gm.mapAdapter.setDragPan(false), this.activeMarker.type === "edge" && this.sendMarkerEvent("edge_marker_click", this.activeFeatureData, this.activeMarker), this.pinEnabled && this.pinHelperInstance ? (this.sharedMarkers = this.pinHelperInstance.getSharedMarkers(
      this.activeMarker.position.coordinate
    ), this.sharedMarkers.forEach(
      (u) => {
        var _a7;
        return (_a7 = this.snappingHelper) == null ? void 0 : _a7.addExcludedFeature(u.featureData);
      }
    )) : (_a6 = this.snappingHelper) == null ? void 0 : _a6.addExcludedFeature(this.activeFeatureData), this.sendMarkerEvent("marker_captured", this.activeFeatureData, this.activeMarker), { next: false }) : { next: true };
  }
  onMouseUp() {
    var _a6;
    if (!this.activeMarker)
      return { next: true };
    const e = {
      featureData: this.activeFeatureData,
      markerData: this.activeMarker
    };
    return this.activeMarker = null, this.activeFeatureData = null, this.sharedMarkers = [], (_a6 = this.snappingHelper) == null ? void 0 : _a6.clearExcludedFeatures(), this.previousPosition = null, this.gm.mapAdapter.setDragPan(true), e.featureData && e.markerData ? (this.sendMarkerEvent("marker_released", e.featureData, e.markerData), { next: false }) : (te.debug("ShapeMarkersHelper.onMouseUp: no active marker or featureData", e), { next: true });
  }
  onMouseMove(e) {
    return !this.activeMarker || !Ke(e, { warning: true }) ? { next: true } : (this.throttledMethods.sendMarkerMoveEvent(e), { next: false });
  }
  onMouseRightButtonClick(e) {
    if (!Ke(e, { warning: true }))
      return { next: true };
    const r = this.getFeatureMarkerByMouseEvent(e);
    return r && r.instance.parent ? (this.throttledMethods.sendMarkerRightClickEvent(
      r.instance.parent,
      r
    ), { next: false }) : { next: true };
  }
  isShapeMarkerAllowed() {
    return _E(this.shapeMarkerAllowedModes, this.gm.getActiveEditModes()).length > 0;
  }
  convertToVertexMarker(e) {
    if (e.type === "edge" && e.instance.parent) {
      const r = e.position, s = e.instance.parent;
      this.removeMarker(e);
      const u = this.createMarker({
        type: "vertex",
        positionData: r,
        parentFeature: s
      }), l = s.getGeoJson(), f = Lk(l, r.coordinate);
      if (f) {
        const h = f.path.join("."), p = s.markers.get(h);
        return p && this.removeMarker(p), s.markers.set(h, u), u;
      }
    }
    return te.error("ShapeMarkersHelper.convertToVertexMarker: invalid marker type", e), e;
  }
  getFeatureMarkerByMouseEvent(e) {
    var _a6;
    const r = this.gm.features.getFeatureByMouseEvent({
      event: e,
      sourceNames: [K.main]
    });
    if ((_a6 = r == null ? void 0 : r.parent) == null ? void 0 : _a6.markers) {
      const s = DE(
        r.parent.markers,
        (u) => u.instance === r
      );
      if ((s == null ? void 0 : s.type) !== "dom")
        return s;
    }
    return null;
  }
  addMarkers() {
    this.gm.features.forEach((e) => {
      if (!e || !this.allowedShapes.includes(e.shape) || e.getShapeProperty("disableEdit") === true)
        return;
      this.addCenterMarker(e);
      const r = this.getAllShapeSegments(e), s = this.getEndMarkerIndexes(e);
      r.forEach((u, l) => {
        if (this.isMarkerIndexAllowed(
          e.shape,
          l,
          r.length
        )) {
          const h = this.createOrUpdateVertexMarker(u.segment.start, e);
          if (e.markers.set(h.markerKey, h.markerData), s.has(l)) {
            const p = this.createOrUpdateVertexMarker(
              u.segment.end,
              e
            );
            e.markers.set(p.markerKey, p.markerData);
          }
        }
        if (this.isEdgeMarkerAllowed(e)) {
          const h = this.createOrUpdateEdgeMarker(u, e);
          e.markers.set(h.markerKey, h.markerData);
        }
      });
    });
  }
  addCenterMarker(e) {
    const r = e.getShapeProperty("center");
    if (r) {
      const s = this.createMarker({
        type: "center",
        positionData: {
          path: [],
          coordinate: r
        },
        parentFeature: e
      });
      e.markers.set("center", s);
    }
  }
  getAllShapeSegments(e) {
    const r = e.getGeoJson(), s = [];
    return Jl(r, (u, l) => {
      s.push({
        segment: u,
        middle: this.getSegmentMiddlePosition(u),
        edgeMarkerKey: this.getEdgeMarkerKey(l)
      });
    }), s;
  }
  isEdgeMarkerAllowed(e) {
    return this.edgeMarkersAllowed && this.edgeMarkerAllowedShapes.includes(e.shape);
  }
  isMarkerIndexAllowed(e, r, s) {
    const u = Math.floor(s / 4);
    return e === "circle" ? (r + u / 2) % u === 0 : e === "ellipse" ? r % u === 0 : true;
  }
  getEdgeMarkerKey(e) {
    return `edge.${e}`;
  }
  getEndMarkerIndexes(e) {
    const r = e.getGeoJson().geometry;
    return e.shape !== "line" || !["LineString", "MultiLineString"].includes(r.type) ? /* @__PURE__ */ new Set() : r.type === "MultiLineString" ? r.coordinates.reduce(
      (u, l) => (u.indexes.add(u.sum + l.length - 2), u.sum += l.length - 1, u),
      { sum: 0, indexes: /* @__PURE__ */ new Set() }
    ).indexes : /* @__PURE__ */ new Set([r.coordinates.length - 2]);
  }
  getSegmentMiddlePosition(e) {
    const r = this.gm.mapAdapter.project(e.start.coordinate), s = this.gm.mapAdapter.project(e.end.coordinate), u = [
      (r[0] + s[0]) / 2,
      (r[1] + s[1]) / 2
    ], l = e.start.path.slice(0, e.start.path.length - 1).concat([-1]);
    return {
      coordinate: this.gm.mapAdapter.unproject(u),
      path: l
    };
  }
  removeMarkers() {
    this.gm.features.forEach((e, r) => {
      const s = this.gm.features.get(K.main, r);
      s && (s.markers.forEach((u) => {
        u.type !== "dom" ? this.gm.features.delete(u.instance) : te.error("Non a FeatureData marker", u);
      }), s.markers = /* @__PURE__ */ new Map());
    });
  }
  removeMarker(e) {
    if (e.type === "dom") {
      te.error("Wrong marker type", e);
      return;
    }
    const r = e.instance.parent;
    if (!r) {
      te.error("Missing parent feature data", e);
      return;
    }
    try {
      r.markers.forEach((s, u) => {
        if (s === e)
          throw this.gm.features.delete(s.instance), r.markers.delete(u), new Error("break");
      });
    } catch {
    }
  }
  handleGmDraw(e) {
    return Zl(e) ? (["feature_created", "mode_start"].includes(e.action) && this.debouncedMethods.refreshMarkers(), { next: true }) : (te.error("ShapeMarkersHelper.handleGmDraw: not a draw event", e), { next: true });
  }
  refreshMarkers() {
    this.gm.options.isModeEnabled("helper", "shape_markers") && (this.removeMarkers(), this.addMarkers());
  }
  handleGmEdit(e) {
    return es(e) ? (e.action === "feature_updated" && this.handleShapeUpdate(e), { next: true }) : (te.error("ShapeMarkersHelper.handleGmEdit: not an edit event", e), { next: true });
  }
  handleShapeUpdate(e) {
    var _a6;
    const r = e.targetFeatures[0];
    if (!r) {
      te.error("ShapeMarkersHelper.handleShapeUpdate: no featureData", e);
      return;
    }
    ((_a6 = this.activeMarker) == null ? void 0 : _a6.type) === "edge" && (this.activeMarker = this.convertToVertexMarker(this.activeMarker));
    const s = this.getAllShapeSegments(r), u = new Set(r.markers.keys()), l = this.getEndMarkerIndexes(r);
    s.forEach((f, h) => {
      if (this.isMarkerIndexAllowed(
        r.shape,
        h,
        s.length
      )) {
        const d = this.createOrUpdateVertexMarker(f.segment.start, r);
        if (u.delete(d.markerKey), l.has(h)) {
          const v = this.createOrUpdateVertexMarker(
            f.segment.end,
            r
          );
          u.delete(v.markerKey);
        }
      }
      if (this.isEdgeMarkerAllowed(r)) {
        const d = this.createOrUpdateEdgeMarker(f, r);
        u.delete(d.markerKey);
      }
    }), this.updateCenterMarkerPosition(r), u.delete("center"), u.forEach((f) => {
      const h = r.markers.get(f);
      h && h.type !== "dom" ? this.gm.features.delete(h.instance) : te.error("Non a FeatureData marker"), r.markers.delete(f);
    });
  }
  createOrUpdateVertexMarker(e, r) {
    const s = e.path.join(".");
    let u = r.markers.get(s) || null;
    if (u && (u == null ? void 0 : u.type) !== "vertex")
      throw new Error(`Invalid marker type "${u == null ? void 0 : u.type}" for edge marker`);
    return u ? (Wh(u.position.coordinate, e.coordinate) || this.gm.features.updateMarkerFeaturePosition(u.instance, e.coordinate), u.position = e) : (u = this.createMarker({
      type: "vertex",
      positionData: e,
      parentFeature: r
    }), r.markers.set(s, u)), { markerKey: s, markerData: u };
  }
  createOrUpdateEdgeMarker(e, r) {
    let s = r.markers.get(e.edgeMarkerKey) || null;
    if (s && (s == null ? void 0 : s.type) !== "edge")
      throw new Error(`Invalid marker type "${s == null ? void 0 : s.type}" for edge marker`);
    return s ? (Wh(s.position.coordinate, e.middle.coordinate) || s.instance.updateGeoJsonGeometry({
      type: "Point",
      coordinates: e.middle.coordinate
    }), s.position = e.middle, s.segment = e.segment) : (s = this.createMarker({
      type: "edge",
      positionData: e.middle,
      segment: e.segment,
      parentFeature: r
    }), r.markers.set(e.edgeMarkerKey, s)), { markerKey: e.edgeMarkerKey, markerData: s };
  }
  updateCenterMarkerPosition(e) {
    const r = e.markers.get("center") || null, s = e.getShapeProperty("center");
    r && r.type !== "dom" && s && (r.instance.updateGeoJsonGeometry({
      type: "Point",
      coordinates: s
    }), r.position.coordinate = s);
  }
  sendMarkerEvent(e, r, s) {
    const u = {
      name: `${se}:edit:marker`,
      level: "system",
      actionType: "edit",
      mode: "change",
      action: e,
      featureData: r,
      markerData: s
    };
    this.gm.events.fire(`${se}:edit`, u);
  }
  sendMarkerRightClickEvent(e, r) {
    const s = {
      name: `${se}:edit:marker`,
      level: "system",
      actionType: "edit",
      mode: "change",
      action: "marker_right_click",
      featureData: e,
      markerData: r
    };
    this.gm.events.fire(`${se}:edit`, s);
  }
  sendMarkerMoveEvent(e) {
    var _a6;
    const r = ((_a6 = this.gm.markerPointer.marker) == null ? void 0 : _a6.getLngLat()) || e.lngLat.toArray();
    this.activeMarker && this.activeFeatureData && (this.pinEnabled ? this.sharedMarkers : [
      {
        markerData: this.activeMarker,
        featureData: this.activeFeatureData
      }
    ]).forEach((u) => {
      if (this.previousPosition) {
        const l = {
          name: `${se}:edit:marker_move`,
          level: "system",
          actionType: "edit",
          mode: "drag",
          action: "marker_move",
          featureData: u.featureData,
          markerData: u.markerData,
          lngLatStart: this.previousPosition,
          lngLatEnd: r
        };
        this.gm.events.fire(`${se}:edit`, l);
      }
    }), this.previousPosition = r;
  }
  createMarker({
    type: e,
    segment: r,
    positionData: s,
    parentFeature: u
  }) {
    const l = s.coordinate, f = this.gm.features.createMarkerFeature({
      sourceName: u.sourceName,
      parentFeature: u,
      type: e,
      coordinate: l
    });
    if (!f)
      throw new Error(`Missine feature data for the "${e}" marker`);
    if (e === "edge" && r)
      return {
        type: e,
        instance: f,
        position: $t(s),
        segment: r
      };
    if (e === "vertex" || e === "center")
      return {
        type: e,
        instance: f,
        position: $t(s)
      };
    throw new Error(`Invalid marker type "${e}" with segment: ${r}`);
  }
};
var BM = class extends Dr {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "snapping");
    __publicField(this, "tolerance", 18);
    __publicField(this, "lineSnappingShapes", [
      "circle",
      "line",
      "rectangle",
      "polygon",
      "snap_guide"
    ]);
    __publicField(this, "eventHandlers", {});
    __publicField(this, "shapeSnappingHandlers", {
      marker: this.getPointsSnapping.bind(this),
      circle: this.getLineSnapping.bind(this),
      circle_marker: this.getPointsSnapping.bind(this),
      text_marker: this.getPointsSnapping.bind(this),
      line: this.getLineSnapping.bind(this),
      rectangle: this.getLineSnapping.bind(this),
      polygon: this.getLineSnapping.bind(this),
      snap_guide: this.getLineSnapping.bind(this)
    });
    __publicField(this, "excludedFeature", /* @__PURE__ */ new Set());
    __publicField(this, "customSnappingLngLats", /* @__PURE__ */ new Map());
    __publicField(this, "customSnappingFeatures", /* @__PURE__ */ new Set());
  }
  onStartAction() {
    this.gm.markerPointer.setSnapping(true);
  }
  onEndAction() {
    this.gm.markerPointer.setSnapping(false);
  }
  addExcludedFeature(e) {
    this.excludedFeature.add(e);
  }
  clearExcludedFeatures() {
    this.excludedFeature.clear();
  }
  addCustomSnappingFeature(e) {
    this.customSnappingFeatures.add(e);
  }
  removeCustomSnappingFeature(e) {
    this.customSnappingFeatures.delete(e);
  }
  clearCustomSnappingFeature() {
    this.customSnappingFeatures.clear();
  }
  setCustomSnappingCoordinates(e, r) {
    this.customSnappingLngLats.set(e, r);
  }
  clearCustomSnappingCoordinates(e) {
    this.customSnappingLngLats.delete(e);
  }
  getSnappedLngLat(e, r) {
    let s = this.getCustomLngLatsSnapping(r);
    if (s)
      return s;
    const u = this.getFeaturesInPointBounds(r).filter(
      (l) => !this.excludedFeature.has(l)
    );
    return s = this.getFeaturePointsSnapping(u, e, r), s || (s = this.getFeatureLinesSnapping(u, e, r), s) ? s : e;
  }
  getCustomLngLatsSnapping(e) {
    const r = {
      distance: 1 / 0,
      lngLat: null
    };
    return this.customSnappingLngLats.forEach((s) => {
      s.forEach((u) => {
        const l = this.gm.mapAdapter.project(u), f = qa(e, l);
        f < this.tolerance && f < r.distance && (r.distance = f, r.lngLat = u);
      });
    }), r.lngLat;
  }
  getFeaturePointsSnapping(e, r, s) {
    let u = e.map((l) => ({
      shape: l.shape,
      ...this.getPointsSnapping(l, r, s)
    })).filter((l) => l.distance < this.tolerance);
    return u.length ? (u = _h(u, ["distance"]), u[0].lngLat) : null;
  }
  getFeatureLinesSnapping(e, r, s) {
    let u = e.filter((l) => this.lineSnappingShapes.includes(l.shape)).map((l) => {
      const f = this.shapeSnappingHandlers[l.shape];
      return f ? {
        shape: l.shape,
        ...f(l, r, s)
      } : null;
    }).filter((l) => l !== null && l.distance < this.tolerance);
    return u.length ? (u = _h(u, ["distance"]), u[0].lngLat) : null;
  }
  getFeaturesInPointBounds(e) {
    const r = [
      [e[0] - this.tolerance, e[1] - this.tolerance],
      [e[0] + this.tolerance, e[1] + this.tolerance]
    ];
    return this.gm.features.getFeaturesByScreenBounds({ bounds: r, sourceNames: [K.main, K.temporary] }).filter((s) => s.temporary ? this.customSnappingFeatures.has(s) : true) || [];
  }
  getPointsSnapping(e, r, s) {
    const u = e.getGeoJson(), l = {
      distance: 1 / 0,
      coord: null
      // lngLat coords
    };
    return aa(
      u,
      (f) => {
        const h = this.gm.mapAdapter.project(f.coordinate), p = qa(s, h);
        p < this.tolerance && p < l.distance && (l.distance = p, l.coord = f.coordinate);
      },
      true
    ), {
      lngLat: l.coord ? l.coord : r,
      distance: l.distance
    };
  }
  getLineSnapping(e, r, s) {
    const u = e.getGeoJson();
    return this.getNearestLinePointData(u, r, s);
  }
  getNearestLinePointData(e, r, s) {
    const u = {
      lngLat: r,
      distance: 1 / 0
    }, l = this.gm.mapAdapter.getEuclideanNearestLngLat(e, r), f = this.gm.mapAdapter.project(l);
    return u.distance = qa(f, s), u.distance < this.tolerance && (u.lngLat = l), u;
  }
};
var UM = class extends Dr {
  constructor() {
    super(...arguments);
    __publicField(this, "mode", "zoom_to_features");
    __publicField(this, "eventHandlers", {});
  }
  onStartAction() {
    this.fitMapToFeatures(), setTimeout(() => {
      this.gm.options.disableMode("helper", "zoom_to_features");
    });
  }
  onEndAction() {
  }
  fitMapToFeatures() {
    const e = this.gm.features.asGeoJsonFeatureCollection({
      sourceNames: [K.main, ...at ? [K.standby] : []]
    }), r = Bd(e), s = [
      [r[0], r[1]],
      [r[2], r[3]]
    ];
    try {
      this.gm.mapAdapter.fitBounds(s, { padding: 20 });
    } catch {
      te.warn("Wrong bounds for zooming to features", s, e);
    }
  }
};
var fl = {
  shape_markers: GM,
  pin: null,
  snapping: BM,
  snap_guides: null,
  measurements: null,
  auto_trace: null,
  geofencing: null,
  zoom_to_features: UM,
  click_to_edit: null
};
var zM = (t, e) => fl[e] ? new fl[e](t) : (te.error(`Helper "${e}" is not available`), null);
var qM = class extends Ao {
  constructor(e, r) {
    super(e);
    __publicField(this, "eventHandlers", {
      [`${se}:helper`]: this.handleHelperEvent.bind(this)
    });
    r.attachEvents(this.eventHandlers);
  }
  handleHelperEvent(e) {
    if (!Wl(e))
      return { next: true };
    const r = `${e.actionType}__${e.mode}`;
    return e.action === "mode_start" ? (this.trackExclusiveModes(e), this.start(r, e), this.trackRelatedModes(e)) : e.action === "mode_end" && (this.trackRelatedModes(e), this.end(r)), { next: true };
  }
  start(e, r) {
    const s = zM(this.gm, r.mode);
    s && (e in this.gm.actionInstances && te.error(`Action instance "${e}" already exists`), this.gm.actionInstances[e] = s, s.startAction());
  }
  end(e) {
    const r = this.gm.actionInstances[e];
    r instanceof Dr ? (r.endAction(), delete this.gm.actionInstances[e]) : console.error(`Wrong action instance for edit event "${e}":`, r);
  }
};
var YM = class {
  constructor(e) {
    __publicField(this, "gm");
    __publicField(this, "bus");
    __publicField(this, "listeners", {});
    this.gm = e, this.bus = new lk(this.gm), this.listeners = {
      draw: new B2(this.gm, this.bus),
      edit: new FM(this.gm, this.bus),
      helper: new qM(this.gm, this.bus),
      control: new ck(this.gm, this.bus)
    };
  }
  fire(e, r) {
    this.listeners[r.actionType] || te.error(`Can't find event listener for "${r.actionType}" event type`), this.bus.fireEvent(e, r);
  }
};
var Vf = 5e3;
var HM = class {
  constructor(e) {
    __publicField(this, "gm");
    __publicField(this, "updateStorage");
    __publicField(this, "autoUpdatesEnabled", true);
    __publicField(this, "delayedSourceUpdateMethods");
    // Track pending update promises per source to allow waiting for MapLibre to commit data
    // Using an array to track multiple concurrent promises (prevents overwriting if rapid updates occur)
    __publicField(this, "pendingUpdatePromises");
    this.gm = e, this.updateStorage = Object.fromEntries(Vu(K).map((r) => [r, []])), this.pendingUpdatePromises = {}, this.delayedSourceUpdateMethods = Object.fromEntries(
      Vu(K).map((r) => [
        r,
        Ag(
          () => this.updateSourceActual(r),
          this.gm.options.settings.throttlingDelay
        )
      ])
    );
  }
  updatesPending(e) {
    var _a6, _b2;
    return !!((_a6 = this.updateStorage[e]) == null ? void 0 : _a6.length) || !!(((_b2 = this.pendingUpdatePromises[e]) == null ? void 0 : _b2.length) ?? 0);
  }
  getFeatureId(e) {
    var _a6;
    const r = ((_a6 = e.properties) == null ? void 0 : _a6[qt]) ?? e.id;
    return r == null && console.warn("Feature id is null or undefined", e), r;
  }
  updateSource({
    sourceName: e,
    diff: r
  }) {
    r && this.updateStorage[e].push(r), this.delayedSourceUpdateMethods[e]();
  }
  updateSourceActual(e) {
    const r = this.gm.features.sources[e];
    if (this.autoUpdatesEnabled && r) {
      if (!r.loaded) {
        setTimeout(() => {
          this.updateSourceActual(e);
        }, this.gm.options.settings.throttlingDelay);
        return;
      }
      const s = this.getCombinedDiff(e);
      if (s) {
        const u = r.updateData(s);
        this.addPendingPromise(e, u);
      }
      this.updateStorage[e].length > 0 && setTimeout(
        () => this.updateSourceActual(e),
        this.gm.options.settings.throttlingDelay
      );
    }
  }
  /**
   * Add a pending promise to the tracking array for a source.
   * Automatically removes the promise from the array when it resolves.
   */
  addPendingPromise(e, r) {
    this.pendingUpdatePromises[e] || (this.pendingUpdatePromises[e] = []), this.pendingUpdatePromises[e].push(r), r.finally(() => {
      const s = this.pendingUpdatePromises[e];
      if (s) {
        const u = s.indexOf(r);
        u !== -1 && s.splice(u, 1), s.length === 0 && delete this.pendingUpdatePromises[e];
      }
    });
  }
  /**
   * Wait for any pending MapLibre source updates to complete.
   * This ensures data is committed before events are fired.
   *
   * When there are queued updates in updateStorage that haven't been processed yet
   * (due to throttling), this method flushes them immediately and waits for completion.
   *
   * Note: We call updateData() directly here rather than going through updateSourceActual()
   * because updateSourceActual() checks `!source.loaded` and may delay processing.
   * When waiting for pending updates (e.g., for event handlers), we need immediate processing.
   *
   * This is safe and won't cause duplicates because getCombinedDiff() atomically drains
   * the storage - whoever calls it first gets the diffs, subsequent calls get null.
   *
   * IMPORTANT: MapLibre's _updateWorkerData() has a guard that returns early if already
   * updating (`if (this._isUpdatingWorker) return`). This means updateData() can return
   * a promise that resolves before the data is actually committed to serialize().
   * To handle this, we loop until both storage and pending promises are empty, with
   * a microtask yield between iterations to allow MapLibre's recursive updates to run.
   */
  async waitForPendingUpdates(e) {
    var _a6, _b2, _c2;
    const r = this.gm.features.sources[e];
    if (r) {
      for (; ((_a6 = this.updateStorage[e]) == null ? void 0 : _a6.length) || ((_b2 = this.pendingUpdatePromises[e]) == null ? void 0 : _b2.length); ) {
        if ((_c2 = this.updateStorage[e]) == null ? void 0 : _c2.length) {
          const u = this.getCombinedDiff(e);
          if (u) {
            const l = r.updateData(u);
            this.addPendingPromise(e, l);
          }
        }
        const s = this.pendingUpdatePromises[e];
        (s == null ? void 0 : s.length) && await Promise.all(s), await new Promise((u) => setTimeout(u, 0));
      }
      await new Promise((s) => requestAnimationFrame(s));
    }
  }
  withAtomicSourcesUpdate(e) {
    try {
      return this.autoUpdatesEnabled = false, e();
    } finally {
      et(this.gm.features.sources).forEach((r) => {
        this.updateSource({ sourceName: r });
      }), this.autoUpdatesEnabled = true;
    }
  }
  getCombinedDiff(e) {
    let r = {
      remove: [],
      add: [],
      update: []
    };
    for (let s = 0; s < Vf && this.updateStorage[e][s] !== void 0; s += 1)
      r = this.mergeGeoJsonDiff(r, this.updateStorage[e][s]);
    return this.updateStorage[e] = this.updateStorage[e].slice(Vf), Object.values(r).find((s) => s.length) ? r : null;
  }
  mergeGeoJsonDiff(e, r) {
    var _a6, _b2, _c2;
    const s = e ?? { add: [], update: [], remove: [] }, u = r ?? { add: [], update: [], remove: [] }, l = new Set(u.remove), f = ((_a6 = s.add) == null ? void 0 : _a6.filter((d) => !l.has(this.getFeatureId(d)))) || [], h = ((_b2 = s.update) == null ? void 0 : _b2.filter((d) => !l.has(this.getFeatureId(d)))) || [], p = [];
    return (_c2 = u.update) == null ? void 0 : _c2.forEach((d) => {
      const v = f.findIndex(
        (E) => this.getFeatureId(E) === this.getFeatureId(d)
      ), _ = h.findIndex(
        (E) => this.getFeatureId(E) === this.getFeatureId(d)
      );
      if (v === -1 && _ === -1) {
        p.push(d);
        return;
      }
      v !== -1 && (f[v] = d), _ !== -1 && (h[_] = d);
    }), {
      add: [...f, ...u.add || []],
      update: [...h, ...p],
      remove: [...s.remove || [], ...u.remove || []]
    };
  }
};
var JM = class {
  isInstanceAvailable() {
    return this.sourceInstance ? true : (te.error("Source instance is not available"), false);
  }
};
var $M = class {
  constructor(e) {
    __publicField(this, "gm");
    __publicField(this, "featureCounter", 0);
    __publicField(this, "featureStore", /* @__PURE__ */ new Map());
    __publicField(this, "featureStoreAllowedSources", [K.main, K.temporary]);
    __publicField(this, "sources");
    __publicField(this, "defaultSourceName", K.main);
    __publicField(this, "updateManager");
    __publicField(this, "layers");
    this.gm = e, this.updateManager = new HM(e), this.sources = Object.fromEntries(
      Vu(K).map((r) => [r, null])
    ), this.layers = [];
  }
  get forEach() {
    return this.filteredForEach((e) => !e.temporary);
  }
  get tmpForEach() {
    return this.filteredForEach((e) => e.temporary);
  }
  init() {
    if (Object.values(this.sources).some((e) => e !== null)) {
      te.warn("features.init(): features are already initialized");
      return;
    }
    et(this.sources).forEach((e) => {
      this.sources[e] = this.createSource(e);
    }), this.hydrateFromExistingSources(), this.gm.options.settings.useDefaultLayers && (this.layers = this.createLayers());
  }
  /**
   * Hydrates the feature store from existing sources and syncs the ID counter.
   * This is called during init to restore state when remounting on preserved sources.
   */
  hydrateFromExistingSources() {
    let e = 0;
    et(this.sources).forEach((r) => {
      var _a6;
      const s = this.sources[r];
      if (s)
        try {
          const u = s.getGeoJson();
          if (u && "features" in u)
            for (const l of u.features) {
              const f = (_a6 = l.properties) == null ? void 0 : _a6[qt];
              if (!f) continue;
              if (typeof f == "string" && f.startsWith("feature-")) {
                const d = parseInt(f.replace("feature-", ""), 10);
                !isNaN(d) && d > e && (e = d);
              }
              if (this.featureStore.has(f)) continue;
              const h = l, p = new Bs({
                gm: this.gm,
                id: f,
                parent: null,
                source: s,
                geoJsonShapeFeature: $t(h),
                skipSourceUpdate: true
              });
              this.featureStore.set(f, p);
            }
        } catch {
        }
    }), e > this.featureCounter && (this.featureCounter = e);
  }
  getNewFeatureId(e) {
    if (this.featureCounter += 1, this.gm.options.settings.idGenerator)
      return this.gm.options.settings.idGenerator(e);
    let r = `feature-${this.featureCounter}`;
    for (; this.featureStore.has(r); )
      this.featureCounter += 1, r = `feature-${this.featureCounter}`;
    return r;
  }
  filteredForEach(e) {
    return (r) => {
      this.featureStore.forEach((s, u, l) => {
        e(s) && r(s, u, l);
      });
    };
  }
  has(e, r) {
    const s = this.featureStore.get(r);
    return !!s && (s == null ? void 0 : s.source) === this.sources[e];
  }
  get(e, r) {
    const s = this.featureStore.get(r) || null;
    return (s == null ? void 0 : s.source) === this.sources[e] ? s : null;
  }
  add(e) {
    if (this.featureStore.has(e.id)) {
      te.error(`features.add: feature with the id "${e.id}" already exists`);
      return;
    }
    this.featureStoreAllowedSources.includes(e.source.id) && this.featureStore.set(e.id, e);
  }
  setDefaultSourceName(e) {
    this.defaultSourceName = e;
  }
  createSource(e) {
    const r = this.gm.mapAdapter.addSource(e, {
      type: "FeatureCollection",
      features: []
    });
    if (r)
      return r;
    throw new Error(`Features: failed to create the source: "${e}"`);
  }
  delete(e) {
    let r;
    e instanceof Bs ? r = e : r = this.featureStore.get(e) || null, r ? (this.featureStore.delete(r.id), r.delete()) : te.error(`features.delete: feature "${e}" not found`);
  }
  deleteAll() {
    this.featureStore.forEach((e) => {
      e.delete();
    }), this.featureStore.clear();
  }
  getFeatureByMouseEvent({
    event: e,
    sourceNames: r
  }) {
    if (!Ke(e, { warning: true }))
      return null;
    const s = [e.point.x, e.point.y], u = this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: s,
      sourceNames: r
    });
    return u.length ? u[0] : null;
  }
  getFeaturesByGeoJsonBounds({
    geoJson: e,
    sourceNames: r
  }) {
    const s = $l(e), u = this.gm.mapAdapter.coordBoundsToScreenBounds(s);
    return this.getFeaturesByScreenBounds({ bounds: u, sourceNames: r });
  }
  getFeaturesByScreenBounds({
    bounds: e,
    sourceNames: r
  }) {
    return this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: e,
      sourceNames: r
    });
  }
  createFeature({
    featureId: e,
    shapeGeoJson: r,
    parent: s,
    sourceName: u,
    imported: l
  }) {
    const f = this.sources[u];
    if (!f)
      return te.error("Features.createFeature Missing source for feature creation"), null;
    const h = e ?? r.properties[qt] ?? this.getNewFeatureId(r);
    if (this.featureStore.get(h))
      return te.error(
        `Features.createFeature: feature with the id "${h}" already exists`,
        this.featureStore.get(h)
      ), null;
    const p = new Bs({
      gm: this.gm,
      id: h,
      parent: s || null,
      source: f,
      geoJsonShapeFeature: $t(r)
    });
    return this.add(p), !p.temporary && !l && this.fireFeatureCreatedEvent(p), this.featureCounter += 1, p;
  }
  importGeoJson(e, r) {
    const s = r ?? {}, u = "features" in e ? e.features : [e], l = {
      stats: {
        total: 0,
        success: 0,
        failed: 0,
        overwritten: 0
      },
      addedFeatures: []
    };
    return u.forEach((f) => {
      var _a6;
      let h = null;
      l.stats.total += 1;
      const p = GS(f);
      if (p) {
        if (s.idPropertyName) {
          const d = BS(p, s.idPropertyName);
          d && (p.id = d);
        }
        if (s.overwrite) {
          const d = p.id ?? ((_a6 = p.properties) == null ? void 0 : _a6[qt]);
          d && this.featureStore.has(d) && (this.delete(d), l.stats.overwritten += 1);
        }
        h = this.importGeoJsonFeature(p);
      }
      h ? (l.addedFeatures.push(h), l.stats.success += 1) : l.stats.failed += 1;
    }), l;
  }
  importGeoJsonFeature(e) {
    const r = this.defaultSourceName, s = this.getFeatureShapeByGeoJson(e);
    return s ? this.createFeature({
      featureId: e.id,
      shapeGeoJson: e,
      sourceName: r,
      imported: true
    }) : (te.error("features.addGeoJsonFeature: unknown shape", s), null);
  }
  getAll() {
    return this.exportGeoJson();
  }
  /**
   * Exports GeoJSON from Geoman's internal state.
   *
   * This is the recommended method for most use cases as it always returns the latest
   * feature data, even during event handlers before MapLibre has committed changes.
   *
   * @param options - Export options
   * @param options.allowedShapes - Filter to only include specific shape types
   * @param options.idPropertyName - Property name to use for feature IDs (default: 'gm_id')
   * @returns GeoJSON FeatureCollection with all features
   *
   * @example
   * // Export all features
   * const geoJson = geoman.features.exportGeoJson();
   *
   * // Export only polygons and circles
   * const shapes = geoman.features.exportGeoJson({ allowedShapes: ['polygon', 'circle'] });
   */
  exportGeoJson({
    allowedShapes: e,
    idPropertyName: r
  } = { allowedShapes: void 0 }) {
    return this.asGeoJsonFeatureCollection({
      sourceNames: [K.main, ...at ? [K.standby] : []],
      shapeTypes: e || [...or],
      idPropertyName: r,
      useMapLibreSource: false
    });
  }
  /**
   * Exports GeoJSON directly from MapLibre's underlying source data.
   *
   * This method reads from MapLibre's serialized source state, which may lag slightly
   * behind Geoman's internal state during rapid updates or in event handlers.
   *
   * Use this method when you specifically need to verify what MapLibre has committed
   * to its source, for debugging, or for synchronization with external systems that
   * read directly from MapLibre sources.
   *
   * For most use cases, prefer `exportGeoJson()` which uses Geoman's internal state
   * and is always up-to-date.
   *
   * @param options - Export options
   * @param options.allowedShapes - Filter to only include specific shape types
   * @param options.idPropertyName - Property name to use for feature IDs (default: 'gm_id')
   * @returns GeoJSON FeatureCollection from MapLibre's source
   *
   * @example
   * // Export features as stored in MapLibre source
   * const geoJson = geoman.features.exportGeoJsonFromSource();
   *
   * // Verify MapLibre has committed the data
   * await geoman.features.waitForPendingUpdates();
   * const committed = geoman.features.exportGeoJsonFromSource();
   */
  exportGeoJsonFromSource({
    allowedShapes: e,
    idPropertyName: r
  } = { allowedShapes: void 0 }) {
    return this.asGeoJsonFeatureCollection({
      sourceNames: [K.main, ...at ? [K.standby] : []],
      shapeTypes: e || [...or],
      idPropertyName: r,
      useMapLibreSource: true
    });
  }
  asGeoJsonFeatureCollection({
    shapeTypes: e,
    sourceNames: r,
    idPropertyName: s,
    useMapLibreSource: u = false
  }) {
    const l = {
      type: "FeatureCollection",
      features: []
    };
    return s ?? (s = qt), r.forEach((f) => {
      const h = this.sources[f];
      h && (u ? h.getGeoJson() : h.getGmGeoJson()).features.filter((d) => !!d).forEach((d) => {
        const v = this.get(f, d.id);
        if (!v)
          return;
        const _ = d.properties[qt];
        s !== qt && (d.properties[s] = _, delete d.properties[qt]), (e === void 0 || e.includes(v.shape)) && l.features.push({ ...d, id: _ });
      });
    }), l;
  }
  convertSourceToGm(e) {
    const r = [], s = e.getGeoJson(), u = "features" in s ? s.features : [s];
    return this.gm.mapAdapter.getSource(e.id).remove(), u.forEach((f) => {
      const h = this.addGeoJsonFeature({
        shapeGeoJson: f,
        defaultSource: true
      });
      h && r.push(h);
    }), r;
  }
  addGeoJsonFeature({
    shapeGeoJson: e,
    sourceName: r,
    defaultSource: s
  }) {
    let u;
    if (s ? (u = this.defaultSourceName, r && te.warn("features.addGeoJsonFeature: default source is set, sourceName is ignored")) : u = r || null, !u)
      return te.error("features.addGeoJsonFeature: missing sourceName"), null;
    const l = this.getFeatureShapeByGeoJson(e);
    return l ? this.createFeature({
      featureId: e.id,
      shapeGeoJson: {
        ...e,
        properties: { ...e.properties, shape: l }
      },
      sourceName: u
    }) : (te.error("features.addGeoJsonFeature: unknown shape", l), null);
  }
  createLayers() {
    const e = [];
    return et(this.sources).forEach((r) => {
      et(this.gm.options.layerStyles).forEach((s) => {
        this.gm.options.layerStyles[s][r].forEach((l) => {
          const f = this.createGenericLayer({
            sourceName: r,
            shapeNames: [s],
            partialStyle: l
          });
          f && e.push(f);
        });
      });
    }), e;
  }
  createGenericLayer({
    sourceName: e,
    shapeNames: r,
    partialStyle: s
  }) {
    const u = this.getGenericLayerName({ sourceName: e, shapeNames: r, partialStyle: s });
    if (!u)
      throw new Error(`Can't create a layer, for ${{ sourceName: e, shapeNames: r, partialStyle: s }}`);
    const l = {
      ...s,
      id: u,
      source: e,
      filter: ["in", ["get", `${mt}shape`], ["literal", r]]
    };
    return this.gm.mapAdapter.addLayer(l);
  }
  getGenericLayerName({
    sourceName: e,
    shapeNames: r,
    partialStyle: s
  }) {
    const l = r.length === 1 ? r[0] : "mixed", f = (p) => `${e}-${l}__${s.type}-layer-${p}`;
    let h = null;
    for (let p = 0; p < 100; p += 1) {
      const d = f(p);
      if (!this.gm.mapAdapter.getLayer(d))
        return h = d, h;
    }
    return null;
  }
  getFeatureShapeByGeoJson(e) {
    const r = {
      Point: "marker",
      LineString: "line",
      MultiLineString: "line",
      Polygon: "polygon",
      MultiPolygon: "polygon"
    }, s = e.properties;
    return (s == null ? void 0 : s.shape) && or.includes(s == null ? void 0 : s.shape) ? s == null ? void 0 : s.shape : r[e.geometry.type] || null;
  }
  createMarkerFeature({
    parentFeature: e,
    coordinate: r,
    type: s,
    sourceName: u
  }) {
    return this.createFeature({
      sourceName: u,
      parent: e,
      shapeGeoJson: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: r
        },
        properties: {
          [`${mt}shape`]: `${s}_marker`
        }
      }
    });
  }
  updateMarkerFeaturePosition(e, r) {
    e.updateGeoJsonGeometry({
      type: "Point",
      coordinates: r
    });
  }
  fireFeatureCreatedEvent(e) {
    if (Cr(e.shape, or)) {
      const r = {
        name: `${se}:draw:feature_created`,
        level: "system",
        actionType: "draw",
        mode: e.shape,
        action: "feature_created",
        featureData: e
      };
      this.gm.events.fire(`${se}:draw`, r);
    }
  }
};
var VM = class {
  getEuclideanNearestLngLat(e, r) {
    const s = this.project(r);
    let u = [0, 0], l = 1 / 0;
    return Jl(e, (f) => {
      const h = this.project(f.start.coordinate), p = this.project(f.end.coordinate), d = Pk(
        h,
        p,
        s
      ), v = qa(s, d);
      v < l && (l = v, u = [d[0], d[1]]);
    }), this.unproject(u);
  }
  getDistance(e, r) {
    return Vd(e, r, { units: "meters" });
  }
};
var XM = class {
  isInstanceAvailable() {
    return this.layerInstance ? true : (te.error("layerInstance is not available"), false);
  }
};
var wu = class extends XM {
  constructor({
    gm: e,
    layerId: r,
    options: s
  }) {
    super();
    __publicField(this, "gm");
    __publicField(this, "layerInstance", null);
    __publicField(this, "mapInstance");
    this.gm = e, this.mapInstance = this.gm.mapAdapter.mapInstance, s ? this.layerInstance = this.createLayer(s) : this.layerInstance = this.mapInstance.getLayer(r) || null;
  }
  get id() {
    if (!this.isInstanceAvailable())
      throw new Error("Layer instance is not available");
    return this.layerInstance.id;
  }
  get source() {
    if (!this.isInstanceAvailable())
      throw new Error("Layer instance is not available");
    return this.layerInstance.source;
  }
  createLayer(e) {
    let r = this.mapInstance.getLayer(e.id);
    return r ? te.warn(`Layer "${e.id}" already exists, skipping`) : (this.mapInstance.addLayer(e), r = this.mapInstance.getLayer(e.id)), r ?? null;
  }
  remove() {
    this.isInstanceAvailable() && this.mapInstance.removeLayer(this.id), this.layerInstance = null;
  }
};
var WM = class extends Gl {
  constructor({
    mapInstance: e,
    options: r,
    lngLat: s
  }) {
    super();
    __publicField(this, "markerInstance");
    this.markerInstance = new import_maplibre_gl.default.Marker(r).setLngLat(s).addTo(e);
  }
  getElement() {
    var _a6;
    return this.isMarkerInstanceAvailable() && ((_a6 = this.markerInstance) == null ? void 0 : _a6.getElement()) || null;
  }
  setLngLat(e) {
    var _a6;
    this.isMarkerInstanceAvailable() && ((_a6 = this.markerInstance) == null ? void 0 : _a6.setLngLat(e));
  }
  getLngLat() {
    var _a6;
    return this.isMarkerInstanceAvailable() ? ((_a6 = this.markerInstance) == null ? void 0 : _a6.getLngLat().toArray()) || [0, 0] : [0, 0];
  }
  remove() {
    var _a6;
    (_a6 = this.markerInstance) == null ? void 0 : _a6.remove();
  }
};
var jM = class {
  isInstanceAvailable() {
    return this.popupInstance ? true : (te.error("Popup instance is not available"), false);
  }
};
var ZM = class extends jM {
  constructor({
    mapInstance: e,
    options: r,
    lngLat: s
  }) {
    super();
    __publicField(this, "popupInstance");
    this.popupInstance = new import_maplibre_gl.default.Popup(r).addTo(e), s && this.setLngLat(s);
  }
  getLngLat() {
    return this.isInstanceAvailable() ? this.popupInstance.getLngLat().toArray() || [0, 0] : [0, 0];
  }
  setLngLat(e) {
    this.isInstanceAvailable() && this.popupInstance.setLngLat(e);
  }
  setHtml(e) {
    this.isInstanceAvailable() && this.popupInstance.setHTML(e);
  }
  remove() {
    this.isInstanceAvailable() && this.popupInstance.remove();
  }
};
var Xf = class extends JM {
  constructor({ gm: e, geoJson: r, sourceId: s }) {
    super();
    __publicField(this, "gm");
    __publicField(this, "mapInstance");
    __publicField(this, "sourceInstance");
    this.gm = e, this.mapInstance = this.gm.mapAdapter.mapInstance, r ? this.sourceInstance = this.createSource({ geoJson: r, sourceId: s }) : this.sourceInstance = this.mapInstance.getSource(s) || null;
  }
  get id() {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    return this.sourceInstance.id;
  }
  get loaded() {
    return this.mapInstance.isSourceLoaded(this.id);
  }
  createSource({ geoJson: e, sourceId: r }) {
    let s = this.mapInstance.getSource(r);
    return s ? te.warn(`Source "${s.id}" already exists, skipping`) : (this.mapInstance.addSource(r, {
      type: "geojson",
      data: e,
      promoteId: qt
    }), s = this.mapInstance.getSource(r)), s ?? null;
  }
  getGeoJson() {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    return this.sourceInstance.serialize().data;
  }
  getGmGeoJson() {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    const e = {
      type: "FeatureCollection",
      features: []
    };
    return this.gm.features.filteredForEach(
      (s) => {
        var _a6;
        return s.source.id === ((_a6 = this.sourceInstance) == null ? void 0 : _a6.id);
      }
    )((s) => {
      or.includes(s.shape) && e.features.push(s.getGeoJson());
    }), e;
  }
  async setData(e) {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    await this.sourceInstance.setData(e, true);
  }
  async updateData(e) {
    if (!this.isInstanceAvailable())
      return;
    const r = this.convertUniversalDiffToMlDiff(e);
    await this.sourceInstance.updateData(r, true);
  }
  convertUniversalDiffToMlDiff(e) {
    var _a6, _b2;
    return {
      add: (_a6 = e.add) == null ? void 0 : _a6.map(this.sanitizeFeatureForAdd.bind(this)),
      update: (_b2 = e.update) == null ? void 0 : _b2.map(this.convertFeatureToMlUpdateDiff.bind(this)),
      remove: e.remove
    };
  }
  /**
   * Sanitize a feature for addition to the source by removing undefined property values.
   * MapLibre's protobuf encoding does not support undefined values (per MapBox vector tile spec).
   */
  sanitizeFeatureForAdd(e) {
    if (!e.properties)
      return e;
    const r = {};
    for (const [s, u] of Object.entries(e.properties))
      u !== void 0 && (r[s] = u);
    return {
      ...e,
      properties: r
    };
  }
  convertFeatureToMlUpdateDiff(e) {
    var _a6;
    const r = [], s = [];
    return Object.entries(e.properties || {}).forEach(([u, l]) => {
      l === void 0 ? s.push(u) : r.push({ key: u, value: l });
    }), {
      id: (_a6 = e.properties) == null ? void 0 : _a6[qt],
      newGeometry: e.geometry,
      addOrUpdateProperties: r,
      removeProperties: s
    };
  }
  remove() {
    this.isInstanceAvailable() && (this.gm.mapAdapter.eachLayer((e) => {
      e.source === this.sourceInstance.id && this.gm.mapAdapter.removeLayer(e.id);
    }), this.mapInstance.removeSource(this.sourceInstance.id));
  }
};
var KM = [
  "click",
  "dblclick",
  "mousedown",
  "mouseup",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "contextmenu",
  "touchstart",
  "touchend",
  "touchcancel"
];
var ku = (t) => KM.includes(t);
var QM = class extends VM {
  constructor(e, r) {
    super();
    __publicField(this, "gm");
    __publicField(this, "mapType", "maplibre");
    __publicField(this, "mapInstance");
    this.gm = r, this.mapInstance = e;
  }
  getMapInstance() {
    return this.mapInstance;
  }
  isLoaded() {
    return this.mapInstance._loaded;
  }
  getContainer() {
    return this.mapInstance.getContainer();
  }
  getCanvas() {
    return this.mapInstance.getCanvas();
  }
  addControl(e) {
    this.mapInstance.addControl(e);
  }
  removeControl(e) {
    this.mapInstance.removeControl(e);
  }
  async loadImage({ id: e, image: r }) {
    if (!this.mapInstance.hasImage(e)) {
      const s = await this.mapInstance.loadImage(r);
      this.mapInstance.addImage(e, s.data);
    }
  }
  removeImage(e) {
    try {
      this.mapInstance.hasImage(e) && this.mapInstance.removeImage(e);
    } catch {
    }
  }
  getBounds() {
    return this.mapInstance.getBounds().toArray();
  }
  fitBounds(e, r) {
    this.mapInstance.fitBounds(e, r);
  }
  setCursor(e) {
    this.mapInstance.getCanvas().style.cursor = e;
  }
  disableMapInteractions(e) {
    e.forEach((r) => {
      this.mapInstance[r].disable();
    });
  }
  enableMapInteractions(e) {
    e.forEach((r) => {
      this.mapInstance[r].enable();
    });
  }
  setDragPan(e) {
    e ? this.mapInstance.dragPan.enable() : this.mapInstance.dragPan.disable();
  }
  queryFeaturesByScreenCoordinates({
    queryCoordinates: e = void 0,
    sourceNames: r
  }) {
    return Eh(
      this.mapInstance.queryRenderedFeatures(e).map((u) => ({
        featureId: u.properties[qt],
        featureSourceName: u.source
      })),
      Wi
    ).map(({ featureId: u, featureSourceName: l }) => u === void 0 || !r.includes(l) ? null : this.gm.features.get(l, u) || null).filter((u) => !!u);
  }
  queryGeoJsonFeatures({
    queryCoordinates: e = void 0,
    sourceNames: r
  }) {
    const s = (l, f) => (l == null ? void 0 : l.id) === (f == null ? void 0 : f.id);
    return Eh(
      this.mapInstance.queryRenderedFeatures(e).map((l) => {
        const f = this.convertToGeoJsonImportFeature(l);
        return f ? {
          id: l.properties[qt],
          sourceName: l.source,
          geoJson: f
        } : null;
      }),
      s
    ).filter((l) => !!l && l.id !== void 0 && l.geoJson && r.includes(l.sourceName));
  }
  convertToGeoJsonImportFeature(e) {
    const r = e.properties[qt];
    return r === void 0 || e.geometry.type === "GeometryCollection" ? null : {
      id: r,
      type: "Feature",
      properties: e.properties,
      geometry: e.geometry
    };
  }
  addSource(e, r) {
    return new Xf({ gm: this.gm, sourceId: e, geoJson: r });
  }
  getSource(e) {
    return new Xf({ gm: this.gm, sourceId: e });
  }
  addLayer(e) {
    const r = e.id;
    return new wu({ gm: this.gm, layerId: r, options: e });
  }
  getLayer(e) {
    return this.mapInstance.getLayer(e) ? new wu({ gm: this.gm, layerId: e }) : null;
  }
  removeLayer(e) {
    const r = this.getLayer(e);
    r && r.remove();
  }
  eachLayer(e) {
    this.mapInstance.getStyle().layers.forEach((r) => {
      e(new wu({ gm: this.gm, layerId: r.id }));
    });
  }
  createDomMarker(e, r) {
    return new WM({
      mapInstance: this.mapInstance,
      options: e,
      lngLat: r
    });
  }
  createPopup(e, r) {
    return new ZM({
      mapInstance: this.mapInstance,
      options: e,
      lngLat: r
    });
  }
  project(e) {
    const r = this.mapInstance.project(e);
    return [r.x, r.y];
  }
  unproject(e) {
    const r = this.mapInstance.unproject(e);
    return [r.lng, r.lat];
  }
  coordBoundsToScreenBounds(e) {
    const r = new import_maplibre_gl.default.LngLatBounds(e), s = this.project(r.getSouthWest().toArray()), u = this.project(r.getNorthEast().toArray());
    return [s, u];
  }
  fire(e, r) {
    this.mapInstance.fire(e, r);
  }
  on(e, r, s) {
    if (typeof r == "string" && s && ku(e))
      this.mapInstance.on(e, r, s);
    else if (typeof r == "function")
      this.mapInstance.on(e, r);
    else
      throw new Error("Invalid arguments passed to 'on' method");
  }
  once(e, r, s) {
    if (typeof r == "string" && s && ku(e))
      this.mapInstance.once(e, r, s);
    else if (typeof r == "function")
      this.mapInstance.once(e, r);
    else
      throw new Error("Invalid arguments passed to 'once' method.");
  }
  off(e, r, s) {
    if (typeof r == "string" && s && ku(e))
      this.mapInstance.off(e, r, s);
    else if (typeof r == "function")
      this.mapInstance.off(e, r);
    else
      throw new Error("Invalid arguments passed to 'off' method");
  }
};
var eI = (t, e) => new QM(e, t);
var tI = (t, e) => {
  if (!Array.isArray(t) || !Array.isArray(e))
    return;
  if (e.some((u) => !Vk(u))) {
    te.warn("Wrong partial layer detected for layer styles");
    return;
  }
  const r = EE(t, "type"), s = sE(e, "type");
  if (Object.values(s).some((u) => u > 1))
    throw new Error(
      'Multiple layers for the same shape are detected. Use "useDefaultLayers: false" and define layers manually.'
    );
  return e.forEach((u) => {
    r[u.type] ? xE(r[u.type], u) : r[u.type] = $t(u);
  }), pE(r);
};
var nI = class {
  constructor(e, r) {
    __publicField(this, "gm");
    __publicField(this, "settings");
    __publicField(this, "controls");
    __publicField(this, "layerStyles");
    this.gm = e;
    const s = this.getMergedOptions(r);
    this.settings = s.settings, this.controls = s.controls, this.layerStyles = s.layerStyles;
  }
  getMergedOptions(e = {}) {
    var _a6;
    const r = Pu();
    return typeof ((_a6 = e.settings) == null ? void 0 : _a6.controlsUiEnabledByDefault) == "boolean" && (r.settings.controlsUiEnabledByDefault = e.settings.controlsUiEnabledByDefault), FE(r), hE(r, e, tI);
  }
  enableMode(e, r) {
    const s = this.isModeEnabled(e, r), u = this.isModeAvailable(e, r);
    if (u || te.warn(`Unable to enable mode, "${e}:${r}" is not available`), s || !u)
      return;
    const f = this.controls[e][r];
    f ? (f.active = true, this.fireModeEvent(e, r, "mode_start"), this.fireControlEvent(e, r, "on"), this.fireModeEvent(e, r, "mode_started")) : te.error("Can't find control section for", e, r);
  }
  disableMode(e, r) {
    const s = this.isModeEnabled(e, r), u = this.isModeAvailable(e, r);
    if (!s || !u)
      return;
    const f = this.controls[e][r];
    f ? (f.active = false, this.fireModeEvent(e, r, "mode_end"), this.fireControlEvent(e, r, "off"), this.fireModeEvent(e, r, "mode_ended")) : te.error("Can't find control section for", e, r);
  }
  syncModeState(e, r) {
    const u = this.controls[e][r], l = this.isModeAvailable(e, r);
    u && (l ? u.active ? this.enableMode(e, r) : this.disableMode(e, r) : (console.log(`Not available mode: ${e}:${r}`), u.active = false, u.uiEnabled = false));
  }
  toggleMode(e, r) {
    this.isModeEnabled(e, r) ? this.disableMode(e, r) : this.enableMode(e, r);
  }
  isModeEnabled(e, r) {
    return !!Object.entries(this.gm.actionInstances).find(([s, u]) => s === `${e}__${r}` && u);
  }
  isModeAvailable(e, r) {
    return e === "draw" && Cr(r, Od) ? !!this.gm.drawClassMap[r] : e === "edit" && Cr(r, Dd) ? !!this.gm.editClassMap[r] : e === "helper" && Cr(r, Rd) ? !!this.gm.helperClassMap[r] : false;
  }
  getControlOptions({
    modeType: e,
    modeName: r
  }) {
    return e && r && this.controls[e][r] || null;
  }
  fireModeEvent(e, r, s) {
    const u = {
      name: `${se}:${r}:mode`,
      level: "system",
      actionType: e,
      mode: r,
      action: s
    };
    rc(u) && (Zl(u) ? this.gm.events.fire(`${se}:${e}`, u) : es(u) ? this.gm.events.fire(`${se}:${e}`, u) : Wl(u) ? this.gm.events.fire(`${se}:${e}`, u) : te.warn("Unknown mode event: ", u));
  }
  fireControlEvent(e, r, s) {
    const u = {
      name: `${se}:control:switch`,
      level: "system",
      actionType: "control",
      section: e,
      mode: r,
      action: s
    };
    this.gm.events.fire(`${se}:control`, u);
  }
};
var rI = class {
  constructor(e) {
    __publicField(this, "gm");
    __publicField(this, "marker", null);
    __publicField(this, "tmpMarker", null);
    __publicField(this, "snapping", false);
    __publicField(this, "oldSnapping");
    this.gm = e, this.initEventHandlers();
  }
  get snappingHelper() {
    return this.gm.actionInstances.helper__snapping || null;
  }
  initEventHandlers() {
    this.throttledMethods = ci(
      {
        onMouseMove: this.onMouseMove
      },
      this,
      this.gm.options.settings.throttlingDelay
    ), this.eventHandlers = {
      mousemove: this.throttledMethods.onMouseMove.bind(this)
    };
  }
  setSnapping(e) {
    if (e && !this.snappingHelper) {
      te.error("MarkerPointer: snapping is not available");
      return;
    }
    this.snapping = e;
  }
  pauseSnapping() {
    this.oldSnapping !== void 0 && te.error("MarkerPointer: snapping is already paused"), this.oldSnapping = this.snapping, this.setSnapping(false);
  }
  resumeSnapping() {
    this.oldSnapping === void 0 ? (te.error("MarkerPointer: resumeSnapping is called before pauseSnapping"), this.setSnapping(true)) : (this.setSnapping(this.oldSnapping), this.oldSnapping = void 0);
  }
  enable({ lngLat: e, customMarker: r, invisibleMarker: s } = {
    lngLat: [0, 0],
    customMarker: void 0,
    invisibleMarker: false
  }) {
    if (!qk()) {
      if (r && s)
        throw new Error("MarkerPointer: customMarker and invisibleMarker can't be used together");
      if (this.marker)
        throw new Error("MarkerPointer: marker is already enabled");
      this.gm.events.bus.attachEvents(this.eventHandlers), s ? this.marker = this.createInvisibleMarker(e || [0, 0]) : this.marker = r || this.createMarker(e || [0, 0]), this.gm.getActiveDrawModes().length && this.gm.mapAdapter.setCursor("crosshair");
    }
  }
  disable() {
    this.marker && (this.gm.events.bus.detachEvents(this.eventHandlers), this.marker.remove(), this.marker = null), this.gm.mapAdapter.setCursor("");
  }
  createMarker(e = [0, 0]) {
    return this.gm.mapAdapter.createDomMarker(
      {
        anchor: "center",
        element: this.gm.createSvgMarkerElement("control", { pointerEvents: "none" })
      },
      e
    );
  }
  createInvisibleMarker(e = [0, 0]) {
    const r = document.createElement("div");
    return r.style.width = "0px", r.style.height = "0px", this.gm.mapAdapter.createDomMarker(
      {
        anchor: "center",
        element: r
      },
      e
    );
  }
  onMouseMove(e) {
    if (Ke(e, { warning: true }) && this.marker)
      if (this.snapping && this.snappingHelper) {
        const r = [e.point.x, e.point.y], s = this.snappingHelper.getSnappedLngLat(e.lngLat.toArray(), r);
        this.marker.setLngLat(s);
      } else
        this.marker.setLngLat(e.lngLat.toArray());
    return { next: true };
  }
  syncTmpMarker(e) {
    this.tmpMarker || (this.tmpMarker = this.createMarker(e)), this.tmpMarker.setLngLat(e);
  }
};
var kI = {
  type: "Feature",
  properties: {
    shape: "polygon"
  },
  geometry: {
    type: "MultiPolygon",
    coordinates: [
      [
        [
          [4, 51.2],
          [5.4, 52.4],
          [6.8, 51.2],
          [4, 51.2]
        ]
      ]
    ]
  }
};
var SI = {
  type: "Feature",
  properties: {
    shape: "rectangle"
  },
  geometry: {
    type: "Polygon",
    coordinates: [
      [
        [-0.47, 51.67],
        [1.43, 51.67],
        [1.43, 53.32],
        [-0.47, 53.32],
        [-0.47, 51.67]
      ]
    ]
  }
};
var MI = (t) => Sn(t) && t.name === `${se}:feature:before_create`;
var II = (t) => Sn(t) && t.name === `${se}:feature:before_update`;
var iI = ["mode_start", "mode_started", "mode_end", "mode_ended"];
var rc = (t) => Sn(t) && Cr(t.action, iI);
var sI = (t) => t.length > 0;
function aI(t, e = {}) {
  const r = [];
  if (Rr(t, (u) => {
    r.push(u.coordinates);
  }), r.length < 2)
    throw new Error("Must have at least 2 geometries");
  const s = gM(r[0], ...r.slice(1));
  return s.length === 0 ? null : s.length === 1 ? fr(s[0], e.properties) : Bl(s, e.properties);
}
var oI = aI;
var bI = class extends ts {
  constructor() {
    super(...arguments);
    __publicField(this, "features", []);
    __publicField(this, "featureData", null);
    __publicField(this, "eventHandlers", {
      click: this.onMouseClick.bind(this)
    });
  }
  onStartAction() {
  }
  onEndAction() {
    this.features.forEach((e) => {
      e.changeSource({ sourceName: K.main, atomic: true });
    }), this.features = [];
  }
  onMouseClick(e) {
    if (!Ke(e))
      return { next: true };
    if (this.unselectFeature(e))
      return { next: true };
    const s = this.getAllowedFeatureByMouseEvent({ event: e, sourceNames: [K.main] });
    return s && this.isFeatureAllowedToGroup(s) && (s.changeSource({ sourceName: K.temporary, atomic: true }), this.features.push(s)), this.features.length > 1 ? (this.groupFeatures(), { next: true }) : { next: true };
  }
  unselectFeature(e) {
    const r = this.getAllowedFeatureByMouseEvent({
      event: e,
      sourceNames: [K.temporary]
    });
    if (r) {
      const s = this.features.findIndex((u) => u === r);
      return s > -1 && this.features.splice(s, 1), r.changeSource({ sourceName: K.main, atomic: true }), true;
    }
    return false;
  }
  getAllowedFeatureByMouseEvent({
    event: e,
    sourceNames: r
  }) {
    const s = this.getFeatureByMouseEvent({ event: e, sourceNames: r });
    return s && this.allowedShapeTypes.includes(s.shape) ? s : null;
  }
  isFeatureAllowedToGroup(e) {
    if (!this.allowedShapeTypes.includes(e.shape))
      return false;
    if (this.features.length === 0)
      return true;
    const r = e.getGeoJson();
    return this.features.every(
      (s) => Sp(s.getGeoJson(), r)
    );
  }
  groupFeatures() {
    if (!this.features.length) {
      te.error("BaseGroupEdit.groupFeatures: no features to group");
      return;
    }
    const e = {
      type: "FeatureCollection",
      features: this.features.map((s) => {
        const u = s.getGeoJson();
        return ["Polygon", "MultiPolygon"].includes(u.geometry.type) ? u : null;
      }).filter((s) => !!s)
    };
    let r = null;
    if (this.mode === "union" ? r = oI(e) : this.mode === "difference" && (r = Tp(e)), r) {
      const s = this.gm.features.createFeature({
        shapeGeoJson: {
          ...r,
          properties: {
            ...r.properties,
            shape: "polygon"
          }
        },
        sourceName: K.main
      });
      this.features.forEach((u) => {
        this.gm.features.delete(u);
      }), s && sI(this.features) && this.fireFeatureUpdatedEvent({
        sourceFeatures: this.features,
        targetFeatures: [s]
      }), this.features = [];
    }
  }
};
var uI = class {
  constructor(e, r = {}) {
    __publicField(this, "mapAdapterInstance", null);
    __publicField(this, "globalLngLatBounds", this.getGlobalLngLatBounds());
    __publicField(this, "features");
    __publicField(this, "loaded", false);
    __publicField(this, "destroyed", false);
    __publicField(this, "options");
    __publicField(this, "events");
    __publicField(this, "control");
    __publicField(this, "actionInstances", {});
    __publicField(this, "markerPointer");
    this.options = this.initCoreOptions(r), this.events = this.initCoreEvents(), this.features = this.initCoreFeatures(), this.control = this.initCoreControls(), this.markerPointer = this.initMarkerPointer();
    const s = Object.assign(e, { gm: this });
    this.mapAdapterInstance = eI(this, s), this.waitForBaseMap().then(this.init.bind(this)).catch((u) => {
      te.error("Geoman initialization failed:", u), this.destroy();
    });
  }
  get drawClassMap() {
    return Ku;
  }
  get editClassMap() {
    return hl;
  }
  get helperClassMap() {
    return fl;
  }
  get mapAdapter() {
    if (this.mapAdapterInstance)
      return this.mapAdapterInstance;
    throw te.trace("Map adapter is not initialized"), new Error("Map adapter is not initialized");
  }
  initCoreOptions(e = {}) {
    return new nI(this, e);
  }
  initCoreEvents() {
    return new YM(this);
  }
  initCoreFeatures() {
    return new $M(this);
  }
  initCoreControls() {
    return new ak(this);
  }
  initMarkerPointer() {
    return new rI(this);
  }
  addControls(e = void 0) {
    return new Promise((r) => {
      (async () => {
        e ? this.control.createControls(e) : this.mapAdapter.addControl(this.control), await this.onMapLoad(), r();
      })().then();
    });
  }
  async waitForBaseMap() {
    const e = this.mapAdapter.mapInstance;
    if (!Jk(e)) {
      te.error('Map instance does not have a "once" method', e);
      return;
    }
    return this.mapAdapter.isLoaded() || await Qh(
      new Promise((r) => {
        const s = () => r(e);
        e.once("load", s), this.mapAdapter.isLoaded() && (e.off("load", s), r(e));
      }),
      "waitForBaseMap failed"
    ), e;
  }
  async waitForGeomanLoaded() {
    if (this.loaded)
      return this;
    if (this.destroyed)
      return;
    const e = await this.waitForBaseMap();
    if (!e) {
      te.error("Map instance is not available", e);
      return;
    }
    const r = `${ut}:loaded`;
    return await Qh(
      new Promise((s) => {
        const u = () => s(this);
        e.once(r, u), this.loaded && (e.off(r, u), s(this));
      }),
      "waitForGeomanLoaded failed"
    ), this;
  }
  async init() {
    this.destroyed || (this.features.init(), !this.destroyed && await this.addControls());
  }
  /**
   * Destroys the Geoman instance and cleans up resources.
   *
   * This method can be called at any point in the lifecycle:
   * - Before initialization completes: cancels pending init and cleans up synchronously
   * - After initialization completes: performs full cleanup including controls
   *
   * For React StrictMode compatibility, this method performs synchronous cleanup
   * of the `gm` reference on the map instance, allowing immediate re-initialization.
   */
  async destroy({ removeSources: e } = { removeSources: false }) {
    if (this.destroyed = true, this.mapAdapterInstance && "gm" in this.mapAdapterInstance.mapInstance && delete this.mapAdapterInstance.mapInstance.gm, this.loaded ? (this.removeControls(), this.mapAdapter.removeImage("default-marker")) : this.events.bus.detachAllEvents(), e)
      for (const r of Object.values(this.features.sources))
        r && r.remove();
  }
  removeControls() {
    this.disableAllModes(), this.mapAdapter.removeControl(this.control);
  }
  async onMapLoad() {
    if (this.loaded || this.destroyed || (await this.mapAdapter.loadImage({
      id: "default-marker",
      image: bm
    }), this.destroyed))
      return;
    const e = {
      name: `${se}:control:load`,
      level: "system",
      actionType: "control",
      action: "loaded"
    };
    this.events.fire(`${se}:control`, e), this.loaded = true;
  }
  disableAllModes() {
    et(this.actionInstances).forEach((e) => {
      const [r, s] = e.split("__");
      O2(r) && G2(s) && this.options.disableMode(r, s);
    });
  }
  getActiveDrawModes() {
    return et(this.actionInstances).map((e) => {
      const r = this.actionInstances[e];
      return r instanceof yr ? r.mode : null;
    }).filter((e) => e !== null);
  }
  getActiveEditModes() {
    return et(this.actionInstances).map((e) => {
      const r = this.actionInstances[e];
      return r instanceof ts ? r.mode : null;
    }).filter((e) => e !== null);
  }
  getActiveHelperModes() {
    return et(this.actionInstances).map((e) => {
      const r = this.actionInstances[e];
      return r instanceof Dr ? r.mode : null;
    }).filter((e) => e !== null);
  }
  getGlobalLngLatBounds() {
    const e = 85.051129;
    return [
      [-179.99999, -e],
      [179.99999, e]
    ];
  }
  setGlobalEventsListener(e = null) {
    this.events.bus.forwarder.globalEventsListener = e;
  }
  createSvgMarkerElement(e, r = void 0) {
    const s = this.options.settings.markerIcons;
    s[e] || te.error(`createMarkerElement: marker type "${e}" not found`);
    const u = document.createElement("div");
    u.classList.add("marker-wrapper"), u.style.lineHeight = "0", u.innerHTML = s[e] || "NO_ICON";
    const l = u.firstChild;
    if (typeof l != "object")
      throw te.error(`createMarkerElement: no icon "${e}" found`), new Error(`No icon "${e}" found`);
    return r && Object.assign(l.style, r), u;
  }
  enableMode(e, r) {
    this.options.enableMode(e, r);
  }
  disableMode(e, r) {
    this.options.disableMode(e, r);
  }
  toggleMode(e, r) {
    this.options.toggleMode(e, r);
  }
  isModeEnabled(e, r) {
    return this.options.isModeEnabled(e, r);
  }
  // helper methods for compatibility with the old API
  // draw (draw:*)
  enableDraw(e) {
    this.options.enableMode("draw", e);
  }
  disableDraw() {
    this.getActiveDrawModes().forEach((e) => this.options.disableMode("draw", e));
  }
  toggleDraw(e) {
    this.options.toggleMode("draw", e);
  }
  drawEnabled(e) {
    return this.options.isModeEnabled("draw", e);
  }
  // drag(edit:drag)
  enableGlobalDragMode() {
    this.options.enableMode("edit", "drag");
  }
  disableGlobalDragMode() {
    this.options.disableMode("edit", "drag");
  }
  toggleGlobalDragMode() {
    this.options.toggleMode("edit", "drag");
  }
  globalDragModeEnabled() {
    return this.options.isModeEnabled("edit", "drag");
  }
  // edit (edit:change)
  enableGlobalEditMode() {
    this.options.enableMode("edit", "change");
  }
  disableGlobalEditMode() {
    this.options.disableMode("edit", "change");
  }
  toggleGlobalEditMode() {
    this.options.toggleMode("edit", "change");
  }
  globalEditModeEnabled() {
    return this.options.isModeEnabled("edit", "change");
  }
  // rotate (edit:rotate)
  enableGlobalRotateMode() {
    this.options.enableMode("edit", "rotate");
  }
  disableGlobalRotateMode() {
    this.options.disableMode("edit", "rotate");
  }
  toggleGlobalRotateMode() {
    this.options.toggleMode("edit", "rotate");
  }
  globalRotateModeEnabled() {
    return this.options.isModeEnabled("edit", "rotate");
  }
  // cut (edit:cut)
  enableGlobalCutMode() {
    this.options.enableMode("edit", "cut");
  }
  disableGlobalCutMode() {
    this.options.disableMode("edit", "cut");
  }
  toggleGlobalCutMode() {
    this.options.toggleMode("edit", "cut");
  }
  globalCutModeEnabled() {
    return this.options.isModeEnabled("edit", "cut");
  }
  // remove (edit:delete)
  enableGlobalRemovalMode() {
    this.options.enableMode("edit", "delete");
  }
  disableGlobalRemovalMode() {
    this.options.disableMode("edit", "delete");
  }
  toggleGlobalRemovalMode() {
    this.options.toggleMode("edit", "delete");
  }
  globalRemovalModeEnabled() {
    return this.options.isModeEnabled("edit", "delete");
  }
};
var AI = async (t, e) => {
  const r = new uI(t, e);
  if (!await r.waitForGeomanLoaded() || r.destroyed)
    throw new Error("Geoman initialization failed");
  return r;
};
export {
  jl as BaseAction,
  Gl as BaseDomMarker,
  nc as BaseDrag,
  yr as BaseDraw,
  ts as BaseEdit,
  bI as BaseGroupEdit,
  Dr as BaseHelper,
  XM as BaseLayer,
  VM as BaseMapAdapter,
  jM as BasePopup,
  JM as BaseSource,
  Od as DRAW_MODES,
  Dd as EDIT_MODES,
  gk as EXTRA_DRAW_MODES,
  qt as FEATURE_ID_PROPERTY,
  mt as FEATURE_PROPERTY_PREFIX,
  Bs as FeatureData,
  ut as GM_PREFIX,
  uI as Geoman,
  nI as GmOptions,
  Rd as HELPER_MODES,
  at as IS_PRO,
  ec as LineDrawer,
  rI as MarkerPointer,
  or as SHAPE_NAMES,
  K as SOURCES,
  GM as ShapeMarkersHelper,
  fI as boundsContains,
  Tk as boundsToBBox,
  gI as calculatePerimeter,
  wt as controlIcons,
  dI as convertToLineStringFeatureCollection,
  ci as convertToThrottled,
  AI as createGeomanInstance,
  SI as customShapeRectangle,
  kI as customShapeTriangle,
  rv as defaultLayerStyles,
  Ku as drawClassMap,
  aa as eachCoordinateWithPath,
  Jl as eachSegmentWithPath,
  hl as editClassMap,
  Lk as findCoordinateWithPath,
  wI as formatArea,
  xI as formatDistance,
  Zu as geoJsonPointToLngLat,
  qa as getEuclideanDistance,
  Pk as getEuclideanSegmentNearestPoint,
  cu as getGeoJsonCoordinatesCount,
  Zd as getGeoJsonFirstPoint,
  lu as getLngLatDiff,
  fl as helperClassMap,
  Cr as includesWithType,
  yI as isActionType,
  vI as isBaseMapEventName,
  R2 as isDrawModeName,
  D2 as isEditModeName,
  Wh as isEqualPosition,
  Ra as isGeoJsonFeatureInPolygon,
  Cd as isGmControlEvent,
  Zl as isGmDrawEvent,
  pI as isGmDrawFreehandDrawerEvent,
  ep as isGmDrawLineDrawerEvent,
  Qd as isGmDrawShapeEvent,
  es as isGmEditEvent,
  Sn as isGmEvent,
  MI as isGmFeatureBeforeCreateEvent,
  II as isGmFeatureBeforeUpdateEvent,
  Wl as isGmHelperEvent,
  rc as isGmModeEvent,
  F2 as isHelperModeName,
  Ke as isMapPointerEvent,
  Jk as isMapWithOnceMethod,
  G2 as isModeName,
  Hl as isMultiPolygonFeature,
  sI as isNonEmptyArray,
  mI as isPointerEventName,
  Yl as isPolygonFeature,
  Gk as lngLatToGeoJsonPoint,
  tI as mergeByTypeCustomizer,
  EI as moveFeatureData,
  RS as moveGeoJson,
  zS as toMod,
  hI as twoCoordsToLineString,
  et as typedKeys
};
//# sourceMappingURL=@geoman-io_maplibre-geoman-free.js.map
